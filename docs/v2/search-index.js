window.searchResultTemplate = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='  <div class="ds-suggestion">\n    <div class="cs-docsearch-suggestion cs-docsearch-suggestion__main cs-docsearch-suggestion__secondary" style="white-space: normal;">\n      <div class="cs-docsearch-suggestion--category-header">\n        <span class="cs-docsearch-suggestion--category-header-lvl0">'+
((__t=( section ))==null?'':__t)+
'</span>\n      </div>\n      '+
((__t=( results ))==null?'':__t)+
'\n  </div>\n</div>';
}
return __p;
};
window.searchResultsListTemplate = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="cs-docsearch-suggestion--wrapper searchWrapper" data-href="'+
((__t=( section ))==null?'':__t)+
'">\n  <div class="cs-docsearch-suggestion--content">\n    <div class="cs-docsearch-suggestion--title">\n      '+
((__t=( title ))==null?'':__t)+
'\n    </div>\n    <div class="cs-docsearch-suggestion--text">'+
((__t=( content ))==null?'':__t)+
'</div>\n  </div>\n</div>';
}
return __p;
};
window.searchCollection = {"tree":{"introduction":{"title":"","parent":false,"dataLevel":2},"overview":{"title":"Overview","parent":false,"dataLevel":2},"coffeescript-2":{"title":"CoffeeScript 2","parent":false,"dataLevel":2},"whats-new-in-coffeescript-2":{"title":"What’s New In CoffeeScript 2?","parent":"coffeescript-2","dataLevel":2},"compatibility":{"title":"Compatibility","parent":"coffeescript-2","dataLevel":2},"installation":{"title":"Installation","parent":false,"dataLevel":false},"usage":{"title":"Usage","parent":false,"dataLevel":2},"cli":{"title":"Command Line","parent":"usage","dataLevel":2},"nodejs-usage":{"title":"Node.js","parent":"usage","dataLevel":2},"transpilation":{"title":"Transpilation","parent":"usage","dataLevel":2},"language":{"title":"Language Reference","parent":false,"dataLevel":1},"functions":{"title":"Functions","parent":"language","dataLevel":1},"strings":{"title":"Strings","parent":"language","dataLevel":1},"objects-and-arrays":{"title":"Objects and Arrays","parent":"language","dataLevel":1},"comments":{"title":"Comments","parent":"language","dataLevel":1},"lexical-scope":{"title":"Lexical Scoping and Variable Safety","parent":"language","dataLevel":1},"conditionals":{"title":"If, Else, Unless, and Conditional Assignment","parent":"language","dataLevel":1},"splats":{"title":"Splats, or Rest Parameters/Spread Syntax","parent":"language","dataLevel":1},"loops":{"title":"Loops and Comprehensions","parent":"language","dataLevel":1},"slices":{"title":"Array Slicing and Splicing with Ranges","parent":"language","dataLevel":1},"expressions":{"title":"Everything is an Expression (at least, as much as possible)","parent":"language","dataLevel":1},"operators":{"title":"Operators and Aliases","parent":"language","dataLevel":1},"existential-operator":{"title":"The Existential Operator","parent":"language","dataLevel":1},"chaining":{"title":"Chaining Function Calls","parent":"language","dataLevel":1},"destructuring":{"title":"Destructuring Assignment","parent":"language","dataLevel":1},"fat-arrow":{"title":"Bound (Fat Arrow) Functions","parent":"language","dataLevel":1},"generators":{"title":"Generator Functions","parent":"language","dataLevel":1},"async-functions":{"title":"Async Functions","parent":"language","dataLevel":1},"classes":{"title":"Classes","parent":"language","dataLevel":1},"prototypal-inheritance":{"title":"Prototypal Inheritance","parent":"language","dataLevel":1},"switch":{"title":"Switch/When/Else","parent":"language","dataLevel":1},"try":{"title":"Try/Catch/Finally","parent":"language","dataLevel":1},"comparisons":{"title":"Chained Comparisons","parent":"language","dataLevel":1},"regexes":{"title":"Block Regular Expressions","parent":"language","dataLevel":1},"tagged-template-literals":{"title":"Tagged Template Literals","parent":"language","dataLevel":1},"modules":{"title":"Modules","parent":"language","dataLevel":1},"embedded":{"title":"Embedded JavaScript","parent":"language","dataLevel":1},"jsx":{"title":"JSX","parent":"language","dataLevel":1},"type-annotations":{"title":"Type Annotations","parent":false,"dataLevel":1},"literate":{"title":"Literate CoffeeScript","parent":false,"dataLevel":1},"source-maps":{"title":"Source Maps","parent":false,"dataLevel":1},"cake":{"title":"Cake, and Cakefiles","parent":false,"dataLevel":1},"scripts":{"title":"\"text/coffeescript\" Script Tags","parent":false,"dataLevel":1},"resources":{"title":"Resources","parent":false,"dataLevel":2},"books":{"title":"Books","parent":"resources","dataLevel":2},"screencasts":{"title":"Screencasts","parent":"resources","dataLevel":2},"examples":{"title":"Examples","parent":"resources","dataLevel":2},"chat":{"title":"Web Chat (IRC)","parent":"resources","dataLevel":2},"annotated-source":{"title":"Annotated Source","parent":"resources","dataLevel":2},"contributing":{"title":"Contributing","parent":"resources","dataLevel":2},"unsupported":{"title":"Unsupported ECMAScript Features","parent":false,"dataLevel":2},"unsupported-let-const":{"title":"let and const: block-scoped and reassignment-protected variables","parent":"unsupported","dataLevel":2},"unsupported-named-functions":{"title":"Named functions and function declarations","parent":"unsupported","dataLevel":2},"unsupported-get-set":{"title":"get and set keyword shorthand syntax","parent":"unsupported","dataLevel":2},"breaking-changes":{"title":"Breaking Changes From CoffeeScript 1.x to 2","parent":false,"dataLevel":3},"breaking-changes-fat-arrow":{"title":"Bound (fat arrow) functions","parent":"breaking-changes","dataLevel":3},"breaking-changes-default-values":{"title":"Default values for function parameters and destructured elements","parent":"breaking-changes","dataLevel":3},"breaking-changes-bound-generator-functions":{"title":"Bound generator functions","parent":"breaking-changes","dataLevel":3},"breaking-changes-classes":{"title":"Classes are compiled to ES2015 classes","parent":"breaking-changes","dataLevel":3},"breaking-changes-super-this":{"title":"super and this","parent":"breaking-changes","dataLevel":3},"breaking-changes-super-extends":{"title":"super and extends","parent":"breaking-changes","dataLevel":3},"breaking-changes-jsx-and-the-less-than-and-greater-than-operators":{"title":"JSX and the < and > operators","parent":"breaking-changes","dataLevel":3},"breaking-changes-literate-coffeescript":{"title":"Literate CoffeeScript parsing","parent":"breaking-changes","dataLevel":3},"breaking-changes-argument-parsing-and-shebang-lines":{"title":"Argument parsing and shebang (#!) lines","parent":"breaking-changes","dataLevel":3},"changelog":{"title":"Changelog","parent":false,"dataLevel":3},"2.3.1":{"title":"2.3.1 - 2018-05-21","parent":"changelog","dataLevel":3},"2.3.0":{"title":"2.3.0 - 2018-04-29","parent":"changelog","dataLevel":3},"2.2.4":{"title":"2.2.4 - 2018-03-29","parent":"changelog","dataLevel":3},"2.2.3":{"title":"2.2.3 - 2018-03-11","parent":"changelog","dataLevel":3},"2.2.2":{"title":"2.2.2 - 2018-02-21","parent":"changelog","dataLevel":3},"2.2.1":{"title":"2.2.1 - 2018-02-06","parent":"changelog","dataLevel":3},"2.2.0":{"title":"2.2.0 - 2018-02-01","parent":"changelog","dataLevel":3},"2.1.1":{"title":"2.1.1 - 2017-12-29","parent":"changelog","dataLevel":3},"2.1.0":{"title":"2.1.0 - 2017-12-10","parent":"changelog","dataLevel":3},"2.0.3":{"title":"2.0.3 - 2017-11-26","parent":"changelog","dataLevel":3},"2.0.2":{"title":"2.0.2 - 2017-10-26","parent":"changelog","dataLevel":3},"2.0.1":{"title":"2.0.1 - 2017-09-26","parent":"changelog","dataLevel":3},"2.0.0":{"title":"2.0.0 - 2017-09-18","parent":"changelog","dataLevel":3},"2.0.0-beta5":{"title":"2.0.0-beta5 - 2017-09-02","parent":"changelog","dataLevel":3},"2.0.0-beta4":{"title":"2.0.0-beta4 - 2017-08-03","parent":"changelog","dataLevel":3},"2.0.0-beta3":{"title":"2.0.0-beta3 - 2017-06-30","parent":"changelog","dataLevel":3},"2.0.0-beta2":{"title":"2.0.0-beta2 - 2017-05-16","parent":"changelog","dataLevel":3},"2.0.0-beta1":{"title":"2.0.0-beta1 - 2017-04-14","parent":"changelog","dataLevel":3},"2.0.0-alpha1":{"title":"2.0.0-alpha1 - 2017-02-21","parent":"changelog","dataLevel":3},"1.12.7":{"title":"1.12.7 - 2017-07-16","parent":"changelog","dataLevel":3},"1.12.6":{"title":"1.12.6 - 2017-05-15","parent":"changelog","dataLevel":3},"1.12.5":{"title":"1.12.5 - 2017-04-10","parent":"changelog","dataLevel":3},"1.12.4":{"title":"1.12.4 - 2017-02-18","parent":"changelog","dataLevel":3},"1.12.3":{"title":"1.12.3 - 2017-01-24","parent":"changelog","dataLevel":3},"1.12.2":{"title":"1.12.2 - 2016-12-16","parent":"changelog","dataLevel":3},"1.12.1":{"title":"1.12.1 - 2016-12-07","parent":"changelog","dataLevel":3},"1.12.0":{"title":"1.12.0 - 2016-12-04","parent":"changelog","dataLevel":3},"1.11.1":{"title":"1.11.1 - 2016-10-02","parent":"changelog","dataLevel":3},"1.11.0":{"title":"1.11.0 - 2016-09-24","parent":"changelog","dataLevel":3},"1.10.0":{"title":"1.10.0 - 2015-09-03","parent":"changelog","dataLevel":3},"1.9.3":{"title":"1.9.3 - 2015-05-27","parent":"changelog","dataLevel":3},"1.9.2":{"title":"1.9.2 - 2015-04-15","parent":"changelog","dataLevel":3},"1.9.1":{"title":"1.9.1 - 2015-02-18","parent":"changelog","dataLevel":3},"1.9.0":{"title":"1.9.0 - 2015-01-29","parent":"changelog","dataLevel":3},"1.8.0":{"title":"1.8.0 - 2014-08-26","parent":"changelog","dataLevel":3},"1.7.1":{"title":"1.7.1 - 2014-01-29","parent":"changelog","dataLevel":3},"1.7.0":{"title":"1.7.0 - 2014-01-28","parent":"changelog","dataLevel":3},"1.6.3":{"title":"1.6.3 - 2013-06-02","parent":"changelog","dataLevel":3},"1.6.2":{"title":"1.6.2 - 2013-03-18","parent":"changelog","dataLevel":3},"1.6.1":{"title":"1.6.1 - 2013-03-05","parent":"changelog","dataLevel":3},"1.5.0":{"title":"1.5.0 - 2013-02-25","parent":"changelog","dataLevel":3},"1.4.0":{"title":"1.4.0 - 2012-10-23","parent":"changelog","dataLevel":3},"1.3.3":{"title":"1.3.3 - 2012-05-15","parent":"changelog","dataLevel":3},"1.3.1":{"title":"1.3.1 - 2012-04-10","parent":"changelog","dataLevel":3},"1.2.0":{"title":"1.2.0 - 2011-12-18","parent":"changelog","dataLevel":3},"1.1.3":{"title":"1.1.3 - 2011-11-08","parent":"changelog","dataLevel":3},"1.1.2":{"title":"1.1.2 - 2011-08-04","parent":"changelog","dataLevel":3},"1.1.1":{"title":"1.1.1 - 2011-05-10","parent":"changelog","dataLevel":3},"1.1.0":{"title":"1.1.0 - 2011-05-01","parent":"changelog","dataLevel":3},"1.0.1":{"title":"1.0.1 - 2011-01-31","parent":"changelog","dataLevel":3},"1.0.0":{"title":"1.0.0 - 2010-12-24","parent":"changelog","dataLevel":3},"0.9.6":{"title":"0.9.6 - 2010-12-06","parent":"changelog","dataLevel":3},"0.9.5":{"title":"0.9.5 - 2010-11-21","parent":"changelog","dataLevel":3},"0.9.4":{"title":"0.9.4 - 2010-09-21","parent":"changelog","dataLevel":3},"0.9.3":{"title":"0.9.3 - 2010-09-16","parent":"changelog","dataLevel":3},"0.9.2":{"title":"0.9.2 - 2010-08-23","parent":"changelog","dataLevel":3},"0.9.1":{"title":"0.9.1 - 2010-08-11","parent":"changelog","dataLevel":3},"0.9.0":{"title":"0.9.0 - 2010-08-04","parent":"changelog","dataLevel":3},"0.7.2":{"title":"0.7.2 - 2010-07-12","parent":"changelog","dataLevel":3},"0.7.1":{"title":"0.7.1 - 2010-07-11","parent":"changelog","dataLevel":3},"0.7.0":{"title":"0.7.0 - 2010-06-28","parent":"changelog","dataLevel":3},"0.6.2":{"title":"0.6.2 - 2010-05-15","parent":"changelog","dataLevel":3},"0.6.1":{"title":"0.6.1 - 2010-04-12","parent":"changelog","dataLevel":3},"0.6.0":{"title":"0.6.0 - 2010-04-03","parent":"changelog","dataLevel":3},"0.5.6":{"title":"0.5.6 - 2010-03-23","parent":"changelog","dataLevel":3},"0.5.5":{"title":"0.5.5 - 2010-03-08","parent":"changelog","dataLevel":3},"0.5.4":{"title":"0.5.4 - 2010-03-03","parent":"changelog","dataLevel":3},"0.5.3":{"title":"0.5.3 - 2010-02-27","parent":"changelog","dataLevel":3},"0.5.2":{"title":"0.5.2 - 2010-02-25","parent":"changelog","dataLevel":3},"0.5.1":{"title":"0.5.1 - 2010-02-24","parent":"changelog","dataLevel":3},"0.5.0":{"title":"0.5.0 - 2010-02-21","parent":"changelog","dataLevel":3},"0.3.2":{"title":"0.3.2 - 2010-02-08","parent":"changelog","dataLevel":3},"0.3.0":{"title":"0.3.0 - 2010-01-26","parent":"changelog","dataLevel":3},"0.2.6":{"title":"0.2.6 - 2010-01-17","parent":"changelog","dataLevel":3},"0.2.5":{"title":"0.2.5 - 2010-01-13","parent":"changelog","dataLevel":3},"0.2.4":{"title":"0.2.4 - 2010-01-12","parent":"changelog","dataLevel":3},"0.2.3":{"title":"0.2.3 - 2010-01-11","parent":"changelog","dataLevel":3},"0.2.2":{"title":"0.2.2 - 2010-01-10","parent":"changelog","dataLevel":3},"0.2.1":{"title":"0.2.1 - 2010-01-05","parent":"changelog","dataLevel":3},"0.2.0":{"title":"0.2.0 - 2010-01-05","parent":"changelog","dataLevel":3},"0.1.6":{"title":"0.1.6 - 2009-12-27","parent":"changelog","dataLevel":3},"0.1.5":{"title":"0.1.5 - 2009-12-26","parent":"changelog","dataLevel":3},"0.1.4":{"title":"0.1.4 - 2009-12-25","parent":"changelog","dataLevel":3},"0.1.3":{"title":"0.1.3 - 2009-12-25","parent":"changelog","dataLevel":3},"0.1.2":{"title":"0.1.2 - 2009-12-24","parent":"changelog","dataLevel":3},"0.1.1":{"title":"0.1.1 - 2009-12-24","parent":"changelog","dataLevel":3},"0.1.0":{"title":"0.1.0 - 2009-12-24","parent":"changelog","dataLevel":3}},"data":[{"section":"introduction","title":"","content":"CoffeeScript is a little language that compiles into JavaScript. Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.CoffeeScript is a little language that compiles into JavaScript.The golden rule of CoffeeScript is: “It’s just JavaScript.” The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.“It’s just JavaScript.”Latest Version: 2.3.1Latest Version:2.3.1# Install locally for a project: npm install --save-dev coffeescript # Install globally to execute .coffee files anywhere: npm install --global coffeescript # Install locally for a project: npm install --save-dev coffeescript # Install globally to execute .coffee files anywhere: npm install --global coffeescript # Install locally for a project: npm install --save-dev coffeescript # Install globally to execute .coffee files anywhere: npm install --global coffeescript # Install locally for a project:# Install globally to execute .coffee files anywhere:","dataLevel":2,"level":1,"parent":false},{"section":"overview","title":"Overview","content":"CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!topleftbottomright               # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list)       # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list)                 // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })();       // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })();                           \t cubes                       # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list)       # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list)                 // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })();       // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })();               # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list)       # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list)     # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list) # Assignment: number   = 42 opposite = true # Conditions: number = -42 if opposite # Functions: square = (x) -> x * x # Arrays: list = [1, 2, 3, 4, 5] # Objects: math =   root:   Math.sqrt   square: square   cube:   (x) -> x * square x # Splats: race = (winner, runners...) ->   print winner, runners # Existence: alert \"I knew it!\" if elvis? # Array comprehensions: cubes = (math.cube num for num in list) # Assignment:number=42opposite=true# Conditions:number=-42ifopposite# Functions:square=(x)->x*x# Arrays:list=[1,2,3,4,5]# Objects:math=  root:Math.sqrtsquare:squarecube:(x)->x*squarex# Splats:race=(winner,runners...)->printwinner,runners# Existence:alert\"I knew it!\"ifelvis?# Array comprehensions:cubes=(math.cubenumfornuminlist)       // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })();       // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })();     // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })(); // Assignment: var cubes, list, math, num, number, opposite, race, square; number = 42; opposite = true; if (opposite) {   // Conditions:   number = -42; } // Functions: square = function(x) {   return x * x; }; // Arrays: list = [1, 2, 3, 4, 5]; // Objects: math = {   root: Math.sqrt,   square: square,   cube: function(x) {     return x * square(x);   } }; // Splats: race = function(winner, ...runners) {   return print(winner, runners); }; if (typeof elvis !== \"undefined\" && elvis !== null) {   // Existence:   alert(\"I knew it!\"); } // Array comprehensions: cubes = (function() {   var i, len, results;   results = [];   for (i = 0, len = list.length; i < len; i++) {     num = list[i];     results.push(math.cube(num));   }   return results; })(); // Assignment:varcubeslistmathnumnumberoppositeracesquarenumber=42opposite=trueifopposite// Conditions:number=-42// Functions:square=functionxreturnx*x// Arrays:list=12345// Objects:math=rootMathsqrtsquaresquarecubefunctionxreturnx*squarex// Splats:race=functionwinner...runnersreturnprintwinnerrunnersiftypeofelvis!==\"undefined\"&&elvis!==null// Existence:alert\"I knew it!\"// Array comprehensions:cubes=functionvarilenresultsresults=fori=0len=listlengthi<leni++num=listiresultspushmathcubenumreturnresults             \t cubes                \t cubes      \t cubes \t \t ","dataLevel":2,"level":1,"parent":false},{"section":"coffeescript-2","title":"CoffeeScript 2","content":"What’s New In CoffeeScript 2?The biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript => becomes a JS =>, a CoffeeScript class becomes a JS class and so on. Major new features in CoffeeScript 2 include async functions and JSX. You can read more in the announcement.=>=>classclassasync functionsJSXannouncementThere are very few breaking changes from CoffeeScript 1.x to 2; we hope the upgrade process is smooth for most projects.breaking changes from CoffeeScript 1.x to 2CompatibilityMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions: Modules and JSX always require transpilation. Splats, a.k.a. object rest/spread syntax, for objects are supported by Node 8.6+. The regular expression s (dotall) flag is supported by Node 9+. Async generator functions are supported by Node 10+. Modules and JSX always require transpilation.ModulesJSXSplats, a.k.a. object rest/spread syntax, for objects are supported by Node 8.6+.Splats, a.k.a. object rest/spread syntax, for objectsThe regular expression s (dotall) flag is supported by Node 9+.regular expression s (dotall) flagsAsync generator functions are supported by Node 10+.Async generator functionsThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to node.green for full details. You can run the tests in your browser to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you transpile your code. When in doubt, transpile.node.greenrun the tests in your browsertranspile","dataLevel":2,"level":1,"parent":false},{"section":"whats-new-in-coffeescript-2","title":"What’s New In CoffeeScript 2?","content":"?The biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript => becomes a JS =>, a CoffeeScript class becomes a JS class and so on. Major new features in CoffeeScript 2 include async functions and JSX. You can read more in the announcement.=>=>classclassasync functionsJSXannouncementThere are very few breaking changes from CoffeeScript 1.x to 2; we hope the upgrade process is smooth for most projects.breaking changes from CoffeeScript 1.x to 2","dataLevel":2,"level":2,"parent":"coffeescript-2"},{"section":"compatibility","title":"Compatibility","content":"Most modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions: Modules and JSX always require transpilation. Splats, a.k.a. object rest/spread syntax, for objects are supported by Node 8.6+. The regular expression s (dotall) flag is supported by Node 9+. Async generator functions are supported by Node 10+. Modules and JSX always require transpilation.ModulesJSXSplats, a.k.a. object rest/spread syntax, for objects are supported by Node 8.6+.Splats, a.k.a. object rest/spread syntax, for objectsThe regular expression s (dotall) flag is supported by Node 9+.regular expression s (dotall) flagsAsync generator functions are supported by Node 10+.Async generator functionsThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to node.green for full details. You can run the tests in your browser to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you transpile your code. When in doubt, transpile.node.greenrun the tests in your browsertranspile","dataLevel":2,"level":2,"parent":"coffeescript-2"},{"section":"installation","title":"Installation","content":"The command-line version of coffee is available as a Node.js utility, requiring Node 6 or later. The core compiler however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see Try CoffeeScript).coffeeNode.jscore compilerTry CoffeeScriptTo install, first make sure you have a working copy of the latest stable version of Node.js. You can then install CoffeeScript globally with npm:Node.jsnpmnpm install --global coffeescript npm install --global coffeescript npm install --global coffeescript This will make the coffee and cake commands available globally.coffeecakeIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:npm install --save-dev coffeescript npm install --save-dev coffeescript npm install --save-dev coffeescript The coffee and cake commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.coffeecakeIf you plan to use the --transpile option (see Transpilation) you will need to also install babel-core either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.--transpileTranspilationbabel-core","dataLevel":false,"level":1,"parent":false},{"section":"usage","title":"Usage","content":"Command LineOnce installed, you should have access to the coffee command, which can execute scripts, compile .coffee files into .js, and provide an interactive REPL. The coffee command takes the following options:coffee.coffee.jscoffee Option Description -c, --compile Compile a .coffee script into a .js JavaScript file of the same name. -t, --transpile Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation. -m, --map Generate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well. -M, --inline-map Just like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file. -i, --interactive Launch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments. -o, --output [DIR] Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch. -w, --watch Watch files for changes, rerunning the specified command when any file is updated. -p, --print Instead of writing out the JavaScript as a file, print it directly to stdout. -s, --stdio Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sc -l, --literate Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name. -e, --eval Compile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\" -r, --require [MODULE]  require() the given module before starting the REPL or evaluating the code given with the --eval flag. -b, --bare Compile the JavaScript without the top-level function safety wrapper. --no-header Suppress the “Generated by CoffeeScript” header. --nodejs The node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times. --tokens Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. -n, --nodes Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler. Option Description Option Description OptionDescription -c, --compile Compile a .coffee script into a .js JavaScript file of the same name. -t, --transpile Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation. -m, --map Generate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well. -M, --inline-map Just like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file. -i, --interactive Launch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments. -o, --output [DIR] Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch. -w, --watch Watch files for changes, rerunning the specified command when any file is updated. -p, --print Instead of writing out the JavaScript as a file, print it directly to stdout. -s, --stdio Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sc -l, --literate Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name. -e, --eval Compile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\" -r, --require [MODULE]  require() the given module before starting the REPL or evaluating the code given with the --eval flag. -b, --bare Compile the JavaScript without the top-level function safety wrapper. --no-header Suppress the “Generated by CoffeeScript” header. --nodejs The node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times. --tokens Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. -n, --nodes Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler. -c, --compile Compile a .coffee script into a .js JavaScript file of the same name. -c, --compile-c, --compileCompile a .coffee script into a .js JavaScript file of the same name..coffee.js -t, --transpile Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation. -t, --transpile-t, --transpilePipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation.babel-core.babelrcpackage.jsonbabelTranspilation -m, --map Generate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well. -m, --map-m, --mapGenerate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well.sourceMappingURL -M, --inline-map Just like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file. -M, --inline-map-M, --inline-mapJust like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file.--map -i, --interactive Launch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments. -i, --interactive-i, --interactiveLaunch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments.coffee -o, --output [DIR] Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch. -o, --output [DIR]-o, --output [DIR]Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch.--compile--watch -w, --watch Watch files for changes, rerunning the specified command when any file is updated. -w, --watch-w, --watchWatch files for changes, rerunning the specified command when any file is updated. -p, --print Instead of writing out the JavaScript as a file, print it directly to stdout. -p, --print-p, --printInstead of writing out the JavaScript as a file, print it directly to stdout.stdout -s, --stdio Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sc -s, --stdio-s, --stdioPipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sccat src/cake.coffee | coffee -sc -l, --literate Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name. -l, --literate-l, --literateParses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name.stdio -e, --eval Compile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\" -e, --eval-e, --evalCompile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\"coffee -e \"console.log num for num in [10..1]\" -r, --require [MODULE]  require() the given module before starting the REPL or evaluating the code given with the --eval flag. -r, --require [MODULE] -r, --require [MODULE]require() the given module before starting the REPL or evaluating the code given with the --eval flag.require()--eval -b, --bare Compile the JavaScript without the top-level function safety wrapper. -b, --bare-b, --bareCompile the JavaScript without the top-level function safety wrapper.top-level function safety wrapper --no-header Suppress the “Generated by CoffeeScript” header. --no-header--no-headerSuppress the “Generated by CoffeeScript” header. --nodejs The node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times. --nodejs--nodejsThe node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times.node--debug--debug-brk--max-stack-size--expose-gc--nodejs --tokens Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. --tokens--tokensInstead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. -n, --nodes Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler. -n, --nodes-n, --nodesInstead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.Examples: Compile a directory tree of .coffee files in src into a parallel tree of .js files in lib: coffee --compile --output lib/ src/ Watch a file for changes, and recompile it every time the file is saved: coffee --watch --compile experimental.coffee Concatenate a list of files into a single script: coffee --join project.js --compile src/*.coffee Print out the compiled JS from a one-liner: coffee -bpe \"alert i for i in [0..10]\" All together now, watch and recompile an entire project as you work on it: coffee -o lib/ -cw src/ Start the CoffeeScript REPL (Ctrl-D to exit, Ctrl-Vfor multi-line): coffee Compile a directory tree of .coffee files in src into a parallel tree of .js files in lib: coffee --compile --output lib/ src/.coffeesrc.jslibcoffee --compile --output lib/ src/Watch a file for changes, and recompile it every time the file is saved: coffee --watch --compile experimental.coffeecoffee --watch --compile experimental.coffeeConcatenate a list of files into a single script: coffee --join project.js --compile src/*.coffeecoffee --join project.js --compile src/*.coffeePrint out the compiled JS from a one-liner: coffee -bpe \"alert i for i in [0..10]\"coffee -bpe \"alert i for i in [0..10]\"All together now, watch and recompile an entire project as you work on it: coffee -o lib/ -cw src/coffee -o lib/ -cw src/Start the CoffeeScript REPL (Ctrl-D to exit, Ctrl-Vfor multi-line): coffeeCtrl-DCtrl-VcoffeeTo use --transpile, see Transpilation.--transpileTranspilationNode.jsIf you’d like to use Node.js’ CommonJS to require CoffeeScript files, e.g. require './app.coffee', you must first “register” CoffeeScript as an extension:requirerequire './app.coffee'require 'coffeescript/register' App = require './app' # The .coffee extension is optional require 'coffeescript/register' App = require './app' # The .coffee extension is optional require 'coffeescript/register' App = require './app' # The .coffee extension is optional require'coffeescript/register'require'./app'# The .coffee extension is optionalIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can require the full module:requireCoffeeScript = require 'coffeescript' eval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"' CoffeeScript = require 'coffeescript' eval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"' CoffeeScript = require 'coffeescript' eval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"' require'coffeescript''console.log \"Mmmmm, I could really go for some #{Math.pi}\"'The compile method has the signature compile(code, options) where code is a string of CoffeeScript code, and the optional options is an object with some or all of the following properties:compilecompile(code, options)codeoptions options.sourceMap, boolean: if true, a source map will be generated; and instead of returning a string, compile will return an object of the form {js, v3SourceMap, sourceMap}. options.inlineMap, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom. options.filename, string: the filename to use for the source map. It can include a path (relative or absolute). options.bare, boolean: if true, output without the top-level function safety wrapper. options.header, boolean: if true, output the Generated by CoffeeScript header. options.transpile, object: if set, this must be an object with the options to pass to Babel. See Transpilation. options.sourceMap, boolean: if true, a source map will be generated; and instead of returning a string, compile will return an object of the form {js, v3SourceMap, sourceMap}.options.sourceMapcompile{js, v3SourceMap, sourceMap}options.inlineMap, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.options.inlineMapoptions.filename, string: the filename to use for the source map. It can include a path (relative or absolute).options.filenameoptions.bare, boolean: if true, output without the top-level function safety wrapper.options.baretop-level function safety wrapperoptions.header, boolean: if true, output the Generated by CoffeeScript header.options.headerGenerated by CoffeeScriptoptions.transpile, object: if set, this must be an object with the options to pass to Babel. See Transpilation.options.transpileobjectoptions to pass to BabelTranspilationTranspilationCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run might not support all of that syntax. In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, { a } = obj into a = obj.a. This is done via transpilers like Babel, Bublé or Traceur Compiler.might not support all of that syntax{ a } = obja = obj.aBabelBubléTraceur CompilerQuickstartFrom the root of your project:npm install --save-dev babel-core babel-preset-env echo '{ \"presets\": [\"env\"] }' > .babelrc coffee --compile --transpile --inline-map some-file.coffee npm install --save-dev babel-core babel-preset-env echo '{ \"presets\": [\"env\"] }' > .babelrc coffee --compile --transpile --inline-map some-file.coffee npm install --save-dev babel-core babel-preset-env echo '{ \"presets\": [\"env\"] }' > .babelrc coffee --compile --transpile --inline-map some-file.coffee echo'{ \"presets\": [\"env\"] }'Transpiling with the CoffeeScript compilerTo make things easy, CoffeeScript has built-in support for the popular Babel transpiler. You can use it via the --transpile command-line option or the transpile Node API option. To use either, babel-core must be installed in your project:Babel--transpiletranspilebabel-corenpm install --save-dev babel-core npm install --save-dev babel-core npm install --save-dev babel-core Or if you’re running the coffee command outside of a project folder, using a globally-installed coffeescript module, babel-core needs to be installed globally:coffeecoffeescriptbabel-corenpm install --global babel-core npm install --global babel-core npm install --global babel-core By default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a .babelrc file in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports other ways, too.) A minimal .babelrc file would be just { \"presets\": [\"env\"] }. This implies that you have installed babel-preset-env:.babelrc file.babelrcother ways.babelrc{ \"presets\": [\"env\"] }babel-preset-envbabel-preset-envnpm install --save-dev babel-preset-env  # Or --global for non-project-based usage npm install --save-dev babel-preset-env  # Or --global for non-project-based usage npm install --save-dev babel-preset-env  # Or --global for non-project-based usage # Or --global for non-project-based usageSee Babel’s website to learn about presets and plugins and the multitude of options you have. Another preset you might need is transform-react-jsx if you’re using JSX with React (JSX can also be used with other frameworks).Babel’s website to learn about presets and pluginstransform-react-jsxtransform-react-jsxOnce you have babel-core and babel-preset-env (or other presets or plugins) installed, and a .babelrc file (or other equivalent) in place, you can use coffee --transpile to pipe CoffeeScript’s output through Babel using the options you’ve saved.babel-corebabel-preset-env.babelrccoffee --transpileIf you’re using CoffeeScript via the Node API, where you call CoffeeScript.compile with a string to be compiled and an options object, the transpile key of the options object should be the Babel options:Node APICoffeeScript.compileoptionstranspileoptionsCoffeeScript.compile(code, {transpile: {presets: ['env']}}) CoffeeScript.compile(code, {transpile: {presets: ['env']}}) CoffeeScript.compile(code, {transpile: {presets: ['env']}}) transpilepresets'env'You can also transpile CoffeeScript’s output without using the transpile option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as Gulp, Webpack, Grunt and Broccoli.transpileGulpWebpackGruntBroccoliPolyfillsNote that transpiling doesn’t automatically supply polyfills for your code. CoffeeScript itself will output Array.indexOf if you use the in operator, or destructuring or spread/rest syntax; and Function.bind if you use a bound (=>) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is babel-polyfill, though there are many other strategies.polyfillsArray.indexOfArray.indexOfinFunction.bindFunction.bind=>babel-polyfillbabel-polyfillotherstrategies","dataLevel":2,"level":1,"parent":false},{"section":"cli","title":"Command Line","content":"Once installed, you should have access to the coffee command, which can execute scripts, compile .coffee files into .js, and provide an interactive REPL. The coffee command takes the following options:coffee.coffee.jscoffee Option Description -c, --compile Compile a .coffee script into a .js JavaScript file of the same name. -t, --transpile Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation. -m, --map Generate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well. -M, --inline-map Just like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file. -i, --interactive Launch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments. -o, --output [DIR] Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch. -w, --watch Watch files for changes, rerunning the specified command when any file is updated. -p, --print Instead of writing out the JavaScript as a file, print it directly to stdout. -s, --stdio Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sc -l, --literate Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name. -e, --eval Compile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\" -r, --require [MODULE]  require() the given module before starting the REPL or evaluating the code given with the --eval flag. -b, --bare Compile the JavaScript without the top-level function safety wrapper. --no-header Suppress the “Generated by CoffeeScript” header. --nodejs The node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times. --tokens Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. -n, --nodes Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler. Option Description Option Description OptionDescription -c, --compile Compile a .coffee script into a .js JavaScript file of the same name. -t, --transpile Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation. -m, --map Generate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well. -M, --inline-map Just like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file. -i, --interactive Launch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments. -o, --output [DIR] Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch. -w, --watch Watch files for changes, rerunning the specified command when any file is updated. -p, --print Instead of writing out the JavaScript as a file, print it directly to stdout. -s, --stdio Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sc -l, --literate Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name. -e, --eval Compile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\" -r, --require [MODULE]  require() the given module before starting the REPL or evaluating the code given with the --eval flag. -b, --bare Compile the JavaScript without the top-level function safety wrapper. --no-header Suppress the “Generated by CoffeeScript” header. --nodejs The node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times. --tokens Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. -n, --nodes Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler. -c, --compile Compile a .coffee script into a .js JavaScript file of the same name. -c, --compile-c, --compileCompile a .coffee script into a .js JavaScript file of the same name..coffee.js -t, --transpile Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation. -t, --transpile-t, --transpilePipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires babel-core to be installed, and options to pass to Babel in a .babelrc file or a package.json with a babel key in the path of the file or folder to be compiled. See Transpilation.babel-core.babelrcpackage.jsonbabelTranspilation -m, --map Generate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well. -m, --map-m, --mapGenerate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well.sourceMappingURL -M, --inline-map Just like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file. -M, --inline-map-M, --inline-mapJust like --map, but include the source map directly in the compiled JavaScript files, rather than in a separate file.--map -i, --interactive Launch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments. -i, --interactive-i, --interactiveLaunch an interactive CoffeeScript session to try short snippets. Identical to calling coffee with no arguments.coffee -o, --output [DIR] Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch. -o, --output [DIR]-o, --output [DIR]Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch.--compile--watch -w, --watch Watch files for changes, rerunning the specified command when any file is updated. -w, --watch-w, --watchWatch files for changes, rerunning the specified command when any file is updated. -p, --print Instead of writing out the JavaScript as a file, print it directly to stdout. -p, --print-p, --printInstead of writing out the JavaScript as a file, print it directly to stdout.stdout -s, --stdio Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sc -s, --stdio-s, --stdioPipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:cat src/cake.coffee | coffee -sccat src/cake.coffee | coffee -sc -l, --literate Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name. -l, --literate-l, --literateParses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over stdio, or using some sort of extension-less file name.stdio -e, --eval Compile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\" -e, --eval-e, --evalCompile and print a little snippet of CoffeeScript directly from the command line. For example:coffee -e \"console.log num for num in [10..1]\"coffee -e \"console.log num for num in [10..1]\" -r, --require [MODULE]  require() the given module before starting the REPL or evaluating the code given with the --eval flag. -r, --require [MODULE] -r, --require [MODULE]require() the given module before starting the REPL or evaluating the code given with the --eval flag.require()--eval -b, --bare Compile the JavaScript without the top-level function safety wrapper. -b, --bare-b, --bareCompile the JavaScript without the top-level function safety wrapper.top-level function safety wrapper --no-header Suppress the “Generated by CoffeeScript” header. --no-header--no-headerSuppress the “Generated by CoffeeScript” header. --nodejs The node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times. --nodejs--nodejsThe node executable has some useful options you can set, such as --debug, --debug-brk, --max-stack-size, and --expose-gc. Use this flag to forward options directly to Node.js. To pass multiple flags, use --nodejs multiple times.node--debug--debug-brk--max-stack-size--expose-gc--nodejs --tokens Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. --tokens--tokensInstead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. -n, --nodes Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler. -n, --nodes-n, --nodesInstead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.Examples: Compile a directory tree of .coffee files in src into a parallel tree of .js files in lib: coffee --compile --output lib/ src/ Watch a file for changes, and recompile it every time the file is saved: coffee --watch --compile experimental.coffee Concatenate a list of files into a single script: coffee --join project.js --compile src/*.coffee Print out the compiled JS from a one-liner: coffee -bpe \"alert i for i in [0..10]\" All together now, watch and recompile an entire project as you work on it: coffee -o lib/ -cw src/ Start the CoffeeScript REPL (Ctrl-D to exit, Ctrl-Vfor multi-line): coffee Compile a directory tree of .coffee files in src into a parallel tree of .js files in lib: coffee --compile --output lib/ src/.coffeesrc.jslibcoffee --compile --output lib/ src/Watch a file for changes, and recompile it every time the file is saved: coffee --watch --compile experimental.coffeecoffee --watch --compile experimental.coffeeConcatenate a list of files into a single script: coffee --join project.js --compile src/*.coffeecoffee --join project.js --compile src/*.coffeePrint out the compiled JS from a one-liner: coffee -bpe \"alert i for i in [0..10]\"coffee -bpe \"alert i for i in [0..10]\"All together now, watch and recompile an entire project as you work on it: coffee -o lib/ -cw src/coffee -o lib/ -cw src/Start the CoffeeScript REPL (Ctrl-D to exit, Ctrl-Vfor multi-line): coffeeCtrl-DCtrl-VcoffeeTo use --transpile, see Transpilation.--transpileTranspilation","dataLevel":2,"level":2,"parent":"usage"},{"section":"nodejs-usage","title":"Node.js","content":"If you’d like to use Node.js’ CommonJS to require CoffeeScript files, e.g. require './app.coffee', you must first “register” CoffeeScript as an extension:requirerequire './app.coffee'require 'coffeescript/register' App = require './app' # The .coffee extension is optional require 'coffeescript/register' App = require './app' # The .coffee extension is optional require 'coffeescript/register' App = require './app' # The .coffee extension is optional require'coffeescript/register'require'./app'# The .coffee extension is optionalIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can require the full module:requireCoffeeScript = require 'coffeescript' eval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"' CoffeeScript = require 'coffeescript' eval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"' CoffeeScript = require 'coffeescript' eval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"' require'coffeescript''console.log \"Mmmmm, I could really go for some #{Math.pi}\"'The compile method has the signature compile(code, options) where code is a string of CoffeeScript code, and the optional options is an object with some or all of the following properties:compilecompile(code, options)codeoptions options.sourceMap, boolean: if true, a source map will be generated; and instead of returning a string, compile will return an object of the form {js, v3SourceMap, sourceMap}. options.inlineMap, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom. options.filename, string: the filename to use for the source map. It can include a path (relative or absolute). options.bare, boolean: if true, output without the top-level function safety wrapper. options.header, boolean: if true, output the Generated by CoffeeScript header. options.transpile, object: if set, this must be an object with the options to pass to Babel. See Transpilation. options.sourceMap, boolean: if true, a source map will be generated; and instead of returning a string, compile will return an object of the form {js, v3SourceMap, sourceMap}.options.sourceMapcompile{js, v3SourceMap, sourceMap}options.inlineMap, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.options.inlineMapoptions.filename, string: the filename to use for the source map. It can include a path (relative or absolute).options.filenameoptions.bare, boolean: if true, output without the top-level function safety wrapper.options.baretop-level function safety wrapperoptions.header, boolean: if true, output the Generated by CoffeeScript header.options.headerGenerated by CoffeeScriptoptions.transpile, object: if set, this must be an object with the options to pass to Babel. See Transpilation.options.transpileobjectoptions to pass to BabelTranspilation","dataLevel":2,"level":2,"parent":"usage"},{"section":"transpilation","title":"Transpilation","content":"CoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run might not support all of that syntax. In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, { a } = obj into a = obj.a. This is done via transpilers like Babel, Bublé or Traceur Compiler.might not support all of that syntax{ a } = obja = obj.aBabelBubléTraceur CompilerQuickstartFrom the root of your project:npm install --save-dev babel-core babel-preset-env echo '{ \"presets\": [\"env\"] }' > .babelrc coffee --compile --transpile --inline-map some-file.coffee npm install --save-dev babel-core babel-preset-env echo '{ \"presets\": [\"env\"] }' > .babelrc coffee --compile --transpile --inline-map some-file.coffee npm install --save-dev babel-core babel-preset-env echo '{ \"presets\": [\"env\"] }' > .babelrc coffee --compile --transpile --inline-map some-file.coffee echo'{ \"presets\": [\"env\"] }'Transpiling with the CoffeeScript compilerTo make things easy, CoffeeScript has built-in support for the popular Babel transpiler. You can use it via the --transpile command-line option or the transpile Node API option. To use either, babel-core must be installed in your project:Babel--transpiletranspilebabel-corenpm install --save-dev babel-core npm install --save-dev babel-core npm install --save-dev babel-core Or if you’re running the coffee command outside of a project folder, using a globally-installed coffeescript module, babel-core needs to be installed globally:coffeecoffeescriptbabel-corenpm install --global babel-core npm install --global babel-core npm install --global babel-core By default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a .babelrc file in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports other ways, too.) A minimal .babelrc file would be just { \"presets\": [\"env\"] }. This implies that you have installed babel-preset-env:.babelrc file.babelrcother ways.babelrc{ \"presets\": [\"env\"] }babel-preset-envbabel-preset-envnpm install --save-dev babel-preset-env  # Or --global for non-project-based usage npm install --save-dev babel-preset-env  # Or --global for non-project-based usage npm install --save-dev babel-preset-env  # Or --global for non-project-based usage # Or --global for non-project-based usageSee Babel’s website to learn about presets and plugins and the multitude of options you have. Another preset you might need is transform-react-jsx if you’re using JSX with React (JSX can also be used with other frameworks).Babel’s website to learn about presets and pluginstransform-react-jsxtransform-react-jsxOnce you have babel-core and babel-preset-env (or other presets or plugins) installed, and a .babelrc file (or other equivalent) in place, you can use coffee --transpile to pipe CoffeeScript’s output through Babel using the options you’ve saved.babel-corebabel-preset-env.babelrccoffee --transpileIf you’re using CoffeeScript via the Node API, where you call CoffeeScript.compile with a string to be compiled and an options object, the transpile key of the options object should be the Babel options:Node APICoffeeScript.compileoptionstranspileoptionsCoffeeScript.compile(code, {transpile: {presets: ['env']}}) CoffeeScript.compile(code, {transpile: {presets: ['env']}}) CoffeeScript.compile(code, {transpile: {presets: ['env']}}) transpilepresets'env'You can also transpile CoffeeScript’s output without using the transpile option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as Gulp, Webpack, Grunt and Broccoli.transpileGulpWebpackGruntBroccoliPolyfillsNote that transpiling doesn’t automatically supply polyfills for your code. CoffeeScript itself will output Array.indexOf if you use the in operator, or destructuring or spread/rest syntax; and Function.bind if you use a bound (=>) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is babel-polyfill, though there are many other strategies.polyfillsArray.indexOfArray.indexOfinFunction.bindFunction.bind=>babel-polyfillbabel-polyfillotherstrategies","dataLevel":2,"level":2,"parent":"usage"},{"section":"language","title":"Language Reference","content":"This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.Many of the examples can be run (where it makes sense) by pressing the ▶ button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.Many of the examples can be run (where it makes sense) by pressing the▶button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.First, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons ; to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces { } to surround blocks of code in functions, if-statements, switch, and try/catch, use indentation.;{ }functionsif-statementsswitchtry/catchYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression. console.log sys.inspect object → console.log(sys.inspect(object));console.log sys.inspect objectconsole.log(sys.inspect(object));FunctionsFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: ->->               square = (x) -> x * x cube   = (x) -> square(x) * x       square = (x) -> x * x cube   = (x) -> square(x) * x                 var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };                           \t cube(5)                       square = (x) -> x * x cube   = (x) -> square(x) * x       square = (x) -> x * x cube   = (x) -> square(x) * x                 var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };               square = (x) -> x * x cube   = (x) -> square(x) * x       square = (x) -> x * x cube   = (x) -> square(x) * x     square = (x) -> x * x cube   = (x) -> square(x) * x square = (x) -> x * x cube   = (x) -> square(x) * x square=(x)->x*xcube=(x)->square(x)*x       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };     var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; }; var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; }; varcubesquaresquare=functionxreturnx*xcube=functionxreturnsquarex*x             \t cube(5)                \t cube(5)      \t cube(5) \t \t Functions may also have default values for arguments, which will be used if the incoming argument is missing (undefined).undefined               fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"                 var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };                           \t fill(\"cup\")                       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"                 var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };               fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"     fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\" fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\" fill=(container,liquid=\"coffee\")->\"Filling the #{container} with #{liquid}...\"       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };     var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; }; var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; }; varfillfill=functioncontainerliquid=\"coffee\"return`Filling the ${container}with ${liquid}...`             \t fill(\"cup\")                \t fill(\"cup\")      \t fill(\"cup\") \t \t StringsLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the \" or ' characters. CoffeeScript also supports string interpolation within \"-quoted strings, using #{ … }. Single-quoted strings are literal. You may even use interpolation in object keys.\"'\"#{ … }               author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"                 var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;                           \t sentence                       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"                 var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;               author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"     author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\" author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\" author=\"Wittgenstein\"quote=\"A picture is a fact. -- #{ author }\"sentence=\"#{ 22 / 7 } is a decent approximation of π\"       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;     var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`; var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`; varauthorquotesentenceauthor=\"Wittgenstein\"quote=`A picture is a fact. -- ${author}`sentence=`${22/7}is a decent approximation of π`             \t sentence                \t sentence      \t sentence \t \t Multiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.               mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"                 var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";                           \t mobyDick                       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"                 var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";               mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"     mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\" mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\" mobyDick=\"Call me Ishmael. Some years ago --  never mind how long precisely -- having little  or no money in my purse, and nothing particular  to interest me on shore, I thought I would sail  about a little and see the watery part of the  world...\"       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";     var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\"; var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\"; varmobyDickmobyDick=\"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\"             \t mobyDick                \t mobyDick      \t mobyDick \t \t Block strings, delimited by \"\"\" or ''', can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\"\"\"'''               html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"                 var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";                           \t html                       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"                 var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";               html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"     html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\" html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\" html=\"\"\"       <strong>         cup of coffeescript       </strong>       \"\"\"       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";     var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\"; var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\"; varhtmlhtml=\"<strong>\\n  cup of coffeescript\\n</strong>\"             \t html                \t html      \t html \t \t Double-quoted block strings, like other double-quoted strings, allow interpolation.Objects and ArraysThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to YAML.YAML               song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9                 var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };                           \t song.join(\" … \")                       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9                 var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };               song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9     song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9 song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9 song=[\"do\",\"re\",\"mi\",\"fa\",\"so\"]singers={Jagger:\"Rock\",Elvis:\"Roll\"}bitlist=[1,0,10,0,11,1,0]kids=  brother:    name:\"Max\"age:11  sister:    name:\"Ida\"age:9       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };     var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } }; var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } }; varbitlistkidssingerssongsong=\"do\"\"re\"\"mi\"\"fa\"\"so\"singers=Jagger\"Rock\"Elvis\"Roll\"bitlist=101001110kids=brothername\"Max\"age11sistername\"Ida\"age9             \t song.join(\" … \")                \t song.join(\" … \")      \t song.join(\" … \") \t \t CoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name.               name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"                 var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;                       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"                 var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;               name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"     name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\" name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\" name=\"Michelangelo\"mask=\"orange\"weapon=\"nunchuks\"turtle={name,mask,weapon}output=\"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;     var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`; var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`; varmasknameoutputturtleweaponname=\"Michelangelo\"mask=\"orange\"weapon=\"nunchuks\"turtle=namemaskweaponoutput=`${turtlename}wears an ${turtlemask}mask. Watch out for his ${turtleweapon}!`CommentsIn CoffeeScript, comments are denoted by the # character to the end of a line, or from ### to the next appearance of ###. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.#######               ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!                 /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };                       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!                 /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };               ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!     ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed! ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed! ###Fortune Cookie Reader v1.0Released under the MIT License###sayFortune=(fortune)->console.logfortune# in bed!       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };     /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! }; /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! }; /*Fortune Cookie Reader v1.0Released under the MIT License*/varsayFortunesayFortune=functionfortunereturnconsolelogfortune// in bed!Inline ### comments make type annotations possible.###type annotationsLexical Scoping and Variable SafetyThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write var yourself.var               outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()                 var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();                           \t inner                       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()                 var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();               outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()     outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers() outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers() outer=1changeNumbers=->inner=-1outer=10inner=changeNumbers()       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();     var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers(); var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers(); varchangeNumbersinnerouterouter=1changeNumbers=functionvarinnerinner=-1returnouter=10inner=changeNumbers             \t inner                \t inner      \t inner \t \t Notice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. outer is not redeclared within the inner function, because it’s already in scope; inner within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.outerinnerBecause you don’t have direct access to the var keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.varAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with import or export statements) is wrapped in an anonymous function: (function(){ … })();. This safety wrapper, combined with the automatic generation of the var keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the bare option, and is unnecessary and automatically disabled when using modules.)importexport(function(){ … })();varbare optionbareIf you’d like to create top-level variables for other scripts to use, attach them as properties on window; attach them as properties on the exports object in CommonJS; or use an export statement. If you’re targeting both CommonJS and the browser, the existential operator (covered below), gives you a reliable way to figure out where to add them: exports ? this.windowexportsexport statementexportexistential operatorexports ? thisSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s let or const. This is intentional; we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.letconstThis is intentionalIf, Else, Unless, and Conditional Assignmentif/else statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the if or unless at the end.ifelseifunlessCoffeeScript can compile if statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular if statement on a single line.ifif               mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill                 var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;                       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill                 var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;               mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill     mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill mood=greatlyImprovedifsingingifhappyandknowsItclapsHands()chaChaCha()elseshowIt()date=iffridaythensueelsejill       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;     var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill; var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill; vardatemoodifsingingmood=greatlyImprovedifhappy&&knowsItclapsHandschaChaChaelseshowItdate=friday?suejillSplats, or Rest Parameters/Spread SyntaxThe JavaScript arguments object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats ..., both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their rest parameters.arguments...rest parameters               gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"                 var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);                           \t                       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"                 var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);               gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"     gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\" gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\" gold=silver=rest=\"unknown\"awardMedals=(first,second,others...)->gold=firstsilver=secondrest=otherscontenders=[\"Michael Phelps\"\"Liu Xiang\"\"Yao Ming\"\"Allyson Felix\"\"Shawn Johnson\"\"Roman Sebrle\"\"Guo Jingjing\"\"Tyson Gay\"\"Asafa Powell\"\"Usain Bolt\"]awardMedalscontenders...alert\"\"\"Gold: #{gold}Silver: #{silver}The Field: #{rest.join ', '}\"\"\"       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);     var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`); var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`); varawardMedalscontendersgoldrestsilvergold=silver=rest=\"unknown\"awardMedals=functionfirstsecond...othersgold=firstsilver=secondreturnrest=otherscontenders=\"Michael Phelps\"\"Liu Xiang\"\"Yao Ming\"\"Allyson Felix\"\"Shawn Johnson\"\"Roman Sebrle\"\"Guo Jingjing\"\"Tyson Gay\"\"Asafa Powell\"\"Usain Bolt\"awardMedals...contendersalert`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${restjoin', '}`             \t                \t      \t \t \t Splats also let us elide array elements…               popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']                 var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];                           \t all                       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']                 var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];               popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']     popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms'] popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms'] popular=['pepperoni','sausage','cheese']unwanted=['anchovies','olives']all=[popular...,unwanted...,'mushrooms']       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];     var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms']; var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms']; varallpopularunwantedpopular='pepperoni''sausage''cheese'unwanted='anchovies''olives'all=...popular...unwanted'mushrooms'             \t all                \t all      \t all \t \t …and object properties.               user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }                 var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };                           \t JSON.stringify(currentUser)                       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }                 var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };               user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }     user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' } user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' } user=  name:'Werner Heisenberg'occupation:'theoretical physicist'currentUser={user...,status:'Uncertain'}       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };     var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' }; var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' }; varcurrentUseruseruser=name'Werner Heisenberg'occupation'theoretical physicist'currentUser=...userstatus'Uncertain'             \t JSON.stringify(currentUser)                \t JSON.stringify(currentUser)      \t JSON.stringify(currentUser) \t \t In ECMAScript this is called spread syntax, and has been supported for arrays since ES2015 and objects since ES2018.spread syntaxLoops and ComprehensionsMost of the loops you’ll write in CoffeeScript will be comprehensions over arrays, objects, and ranges. Comprehensions replace (and compile into) for loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.comprehensionsfor               # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'                 // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }                       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'                 // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }               # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'     # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate' # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate' # Eat lunch.eat=(food)->\"#{food} eaten.\"eatfoodforfoodin['toast','cheese','wine']# Fine five course dining.courses=['greens','caviar','truffles','roast','cake']menu=(i,dish)->\"Menu Item #{i}: #{dish}\"menui+1,dishfordish,iincourses# Health conscious meal.foods=['broccoli','spinach','chocolate']eatfoodforfoodinfoodswhenfoodisnt'chocolate'       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }     // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } } // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } } // Eat lunch.varcoursesdisheatfoodfoodsijkllenlen1len2menurefeat=functionfoodreturn`${food}eaten.`ref='toast''cheese''wine'forj=0len=reflengthj<lenj++food=refjeatfood// Fine five course dining.courses='greens''caviar''truffles''roast''cake'menu=functionidishreturn`Menu Item ${i}: ${dish}`fori=k=0len1=courseslengthk<len1i=++kdish=coursesimenui+1dish// Health conscious meal.foods='broccoli''spinach''chocolate'forl=0len2=foodslengthl<len2l++food=foodsliffood!=='chocolate'eatfoodComprehensions should be able to handle most places where you otherwise would use a loop, each/forEach, map, or select/filter, for example: shortNames = (name for name in list when name.length < 5) If you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.eachforEachmapselectfiltershortNames = (name for name in list when name.length < 5)               countdown = (num for num in [10..1])       countdown = (num for num in [10..1])                 var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();                           \t countdown                       countdown = (num for num in [10..1])       countdown = (num for num in [10..1])                 var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();               countdown = (num for num in [10..1])       countdown = (num for num in [10..1])     countdown = (num for num in [10..1]) countdown = (num for num in [10..1]) countdown=(numfornumin[10..1])       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();     var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })(); var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })(); varcountdownnumcountdown=functionvariresultsresults=fornum=i=10i>=1num=--iresultspushnumreturnresults             \t countdown                \t countdown      \t countdown \t \t Note how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like true — or null, to the bottom of your function.truenullTo step through a range comprehension in fixed-size chunks, use by, for example: evens = (x for x in [0..10] by 2)byevens = (x for x in [0..10] by 2)If you don’t need the current iteration value you may omit it: browser.closeCurrentTab() for [0...count]browser.closeCurrentTab() for [0...count]Comprehensions can also be used to iterate over the keys and values in an object. Use of to signal comprehension over the properties of an object instead of the values in an array.of               yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"                 var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();                           \t ages.join(\", \")                       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"                 var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();               yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"     yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\" yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\" yearsOld=max:10,ida:9,tim:11ages=forchild,ageofyearsOld\"#{child} is #{age}\"       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();     var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })(); var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })(); varageageschildyearsOldyearsOld=max10ida9tim11ages=functionvarresultsresults=forchildinyearsOldage=yearsOldchildresultspush`${child}is ${age}`returnresults             \t ages.join(\", \")                \t ages.join(\", \")      \t ages.join(\", \") \t \t If you would like to iterate over just the keys that are defined on the object itself, by adding a hasOwnProperty check to avoid properties that may be inherited from the prototype, use for own key, value of object.hasOwnPropertyfor own key, value of objectTo iterate a generator function, use from. See Generator Functions.fromGenerator FunctionsThe only low-level loop that CoffeeScript provides is the while loop. The main difference from JavaScript is that the while loop can be used as an expression, returning an array containing the result of each iteration through the loop.whilewhile               # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"                 // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();                           \t lyrics.join(\"\\n\")                       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"                 // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();               # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"     # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\" # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\" # Econ 101ifthis.studyingEconomicsbuy()whilesupply>demand  sell()untilsupply>demand# Nursery Rhymenum=6lyrics=whilenum-=1\"#{num} little monkeys, jumping on the bed.    One fell out and bumped his head.\"       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();     // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })(); // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })(); // Econ 101varlyricsnumifthisstudyingEconomicswhilesupply>demandbuywhile!supply>demandsell// Nursery Rhymenum=6lyrics=functionvarresultsresults=whilenum-=1resultspush`${num}little monkeys, jumping on the bed. One fell out and bumped his head.`returnresults             \t lyrics.join(\"\\n\")                \t lyrics.join(\"\\n\")      \t lyrics.join(\"\\n\") \t \t For readability, the until keyword is equivalent to while not, and the loop keyword is equivalent to while true.untilwhile notloopwhile trueWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the do keyword, which immediately invokes a passed function, forwarding any arguments.do               for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()                 var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }                       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()                 var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }               for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()     for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString() for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString() forfilenameinlistdo(filename)->iffilenamenotin['.DS_Store','Thumbs.db','ehthumbs.db']fs.readFilefilename,(err,contents)->compilefilename,contents.toString()       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }     var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); } var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); } varfilenameilenfori=0len=listlengthi<leni++filename=listifunctionfilenameiffilename!=='.DS_Store'&&filename!=='Thumbs.db'&&filename!=='ehthumbs.db'returnfsreadFilefilenamefunctionerrcontentsreturncompilefilenamecontentstoStringfilenameArray Slicing and Splicing with RangesRanges can also be used to extract slices of arrays. With two dots (3..6), the range is inclusive (3, 4, 5, 6); with three dots (3...6), the range excludes the end (3, 4, 5). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.3..63, 4, 5, 63...63, 4, 5               numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]                 var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);                           \t middle                       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]                 var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);               numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]     numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..] numbers=[1,2,3,4,5,6,7,8,9]start=numbers[0..2]middle=numbers[3...-2]end=numbers[-2..]copy=numbers[..]       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);     var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0); var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0); varcopyendmiddlenumbersstartnumbers=123456789start=numbersslice03middle=numbersslice3-2end=numbersslice-2copy=numbersslice0             \t middle                \t middle      \t middle \t \t The same syntax can be used with assignment to replace a segment of an array with new values, splicing it.               numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]                 var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;                           \t numbers                       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]                 var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;               numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]     numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6] numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6] numbers=[0,1,2,3,4,5,6,7,8,9]numbers[3..6]=[-3,-4,-5,-6]       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;     var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref; var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref; varnumbersrefsplice=splicenumbers=0123456789spliceapplynumbers34concatref=-3-4-5-6ref             \t numbers                \t numbers      \t numbers \t \t Note that JavaScript strings are immutable, and can’t be spliced.Everything is an Expression (at least, as much as possible)You might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the return gets pushed down into each possible branch of execution in the function below.return               grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"                 var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";                           \t eldest                       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"                 var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";               grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"     grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\" grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\" grade=(student)->ifstudent.excellentWork\"A+\"  elseifstudent.okayStuff    ifstudent.triedHardthen\"B\"else\"B-\"  else\"C\"eldest=if24>21then\"Liz\"else\"Ike\"       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";     var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\"; var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\"; vareldestgradegrade=functionstudentifstudentexcellentWorkreturn\"A+\"elseifstudentokayStuffifstudenttriedHardreturn\"B\"elsereturn\"B-\"elsereturn\"C\"eldest=24>21?\"Liz\"\"Ike\"             \t eldest                \t eldest      \t eldest \t \t Even though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (return value), when you know that you’re done.return valueBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:               six = (one = 1) + (two = 2) + (three = 3)       six = (one = 1) + (two = 2) + (three = 3)                 var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);                           \t six                       six = (one = 1) + (two = 2) + (three = 3)       six = (one = 1) + (two = 2) + (three = 3)                 var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);               six = (one = 1) + (two = 2) + (three = 3)       six = (one = 1) + (two = 2) + (three = 3)     six = (one = 1) + (two = 2) + (three = 3) six = (one = 1) + (two = 2) + (three = 3) six=(one=1)+(two=2)+(three=3)       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);     var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3); var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3); varonesixthreetwosix=one=1+two=2+three=3             \t six                \t six      \t six \t \t Things that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:               # The first ten global properties. globals = (name for name of window)[0...10]       # The first ten global properties. globals = (name for name of window)[0...10]                 // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);                           \t globals                       # The first ten global properties. globals = (name for name of window)[0...10]       # The first ten global properties. globals = (name for name of window)[0...10]                 // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);               # The first ten global properties. globals = (name for name of window)[0...10]       # The first ten global properties. globals = (name for name of window)[0...10]     # The first ten global properties. globals = (name for name of window)[0...10] # The first ten global properties. globals = (name for name of window)[0...10] # The first ten global properties.globals=(namefornameofwindow)[0...10]       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);     // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10); // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10); // The first ten global properties.varglobalsnameglobals=functionvarresultsresults=fornameinwindowresultspushnamereturnresultsslice010             \t globals                \t globals      \t globals \t \t As well as silly things, like passing a try/catch statement directly into a function call:trycatch               alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )                 var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());                           \t                       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )                 var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());               alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )     alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" ) alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" ) alert(try    nonexistent/undefined  catcherror\"And the error is ... #{error}\")       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());     var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })()); var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })()); varerroralertfunctiontryreturnnonexistent/void0catcherror1error=error1return`And the error is ... ${error}`             \t                \t      \t \t \t There are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely break, continue, and return. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.breakcontinuereturnOperators and AliasesBecause the == operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles == into ===, and != into !==. In addition, is compiles into ===, and isnt into !==.=======!=!==is===isnt!==You can use not as an alias for !.not!For logic, and compiles to &&, and or into ||.and&&or||Instead of a newline or semicolon, then can be used to separate conditions from expressions, in while, if/else, and switch/when statements.thenwhileifelseswitchwhenAs in YAML, on and yes are the same as boolean true, while off and no are boolean false.YAMLonyestrueoffnofalseunless can be used as the inverse of if.unlessifAs a shortcut for this.property, you can use @property.this.property@propertyYou can use in to test for array presence, and of to test for JavaScript object-key presence.inofIn a for loop, from compiles to the ES2015 of. (Yes, it’s unfortunate; the CoffeeScript of predates the ES2015 of.)forfromES2015 ofofofofTo simplify math expressions, ** can be used for exponentiation and // performs floor division. % works just like in JavaScript, while %% provides “dividend dependent modulo”:**//%%%“dividend dependent modulo”               -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)                 var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));                       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)                 var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));               -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)     -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length) -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length) -7%5==-2# The remainder of 7 / 5-7%%5==3# n %% 5 is always between 0 and 4tabs.selectTabAtIndex((tabs.currentIndex-count)%%tabs.length)       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));     var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length)); var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length)); varmodulo=functionabreturn+a%b=+b+b%b-7%5===-2// The remainder of 7 / 5modulo-75===3// n %% 5 is always between 0 and 4tabsselectTabAtIndexmodulotabscurrentIndex-counttabslengthAll together now: CoffeeScript JavaScript is === isnt !== not ! and && or || true, yes, on true false, no, off  false @, this this a in b [].indexOf.call(b, a) >= 0 a of b a in b for a from b for (a of b) a ** b a ** b a // b Math.floor(a / b) a %% b (a % b + b) % b CoffeeScript JavaScript CoffeeScript JavaScript CoffeeScriptJavaScript is === isnt !== not ! and && or || true, yes, on true false, no, off  false @, this this a in b [].indexOf.call(b, a) >= 0 a of b a in b for a from b for (a of b) a ** b a ** b a // b Math.floor(a / b) a %% b (a % b + b) % b is === isis====== isnt !== isntisnt!==!== not ! notnot!! and && andand&&&& or || oror|||| true, yes, on true true, yes, ontrueyesontruetrue false, no, off  false false, no, off falsenoofffalsefalse @, this this @, this@thisthisthis a in b [].indexOf.call(b, a) >= 0 a in ba in b[].indexOf.call(b, a) >= 0[].indexOf.call(b, a) >= 0 a of b a in b a of ba of ba in ba in b for a from b for (a of b) for a from bfor a from bfor (a of b)for (a of b) a ** b a ** b a ** ba ** ba ** ba ** b a // b Math.floor(a / b) a // ba // bMath.floor(a / b)Math.floor(a / b) a %% b (a % b + b) % b a %% ba %% b(a % b + b) % b(a % b + b) % b               launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"                 var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));                       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"                 var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));               launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"     launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\" launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\" launch()ifignitionisonvolume=10ifbandisntSpinalTapletTheWildRumpusBegin()unlessanswerisnoifcar.speed<limitthenaccelerate()winner=yesifpickin[47,92,13]printinspect\"My name is #{@name}\"       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));     var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`)); var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`)); varvolumewinnerifignition===truelaunchifband!==SpinalTapvolume=10ifanswer!==falseletTheWildRumpusBeginifcarspeed<limitaccelerateifpick===47||pick===92||pick===13winner=trueprintinspect`My name is ${thisname}`The Existential OperatorIt’s a little difficult to check for the existence of a variable in JavaScript. if (variable) … comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator ? returns true unless a variable is null or undefined or undeclared, which makes it analogous to Ruby’s nil?.if (variable) …?nullundefinednil?It can also be used for safer conditional assignment than the JavaScript pattern a = a || value provides, for cases where you may be handling numbers or strings.a = a || value               solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"                 var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";                           \t footprints                       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"                 var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";               solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"     solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\" solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\" solipsism=trueifmind?andnotworld?speed=0speed?=15footprints=yeti?\"bear\"       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";     var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\"; var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\"; varfootprintssolipsismspeediftypeofmind!==\"undefined\"&&mind!==null&&typeofworld===\"undefined\"||world===nullsolipsism=truespeed=0ifspeed==nullspeed=15footprints=typeofyeti!==\"undefined\"&&yeti!==null?yeti\"bear\"             \t footprints                \t footprints      \t footprints \t \t Note that if the compiler knows that a is in scope and therefore declared, a? compiles to a != null, not a !== null. The != makes a loose comparison to null, which does double duty also comparing against undefined. The reverse also holds for not a? or unless a?.aa?a != nullnota !== null!=nullundefinednot a?unless a?               major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'                 var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }                       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'                 var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }               major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'     major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines' major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines' major='Computer Science'unlessmajor?signUpForClass'Introduction to Wines'       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }     var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); } var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); } varmajormajor='Computer Science'ifmajor==nullsignUpForClass'Introduction to Wines'If a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders should be typing when they want to check if a mystery variable exists.should               if window?   environment = 'browser (probably)'       if window?   environment = 'browser (probably)'                 var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }                       if window?   environment = 'browser (probably)'       if window?   environment = 'browser (probably)'                 var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }               if window?   environment = 'browser (probably)'       if window?   environment = 'browser (probably)'     if window?   environment = 'browser (probably)' if window?   environment = 'browser (probably)' ifwindow?environment='browser (probably)'       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }     var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; } var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; } varenvironmentiftypeofwindow!==\"undefined\"&&window!==nullenvironment='browser (probably)'The accessor variant of the existential operator ?. can be used to soak up null references in a chain of properties. Use it instead of the dot accessor . in cases where the base value may be null or undefined. If all of the properties exist then you’ll get the expected result, if the chain is broken, undefined is returned instead of the TypeError that would be raised otherwise.?..nullundefinedundefinedTypeError               zip = lottery.drawWinner?().address?.zipcode       zip = lottery.drawWinner?().address?.zipcode                 var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;                       zip = lottery.drawWinner?().address?.zipcode       zip = lottery.drawWinner?().address?.zipcode                 var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;               zip = lottery.drawWinner?().address?.zipcode       zip = lottery.drawWinner?().address?.zipcode     zip = lottery.drawWinner?().address?.zipcode zip = lottery.drawWinner?().address?.zipcode zip=lottery.drawWinner?().address?.zipcode       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;     var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0; var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0; varrefzipzip=typeoflotterydrawWinner===\"function\"?ref=lotterydrawWinneraddress!=null?refzipcodevoid0void0For completeness: Example Definition a? tests that a is in scope and a != null a ? b returns a if a is in scope and a != null; otherwise, b a?.b or a?['b'] returns a.b if a is in scope and a != null; otherwise, undefined a?(b, c) or a? b, c  returns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefined a ?= b assigns the value of b to a if a is not in scope or if a == null; produces the new value of a Example Definition Example Definition ExampleDefinition a? tests that a is in scope and a != null a ? b returns a if a is in scope and a != null; otherwise, b a?.b or a?['b'] returns a.b if a is in scope and a != null; otherwise, undefined a?(b, c) or a? b, c  returns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefined a ?= b assigns the value of b to a if a is not in scope or if a == null; produces the new value of a a? tests that a is in scope and a != null a?a?tests that a is in scope and a != nullaa != null a ? b returns a if a is in scope and a != null; otherwise, b a ? ba ? breturns a if a is in scope and a != null; otherwise, baaa != nullb a?.b or a?['b'] returns a.b if a is in scope and a != null; otherwise, undefined a?.b or a?['b']a?.ba?['b']returns a.b if a is in scope and a != null; otherwise, undefineda.baa != nullundefined a?(b, c) or a? b, c  returns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefined a?(b, c) or a? b, c a?(b, c)a? b, creturns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefinedabcaundefined a ?= b assigns the value of b to a if a is not in scope or if a == null; produces the new value of a a ?= ba ?= bassigns the value of b to a if a is not in scope or if a == null; produces the new value of abaaa == nullaChaining Function CallsLeading . closes all open calls, allowing for simpler chaining syntax..               $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'                 $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');                       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'                 $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');               $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'     $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white' $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white' $'body'.click(e)->$'.box'.fadeIn'fast'.addClass'show'.css'background','white'       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');     $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white'); $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white'); $'body'clickfunctionereturn$'.box'fadeIn'fast'addClass'show'css'background''white'Destructuring AssignmentJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:               theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]                 var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];                           \t theBait                       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]                 var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];               theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]     theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait] theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait] theBait=1000theSwitch=0[theBait,theSwitch]=[theSwitch,theBait]       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];     var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait]; var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait]; vartheBaittheSwitchtheBait=1000theSwitch=0theBaittheSwitch=theSwitchtheBait             \t theBait                \t theBait      \t theBait \t \t But it’s also helpful for dealing with functions that return multiple values.               weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"                 var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");                           \t forecast                       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"                 var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");               weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"     weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\" weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\" weatherReport=(location)-># Make an Ajax request to fetch the weather...[location,72,\"Mostly Sunny\"][city,temp,forecast]=weatherReport\"Berkeley, CA\"       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");     var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\"); var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\"); varcityforecasttempweatherReportweatherReport=functionlocation// Make an Ajax request to fetch the weather...returnlocation72\"Mostly Sunny\"citytempforecast=weatherReport\"Berkeley, CA\"             \t forecast                \t forecast      \t forecast \t \t Destructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.               futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists                 var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);                           \t name + \"-\" + street                       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists                 var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);               futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists     futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists futurists=  sculptor:\"Umberto Boccioni\"painter:\"Vladimir Burliuk\"poet:    name:\"F.T. Marinetti\"address:[\"Via Roma 42R\"\"Bellagio, Italy 22021\"    ]{sculptor}=futurists{poet:{name,address:[street,city]}}=futurists       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);     var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists); var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists); varcityfuturistsnamesculptorstreetfuturists=sculptor\"Umberto Boccioni\"painter\"Vladimir Burliuk\"poetname\"F.T. Marinetti\"address\"Via Roma 42R\"\"Bellagio, Italy 22021\"sculptor=futuristspoetnameaddressstreetcity=futurists             \t name + \"-\" + street                \t name + \"-\" + street      \t name + \"-\" + street \t \t Destructuring assignment can even be combined with splats.               tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")                 var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);                           \t contents.join(\"\")                       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")                 var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);               tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")     tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\") tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\") tag=\"<impossible>\"[open,contents...,close]=tag.split(\"\")       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);     var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1); var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1); varclosecontentsopenreftagsplice=splicetag=\"<impossible>\"ref=tagsplit\"\"open...contents=refclose=splicecallcontents-1             \t contents.join(\"\")                \t contents.join(\"\")      \t contents.join(\"\") \t \t Expansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.               text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"                 var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);                           \t first + \" \" + last                       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"                 var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);               text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"     text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \" text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \" text=\"Every literary critic believes he will        outwit history and have the last word\"[first,...,last]=text.split\" \"       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);     var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1); var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1); varfirstlastreftextslice=slicetext=\"Every literary critic believes he will outwit history and have the last word\"ref=textsplit\" \"first=reflast=slicecallref-1             \t first + \" \" + last                \t first + \" \" + last      \t first + \" \" + last \t \t Destructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.               class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4                 var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });                           \t tim.age + \" \" + tim.height                       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4                 var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });               class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4     class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4 class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4 classPersonconstructor:(options)->{@name,@age,@height='average'}=optionstim=newPersonname:'Tim',age:4       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });     var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 }); var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 }); varPersontimPerson=classPersonconstructoroptionsnamethisnameagethisageheightthisheight='average'=optionstim=newPersonname'Tim'age4             \t tim.age + \" \" + tim.height                \t tim.age + \" \" + tim.height      \t tim.age + \" \" + tim.height \t \t The above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or undefined—passing null will set a value of null, not the default.undefinedpassing null will set a value of nullnullnullBound (Fat Arrow) FunctionsIn JavaScript, the this keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of this will be lost. If you’re not familiar with this behavior, this Digital Web article gives a good overview of the quirks.thisthisthis Digital Web articleThe fat arrow => can be used to both define a function, and to bind it to the current value of this, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to each, or event-handler functions to use with on. Functions created with the fat arrow are able to access properties of the this where they’re defined.=>thiseachonthis               Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart                 var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };                       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart                 var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };               Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart     Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart Account=(customer,cart)->@customer=customer@cart=cart$('.shopping_cart').on'click',(event)=>@customer.purchase@cart       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };     var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); }; var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); }; varAccountAccount=functioncustomercartthiscustomer=customerthiscart=cartreturn$'.shopping_cart'on'click'event=>returnthiscustomerpurchasethiscartIf we had used -> in the callback above, @customer would have referred to the undefined “customer” property of the DOM element, and trying to call purchase() on it would have raised an exception.->@customerpurchase()The fat arrow was one of the most popular features of CoffeeScript, and ES2015 adopted it; so CoffeeScript 2 compiles => to ES =>.adopted it=>=>Generator FunctionsCoffeeScript supports ES2015 generator functions through the yield keyword. There’s no function*(){} nonsense — a generator in CoffeeScript is simply a function that yields.generator functionsyieldfunction*(){}               perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()                 var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());                           \t ps.next().value                       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()                 var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());               perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()     perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares() perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares() perfectSquares=->num=0loopnum+=1yieldnum*num  returnwindow.psor=perfectSquares()       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());     var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares()); var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares()); varperfectSquaresperfectSquares=function*varnumnum=0whiletruenum+=1yieldnum*numwindowps||windowps=perfectSquares             \t ps.next().value                \t ps.next().value      \t ps.next().value \t \t yield* is called yield from, and yield return may be used if you need to force a generator that doesn’t yield.yield*yield fromyield returnYou can iterate over a generator function using for…from.for…from               fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results                 var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };                           \t getFibonacciNumbers(10)                       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results                 var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };               fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results     fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results fibonacci=->[previous,current]=[1,1]loop[previous,current]=[current,previous+current]yieldcurrent  returngetFibonacciNumbers=(length)->results=[1]fornfromfibonacci()results.pushnbreakifresults.lengthislength  results       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };     var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; }; var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; }; varfibonaccigetFibonacciNumbersfibonacci=function*varcurrentpreviouspreviouscurrent=11whiletruepreviouscurrent=currentprevious+currentyieldcurrentgetFibonacciNumbers=functionlengthvarnrefresultsresults=1ref=fibonaccifornofrefresultspushnifresultslength===lengthbreakreturnresults             \t getFibonacciNumbers(10)                \t getFibonacciNumbers(10)      \t getFibonacciNumbers(10) \t \t Async FunctionsES2017’s async functions are supported through the await keyword. Like with generators, there’s no need for an async keyword; an async function in CoffeeScript is simply a function that awaits.async functionsawaitasyncSimilar to how yield return forces a generator, await return may be used to force a function to be async.yield returnawait return               # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3                 // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);                           \t                       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3                 // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);               # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3     # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3 # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3 # Your browser must support async/await and speech synthesis# to run this example.sleep=(ms)->newPromise(resolve)->window.setTimeoutresolve,mssay=(text)->window.speechSynthesis.cancel()window.speechSynthesis.speaknewSpeechSynthesisUtterancetextcountdown=(seconds)->foriin[seconds..1]sayiawaitsleep1000# wait one second  say\"Blastoff!\"countdown3       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);     // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3); // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3); // Your browser must support async/await and speech synthesis// to run this example.varcountdownsaysleepsleep=functionmsreturnnewPromisefunctionresolvereturnwindowsetTimeoutresolvemssay=functiontextwindowspeechSynthesiscancelreturnwindowspeechSynthesisspeaknewSpeechSynthesisUtterancetextcountdown=asyncfunctionsecondsvarijreffori=j=ref=secondsref<=1?j<=1j>=1i=ref<=1?++j--jsayiawaitsleep1000// wait one secondreturnsay\"Blastoff!\"countdown3             \t                \t      \t \t \t ClassesCoffeeScript 1 provided the class and extends keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its class and extends keywords to ES2015 classes.classextendsclassextends               class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()                 var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();                           \t                       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()                 var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();               class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()     class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move() class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move() classAnimalconstructor:(@name)->  move:(meters)->alert@name+\" moved #{meters}m.\"classSnakeextendsAnimalmove:->alert\"Slithering...\"super5classHorseextendsAnimalmove:->alert\"Galloping...\"super45sam=newSnake\"Sammy the Python\"tom=newHorse\"Tommy the Palomino\"sam.move()tom.move()       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();     var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move(); var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move(); varAnimalHorseSnakesamtomAnimal=classAnimalconstructornamethisname=namemovemetersreturnalertthisname+` moved ${meters}m.`Snake=classSnakeextendsAnimalmovealert\"Slithering...\"returnsupermove5Horse=classHorseextendsAnimalmovealert\"Galloping...\"returnsupermove45sam=newSnake\"Sammy the Python\"tom=newHorse\"Tommy the Palomino\"sammovetommove             \t                \t      \t \t \t Static methods can be defined using @ before the method name:@               class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '                 var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };                           \t Teenager.say(\"Are we there yet?\")                       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '                 var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };               class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '     class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', ' class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', ' classTeenager@say:(speech)->words=speech.split' 'fillers=['uh','um','like','actually','so','maybe']output=[]forword,indexinwordsoutput.pushwordoutput.pushfillers[Math.floor(Math.random()*fillers.length)]unlessindexiswords.length-1    output.join', '       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };     var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } }; var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } }; varTeenagerTeenager=classTeenagerstaticsayspeechvarfillersiindexlenoutputwordwordswords=speechsplit' 'fillers='uh''um''like''actually''so''maybe'output=forindex=i=0len=wordslengthi<lenindex=++iword=wordsindexoutputpushwordifindex!==wordslength-1outputpushfillersMathfloorMathrandom*fillerslengthreturnoutputjoin', '             \t Teenager.say(\"Are we there yet?\")                \t Teenager.say(\"Are we there yet?\")      \t Teenager.say(\"Are we there yet?\") \t \t Finally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, this is the class object itself; therefore, you can assign static properties by using @property: value.this@property: valuePrototypal InheritanceIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The :: operator gives you quick access to an object’s prototype:::               String::dasherize = ->   this.replace /_/g, \"-\"       String::dasherize = ->   this.replace /_/g, \"-\"                 String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };                           \t \"one_two\".dasherize()                       String::dasherize = ->   this.replace /_/g, \"-\"       String::dasherize = ->   this.replace /_/g, \"-\"                 String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };               String::dasherize = ->   this.replace /_/g, \"-\"       String::dasherize = ->   this.replace /_/g, \"-\"     String::dasherize = ->   this.replace /_/g, \"-\" String::dasherize = ->   this.replace /_/g, \"-\" String::dasherize=->this.replace/_/g,\"-\"       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };     String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); }; String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); }; Stringprototypedasherize=functionreturnthisreplace/_/g\"-\"             \t \"one_two\".dasherize()                \t \"one_two\".dasherize()      \t \"one_two\".dasherize() \t \t Switch/When/Elseswitch statements in JavaScript are a bit awkward. You need to remember to break at the end of every case statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the switch into a returnable, assignable expression. The format is: switch condition, when clauses, else the default case.switchbreakcaseswitchswitchwhenelseAs in Ruby, switch statements in CoffeeScript can take multiple values for each when clause. If any of the values match, the clause runs.switchwhen               switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work                 switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }                       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work                 switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }               switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work     switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work switchdaywhen\"Mon\"thengoworkwhen\"Tue\"thengorelaxwhen\"Thu\"thengoiceFishingwhen\"Fri\",\"Sat\"    ifdayisbingoDaygobingogodancing  when\"Sun\"thengochurchelsegowork       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }     switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); } switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); } switchdaycase\"Mon\"goworkbreakcase\"Tue\"gorelaxbreakcase\"Thu\"goiceFishingbreakcase\"Fri\"case\"Sat\"ifday===bingoDaygobingogodancingbreakcase\"Sun\"gochurchbreakdefaultgoworkswitch statements can also be used without a control expression, turning them in to a cleaner alternative to if/else chains.switchifelse               score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'                 var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'                       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'                 var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'               score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'     score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C' score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C' score=76grade=switchwhenscore<60then'F'whenscore<70then'D'whenscore<80then'C'whenscore<90then'B'else'A'# grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'     var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C' var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C' vargradescorescore=76grade=functionswitchfalsecase!score<60return'F'case!score<70return'D'case!score<80return'C'case!score<90return'B'defaultreturn'A'// grade == 'C'Try/Catch/Finallytry expressions have the same semantics as try statements in JavaScript, though in CoffeeScript, you may omit both the catch and finally parts. The catch part may also omit the error parameter if it is not needed.trytryboth               try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()                 var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }                       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()                 var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }               try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()     try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp() try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp() tryallHellBreaksLoose()catsAndDogsLivingTogether()catcherrorprinterrorfinallycleanUp()       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }     var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); } var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); } varerrortryallHellBreaksLoosecatsAndDogsLivingTogethercatcherror1error=error1printerrorfinallycleanUpChained ComparisonsCoffeeScript borrows chained comparisons from Python — making it easy to test if a value falls within a certain range.chained comparisons               cholesterol = 127 healthy = 200 > cholesterol > 60       cholesterol = 127 healthy = 200 > cholesterol > 60                 var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);                           \t healthy                       cholesterol = 127 healthy = 200 > cholesterol > 60       cholesterol = 127 healthy = 200 > cholesterol > 60                 var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);               cholesterol = 127 healthy = 200 > cholesterol > 60       cholesterol = 127 healthy = 200 > cholesterol > 60     cholesterol = 127 healthy = 200 > cholesterol > 60 cholesterol = 127 healthy = 200 > cholesterol > 60 cholesterol=127healthy=200>cholesterol>60       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);     var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60); var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60); varcholesterolhealthycholesterol=127healthy=200>cholesterol&&cholesterol>60             \t healthy                \t healthy      \t healthy \t \t Block Regular ExpressionsSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s /x modifier, CoffeeScript’s block regexes are delimited by /// and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:/x///               NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i                 var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal                       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i                 var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal               NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i     NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i NUMBER=///  ^0b[01]+|# binary^0o[0-7]+|# octal^0x[\\da-f]+|# hex^\\d*\\.?\\d+(?:e[+-]?\\d+)?# decimal///i       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal     var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal varNUMBERNUMBER=/^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i// binary// octal// hex// decimalTagged Template LiteralsCoffeeScript supports ES2015 tagged template literals, which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will behave accordingly: the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.ES2015 tagged template literalsbehave accordingly               upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"                 var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };                           \t greet(\"greg\", \"awesome\")                       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"                 var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };               upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"     upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\" upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\" upperCaseExpr=(textParts,expressions...)->textParts.reduce(text,textPart,i)->text+expressions[i-1].toUpperCase()+textPartgreet=(name,adjective)->upperCaseExpr\"\"\"               Hi #{name}. You look #{adjective}!               \"\"\"       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };     var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; }; var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; }; vargreetupperCaseExprupperCaseExpr=functiontextParts...expressionsreturntextPartsreducefunctiontexttextPartireturntext+expressionsi-1toUpperCase+textPartgreet=functionnameadjectivereturnupperCaseExpr`Hi ${name}. You look ${adjective}!`             \t greet(\"greg\", \"awesome\")                \t greet(\"greg\", \"awesome\")      \t greet(\"greg\", \"awesome\") \t \t ModulesES2015 modules are supported in CoffeeScript, with very similar import and export syntax:importexport               import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'                 import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';                       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'                 import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';               import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'     import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore' import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore' import'local-file.coffee'import'coffeescript'import_from'underscore'import*asunderscorefrom'underscore'import{now}from'underscore'import{nowascurrentTimestamp}from'underscore'import{first,last}from'underscore'importutilityBelt,{each}from'underscore'exportdefaultMathexportsquare=(x)->x*xexportclassMathematicsleast:(x,y)->ifx<ythenxelseyexport{sqrt}export{sqrtassquareRoot}export{Mathematicsasdefault,sqrtassquareRoot}export*from'underscore'export{max,min}from'underscore'       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';     import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore'; import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore'; import'local-file.coffee'import'coffeescript'import_from'underscore'import*asunderscorefrom'underscore'importnowfrom'underscore'importnowascurrentTimestampfrom'underscore'importfirstlastfrom'underscore'importutilityBelteachfrom'underscore'exportdefaultMathexportvarsquare=functionxreturnx*xexportvarMathematics=classMathematicsleastxyifx<yreturnxelsereturnyexportsqrtexportsqrtassquareRootexportMathematicsasdefaultsqrtassquareRootexport*from'underscore'exportmaxminfrom'underscore'Note that the CoffeeScript compiler does not resolve modules; writing an import or export statement in CoffeeScript will produce an import or export statement in the resulting output. It is your responsibility to transpile this ES2015 syntax into code that will work in your target runtimes.does not resolve modulesimportexportimportexporttranspileAlso note that any file with an import or export statement will be output without a top-level function safety wrapper; in other words, importing or exporting modules will automatically trigger bare mode for that file. This is because per the ES2015 spec, import or export statements must occur at the topmost scope.importexporttop-level function safety wrapperbareimportexportEmbedded JavaScriptHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.               hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`                 var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };                           \t hi()                       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`                 var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };               hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`     hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }` hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }` hi=`function(){return[document.title,\"Hello JavaScript\"].join(\": \");}`       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };     var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }; var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }; varhihi=functionreturndocumenttitle\"Hello JavaScript\"join\": \"             \t hi()                \t hi()      \t hi() \t \t Escape backticks with backslashes: \\`​ becomes `​.\\`​`​Escape backslashes before backticks with more backslashes: \\\\\\`​ becomes \\`​.\\\\\\`​\\`​               markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`                 var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };                           \t markdown()                       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`                 var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };               markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`     markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }` markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }` markdown=`function(){return\\`InMarkdown,writecodelike\\\\\\`this\\\\\\`\\`;}`       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };     var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; }; var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; }; varmarkdownmarkdown=functionreturn`In Markdown, write code like \\`this\\``             \t markdown()                \t markdown()      \t markdown() \t \t You can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.               ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```                 function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;                           \t time()                       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```                 function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;               ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```     ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ``` ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ``` ```functiontime(){return`Thetimeis${newDate().toLocaleTimeString()}`;}```       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;     function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ; function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ; functiontimereturn`The time is ${newDatetoLocaleTimeString}`             \t time()                \t time()      \t time() \t \t JSXJSX is JavaScript containing interspersed XML elements. While conceived for React, it is not specific to any particular library or framework.JSXReactCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by Babel with the React JSX transform. CoffeeScript does not output React.createElement calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.Babel with the React JSX transformnotReact.createElementJust like in JSX and HTML, denote XML tags using < and >. You can interpolate CoffeeScript code inside a tag using { and }. To avoid compiler errors, when using < and > to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So i < len, not i<len. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.<>{}<>i < leni<len               renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>                 var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };                       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>                 var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };               renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>     renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside> renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside> renderStarRating=({rating,maxStars})-><asidetitle={\"Rating: #{rating} of #{maxStars} stars\"}>    {forwholeStarin[0...Math.floor(rating)]      <StarclassName=\"wholeStar\"key={wholeStar}/>}{ifrating%1isnt0      <StarclassName=\"halfStar\"/>}{foremptyStarin[Math.ceil(rating)...maxStars]      <StarclassName=\"emptyStar\"key={emptyStar}/>}  </aside>       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };     var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; }; var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; }; varrenderStarRatingrenderStarRating=functionratingmaxStarsvaremptyStarwholeStarreturn<asidetitle=`Rating: ${ratingof$maxStarsstars`}>{(function() {var i, ref, results;results = [];for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {results.push(<Star className=\"wholeStar\" key={wholeStar} />);}return results;})()}{(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}{(function() {var i, ref, ref1, results;results = [];for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {results.push(<Star className=\"emptyStar\" key={emptyStar} />);}return results;})()}</aside>;};Older plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a .cjsx file extension, but this is no longer necessary; regular .coffee will do..cjsx.coffee","dataLevel":1,"level":1,"parent":false},{"section":"functions","title":"Functions","content":"Functions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: ->->               square = (x) -> x * x cube   = (x) -> square(x) * x       square = (x) -> x * x cube   = (x) -> square(x) * x                 var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };                           \t cube(5)                       square = (x) -> x * x cube   = (x) -> square(x) * x       square = (x) -> x * x cube   = (x) -> square(x) * x                 var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };               square = (x) -> x * x cube   = (x) -> square(x) * x       square = (x) -> x * x cube   = (x) -> square(x) * x     square = (x) -> x * x cube   = (x) -> square(x) * x square = (x) -> x * x cube   = (x) -> square(x) * x square=(x)->x*xcube=(x)->square(x)*x       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };       var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; };     var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; }; var cube, square; square = function(x) {   return x * x; }; cube = function(x) {   return square(x) * x; }; varcubesquaresquare=functionxreturnx*xcube=functionxreturnsquarex*x             \t cube(5)                \t cube(5)      \t cube(5) \t \t Functions may also have default values for arguments, which will be used if the incoming argument is missing (undefined).undefined               fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"                 var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };                           \t fill(\"cup\")                       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"                 var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };               fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"       fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\"     fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\" fill = (container, liquid = \"coffee\") ->   \"Filling the #{container} with #{liquid}...\" fill=(container,liquid=\"coffee\")->\"Filling the #{container} with #{liquid}...\"       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };       var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; };     var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; }; var fill; fill = function(container, liquid = \"coffee\") {   return `Filling the ${container} with ${liquid}...`; }; varfillfill=functioncontainerliquid=\"coffee\"return`Filling the ${container}with ${liquid}...`             \t fill(\"cup\")                \t fill(\"cup\")      \t fill(\"cup\") \t \t ","dataLevel":1,"level":2,"parent":"language"},{"section":"strings","title":"Strings","content":"Like JavaScript and many other languages, CoffeeScript supports strings as delimited by the \" or ' characters. CoffeeScript also supports string interpolation within \"-quoted strings, using #{ … }. Single-quoted strings are literal. You may even use interpolation in object keys.\"'\"#{ … }               author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"                 var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;                           \t sentence                       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"                 var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;               author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"       author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\"     author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\" author = \"Wittgenstein\" quote  = \"A picture is a fact. -- #{ author }\" sentence = \"#{ 22 / 7 } is a decent approximation of π\" author=\"Wittgenstein\"quote=\"A picture is a fact. -- #{ author }\"sentence=\"#{ 22 / 7 } is a decent approximation of π\"       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;       var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`;     var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`; var author, quote, sentence; author = \"Wittgenstein\"; quote = `A picture is a fact. -- ${author}`; sentence = `${22 / 7} is a decent approximation of π`; varauthorquotesentenceauthor=\"Wittgenstein\"quote=`A picture is a fact. -- ${author}`sentence=`${22/7}is a decent approximation of π`             \t sentence                \t sentence      \t sentence \t \t Multiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.               mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"                 var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";                           \t mobyDick                       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"                 var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";               mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"       mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\"     mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\" mobyDick = \"Call me Ishmael. Some years ago --   never mind how long precisely -- having little   or no money in my purse, and nothing particular   to interest me on shore, I thought I would sail   about a little and see the watery part of the   world...\" mobyDick=\"Call me Ishmael. Some years ago --  never mind how long precisely -- having little  or no money in my purse, and nothing particular  to interest me on shore, I thought I would sail  about a little and see the watery part of the  world...\"       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";       var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";     var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\"; var mobyDick; mobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\"; varmobyDickmobyDick=\"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\"             \t mobyDick                \t mobyDick      \t mobyDick \t \t Block strings, delimited by \"\"\" or ''', can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\"\"\"'''               html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"                 var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";                           \t html                       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"                 var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";               html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"       html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\"     html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\" html = \"\"\"        <strong>          cup of coffeescript        </strong>        \"\"\" html=\"\"\"       <strong>         cup of coffeescript       </strong>       \"\"\"       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";       var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\";     var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\"; var html; html = \"<strong>\\n  cup of coffeescript\\n</strong>\"; varhtmlhtml=\"<strong>\\n  cup of coffeescript\\n</strong>\"             \t html                \t html      \t html \t \t Double-quoted block strings, like other double-quoted strings, allow interpolation.","dataLevel":1,"level":2,"parent":"language"},{"section":"objects-and-arrays","title":"Objects and Arrays","content":"The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to YAML.YAML               song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9                 var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };                           \t song.join(\" … \")                       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9                 var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };               song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9       song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9     song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9 song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"] singers = {Jagger: \"Rock\", Elvis: \"Roll\"} bitlist = [   1, 0, 1   0, 0, 1   1, 1, 0 ] kids =   brother:     name: \"Max\"     age:  11   sister:     name: \"Ida\"     age:  9 song=[\"do\",\"re\",\"mi\",\"fa\",\"so\"]singers={Jagger:\"Rock\",Elvis:\"Roll\"}bitlist=[1,0,10,0,11,1,0]kids=  brother:    name:\"Max\"age:11  sister:    name:\"Ida\"age:9       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };       var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } };     var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } }; var bitlist, kids, singers, song; song = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]; singers = {   Jagger: \"Rock\",   Elvis: \"Roll\" }; bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0]; kids = {   brother: {     name: \"Max\",     age: 11   },   sister: {     name: \"Ida\",     age: 9   } }; varbitlistkidssingerssongsong=\"do\"\"re\"\"mi\"\"fa\"\"so\"singers=Jagger\"Rock\"Elvis\"Roll\"bitlist=101001110kids=brothername\"Max\"age11sistername\"Ida\"age9             \t song.join(\" … \")                \t song.join(\" … \")      \t song.join(\" … \") \t \t CoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name.               name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"                 var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;                       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"                 var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;               name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"     name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\" name = \"Michelangelo\" mask = \"orange\" weapon = \"nunchuks\" turtle = {name, mask, weapon} output = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\" name=\"Michelangelo\"mask=\"orange\"weapon=\"nunchuks\"turtle={name,mask,weapon}output=\"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;       var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;     var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`; var mask, name, output, turtle, weapon; name = \"Michelangelo\"; mask = \"orange\"; weapon = \"nunchuks\"; turtle = {name, mask, weapon}; output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`; varmasknameoutputturtleweaponname=\"Michelangelo\"mask=\"orange\"weapon=\"nunchuks\"turtle=namemaskweaponoutput=`${turtlename}wears an ${turtlemask}mask. Watch out for his ${turtleweapon}!`","dataLevel":1,"level":2,"parent":"language"},{"section":"comments","title":"Comments","content":"In CoffeeScript, comments are denoted by the # character to the end of a line, or from ### to the next appearance of ###. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.#######               ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!                 /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };                       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!                 /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };               ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!       ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed!     ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed! ### Fortune Cookie Reader v1.0 Released under the MIT License ### sayFortune = (fortune) ->   console.log fortune # in bed! ###Fortune Cookie Reader v1.0Released under the MIT License###sayFortune=(fortune)->console.logfortune# in bed!       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };       /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! };     /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! }; /* Fortune Cookie Reader v1.0 Released under the MIT License */ var sayFortune; sayFortune = function(fortune) {   return console.log(fortune); // in bed! }; /*Fortune Cookie Reader v1.0Released under the MIT License*/varsayFortunesayFortune=functionfortunereturnconsolelogfortune// in bed!Inline ### comments make type annotations possible.###type annotations","dataLevel":1,"level":2,"parent":"language"},{"section":"lexical-scope","title":"Lexical Scoping and Variable Safety","content":"The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write var yourself.var               outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()                 var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();                           \t inner                       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()                 var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();               outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()       outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers()     outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers() outer = 1 changeNumbers = ->   inner = -1   outer = 10 inner = changeNumbers() outer=1changeNumbers=->inner=-1outer=10inner=changeNumbers()       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();       var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers();     var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers(); var changeNumbers, inner, outer; outer = 1; changeNumbers = function() {   var inner;   inner = -1;   return outer = 10; }; inner = changeNumbers(); varchangeNumbersinnerouterouter=1changeNumbers=functionvarinnerinner=-1returnouter=10inner=changeNumbers             \t inner                \t inner      \t inner \t \t Notice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. outer is not redeclared within the inner function, because it’s already in scope; inner within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.outerinnerBecause you don’t have direct access to the var keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.varAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with import or export statements) is wrapped in an anonymous function: (function(){ … })();. This safety wrapper, combined with the automatic generation of the var keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the bare option, and is unnecessary and automatically disabled when using modules.)importexport(function(){ … })();varbare optionbareIf you’d like to create top-level variables for other scripts to use, attach them as properties on window; attach them as properties on the exports object in CommonJS; or use an export statement. If you’re targeting both CommonJS and the browser, the existential operator (covered below), gives you a reliable way to figure out where to add them: exports ? this.windowexportsexport statementexportexistential operatorexports ? thisSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s let or const. This is intentional; we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.letconstThis is intentional","dataLevel":1,"level":2,"parent":"language"},{"section":"conditionals","title":"If, Else, Unless, and Conditional Assignment","content":"if/else statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the if or unless at the end.ifelseifunlessCoffeeScript can compile if statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular if statement on a single line.ifif               mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill                 var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;                       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill                 var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;               mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill       mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill     mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill mood = greatlyImproved if singing if happy and knowsIt   clapsHands()   chaChaCha() else   showIt() date = if friday then sue else jill mood=greatlyImprovedifsingingifhappyandknowsItclapsHands()chaChaCha()elseshowIt()date=iffridaythensueelsejill       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;       var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill;     var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill; var date, mood; if (singing) {   mood = greatlyImproved; } if (happy && knowsIt) {   clapsHands();   chaChaCha(); } else {   showIt(); } date = friday ? sue : jill; vardatemoodifsingingmood=greatlyImprovedifhappy&&knowsItclapsHandschaChaChaelseshowItdate=friday?suejill","dataLevel":1,"level":2,"parent":"language"},{"section":"splats","title":"Splats, or Rest Parameters/Spread Syntax","content":"The JavaScript arguments object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats ..., both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their rest parameters.arguments...rest parameters               gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"                 var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);                           \t                       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"                 var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);               gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"       gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\"     gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\" gold = silver = rest = \"unknown\" awardMedals = (first, second, others...) ->   gold   = first   silver = second   rest   = others contenders = [   \"Michael Phelps\"   \"Liu Xiang\"   \"Yao Ming\"   \"Allyson Felix\"   \"Shawn Johnson\"   \"Roman Sebrle\"   \"Guo Jingjing\"   \"Tyson Gay\"   \"Asafa Powell\"   \"Usain Bolt\" ] awardMedals contenders... alert \"\"\" Gold: #{gold} Silver: #{silver} The Field: #{rest.join ', '} \"\"\" gold=silver=rest=\"unknown\"awardMedals=(first,second,others...)->gold=firstsilver=secondrest=otherscontenders=[\"Michael Phelps\"\"Liu Xiang\"\"Yao Ming\"\"Allyson Felix\"\"Shawn Johnson\"\"Roman Sebrle\"\"Guo Jingjing\"\"Tyson Gay\"\"Asafa Powell\"\"Usain Bolt\"]awardMedalscontenders...alert\"\"\"Gold: #{gold}Silver: #{silver}The Field: #{rest.join ', '}\"\"\"       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);       var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`);     var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`); var awardMedals, contenders, gold, rest, silver; gold = silver = rest = \"unknown\"; awardMedals = function(first, second, ...others) {   gold = first;   silver = second;   return rest = others; }; contenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"]; awardMedals(...contenders); alert(`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${rest.join(', ')}`); varawardMedalscontendersgoldrestsilvergold=silver=rest=\"unknown\"awardMedals=functionfirstsecond...othersgold=firstsilver=secondreturnrest=otherscontenders=\"Michael Phelps\"\"Liu Xiang\"\"Yao Ming\"\"Allyson Felix\"\"Shawn Johnson\"\"Roman Sebrle\"\"Guo Jingjing\"\"Tyson Gay\"\"Asafa Powell\"\"Usain Bolt\"awardMedals...contendersalert`Gold: ${gold}\\nSilver: ${silver}\\nThe Field: ${restjoin', '}`             \t                \t      \t \t \t Splats also let us elide array elements…               popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']                 var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];                           \t all                       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']                 var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];               popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']       popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms']     popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms'] popular  = ['pepperoni', 'sausage', 'cheese'] unwanted = ['anchovies', 'olives'] all = [popular..., unwanted..., 'mushrooms'] popular=['pepperoni','sausage','cheese']unwanted=['anchovies','olives']all=[popular...,unwanted...,'mushrooms']       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];       var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms'];     var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms']; var all, popular, unwanted; popular = ['pepperoni', 'sausage', 'cheese']; unwanted = ['anchovies', 'olives']; all = [...popular, ...unwanted, 'mushrooms']; varallpopularunwantedpopular='pepperoni''sausage''cheese'unwanted='anchovies''olives'all=...popular...unwanted'mushrooms'             \t all                \t all      \t all \t \t …and object properties.               user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }                 var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };                           \t JSON.stringify(currentUser)                       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }                 var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };               user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }       user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' }     user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' } user =   name: 'Werner Heisenberg'   occupation: 'theoretical physicist' currentUser = { user..., status: 'Uncertain' } user=  name:'Werner Heisenberg'occupation:'theoretical physicist'currentUser={user...,status:'Uncertain'}       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };       var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' };     var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' }; var currentUser, user; user = {   name: 'Werner Heisenberg',   occupation: 'theoretical physicist' }; currentUser = {   ...user,   status: 'Uncertain' }; varcurrentUseruseruser=name'Werner Heisenberg'occupation'theoretical physicist'currentUser=...userstatus'Uncertain'             \t JSON.stringify(currentUser)                \t JSON.stringify(currentUser)      \t JSON.stringify(currentUser) \t \t In ECMAScript this is called spread syntax, and has been supported for arrays since ES2015 and objects since ES2018.spread syntax","dataLevel":1,"level":2,"parent":"language"},{"section":"loops","title":"Loops and Comprehensions","content":"Most of the loops you’ll write in CoffeeScript will be comprehensions over arrays, objects, and ranges. Comprehensions replace (and compile into) for loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.comprehensionsfor               # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'                 // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }                       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'                 // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }               # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'       # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate'     # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate' # Eat lunch. eat = (food) -> \"#{food} eaten.\" eat food for food in ['toast', 'cheese', 'wine'] # Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'] menu = (i, dish) -> \"Menu Item #{i}: #{dish}\"  menu i + 1, dish for dish, i in courses # Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate'] eat food for food in foods when food isnt 'chocolate' # Eat lunch.eat=(food)->\"#{food} eaten.\"eatfoodforfoodin['toast','cheese','wine']# Fine five course dining.courses=['greens','caviar','truffles','roast','cake']menu=(i,dish)->\"Menu Item #{i}: #{dish}\"menui+1,dishfordish,iincourses# Health conscious meal.foods=['broccoli','spinach','chocolate']eatfoodforfoodinfoodswhenfoodisnt'chocolate'       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }       // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } }     // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } } // Eat lunch. var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref; eat = function(food) {   return `${food} eaten.`; }; ref = ['toast', 'cheese', 'wine']; for (j = 0, len = ref.length; j < len; j++) {   food = ref[j];   eat(food); } // Fine five course dining. courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']; menu = function(i, dish) {   return `Menu Item ${i}: ${dish}`; }; for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {   dish = courses[i];   menu(i + 1, dish); } // Health conscious meal. foods = ['broccoli', 'spinach', 'chocolate']; for (l = 0, len2 = foods.length; l < len2; l++) {   food = foods[l];   if (food !== 'chocolate') {     eat(food);   } } // Eat lunch.varcoursesdisheatfoodfoodsijkllenlen1len2menurefeat=functionfoodreturn`${food}eaten.`ref='toast''cheese''wine'forj=0len=reflengthj<lenj++food=refjeatfood// Fine five course dining.courses='greens''caviar''truffles''roast''cake'menu=functionidishreturn`Menu Item ${i}: ${dish}`fori=k=0len1=courseslengthk<len1i=++kdish=coursesimenui+1dish// Health conscious meal.foods='broccoli''spinach''chocolate'forl=0len2=foodslengthl<len2l++food=foodsliffood!=='chocolate'eatfoodComprehensions should be able to handle most places where you otherwise would use a loop, each/forEach, map, or select/filter, for example: shortNames = (name for name in list when name.length < 5) If you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.eachforEachmapselectfiltershortNames = (name for name in list when name.length < 5)               countdown = (num for num in [10..1])       countdown = (num for num in [10..1])                 var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();                           \t countdown                       countdown = (num for num in [10..1])       countdown = (num for num in [10..1])                 var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();               countdown = (num for num in [10..1])       countdown = (num for num in [10..1])     countdown = (num for num in [10..1]) countdown = (num for num in [10..1]) countdown=(numfornumin[10..1])       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();       var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })();     var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })(); var countdown, num; countdown = (function() {   var i, results;   results = [];   for (num = i = 10; i >= 1; num = --i) {     results.push(num);   }   return results; })(); varcountdownnumcountdown=functionvariresultsresults=fornum=i=10i>=1num=--iresultspushnumreturnresults             \t countdown                \t countdown      \t countdown \t \t Note how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like true — or null, to the bottom of your function.truenullTo step through a range comprehension in fixed-size chunks, use by, for example: evens = (x for x in [0..10] by 2)byevens = (x for x in [0..10] by 2)If you don’t need the current iteration value you may omit it: browser.closeCurrentTab() for [0...count]browser.closeCurrentTab() for [0...count]Comprehensions can also be used to iterate over the keys and values in an object. Use of to signal comprehension over the properties of an object instead of the values in an array.of               yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"                 var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();                           \t ages.join(\", \")                       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"                 var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();               yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"       yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\"     yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\" yearsOld = max: 10, ida: 9, tim: 11 ages = for child, age of yearsOld   \"#{child} is #{age}\" yearsOld=max:10,ida:9,tim:11ages=forchild,ageofyearsOld\"#{child} is #{age}\"       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();       var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })();     var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })(); var age, ages, child, yearsOld; yearsOld = {   max: 10,   ida: 9,   tim: 11 }; ages = (function() {   var results;   results = [];   for (child in yearsOld) {     age = yearsOld[child];     results.push(`${child} is ${age}`);   }   return results; })(); varageageschildyearsOldyearsOld=max10ida9tim11ages=functionvarresultsresults=forchildinyearsOldage=yearsOldchildresultspush`${child}is ${age}`returnresults             \t ages.join(\", \")                \t ages.join(\", \")      \t ages.join(\", \") \t \t If you would like to iterate over just the keys that are defined on the object itself, by adding a hasOwnProperty check to avoid properties that may be inherited from the prototype, use for own key, value of object.hasOwnPropertyfor own key, value of objectTo iterate a generator function, use from. See Generator Functions.fromGenerator FunctionsThe only low-level loop that CoffeeScript provides is the while loop. The main difference from JavaScript is that the while loop can be used as an expression, returning an array containing the result of each iteration through the loop.whilewhile               # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"                 // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();                           \t lyrics.join(\"\\n\")                       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"                 // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();               # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"       # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\"     # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\" # Econ 101 if this.studyingEconomics   buy()  while supply > demand   sell() until supply > demand # Nursery Rhyme num = 6 lyrics = while num -= 1   \"#{num} little monkeys, jumping on the bed.     One fell out and bumped his head.\" # Econ 101ifthis.studyingEconomicsbuy()whilesupply>demand  sell()untilsupply>demand# Nursery Rhymenum=6lyrics=whilenum-=1\"#{num} little monkeys, jumping on the bed.    One fell out and bumped his head.\"       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();       // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })();     // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })(); // Econ 101 var lyrics, num; if (this.studyingEconomics) {   while (supply > demand) {     buy();   }   while (!(supply > demand)) {     sell();   } } // Nursery Rhyme num = 6; lyrics = (function() {   var results;   results = [];   while (num -= 1) {     results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);   }   return results; })(); // Econ 101varlyricsnumifthisstudyingEconomicswhilesupply>demandbuywhile!supply>demandsell// Nursery Rhymenum=6lyrics=functionvarresultsresults=whilenum-=1resultspush`${num}little monkeys, jumping on the bed. One fell out and bumped his head.`returnresults             \t lyrics.join(\"\\n\")                \t lyrics.join(\"\\n\")      \t lyrics.join(\"\\n\") \t \t For readability, the until keyword is equivalent to while not, and the loop keyword is equivalent to while true.untilwhile notloopwhile trueWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the do keyword, which immediately invokes a passed function, forwarding any arguments.do               for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()                 var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }                       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()                 var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }               for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()       for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString()     for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString() for filename in list   do (filename) ->     if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']       fs.readFile filename, (err, contents) ->         compile filename, contents.toString() forfilenameinlistdo(filename)->iffilenamenotin['.DS_Store','Thumbs.db','ehthumbs.db']fs.readFilefilename,(err,contents)->compilefilename,contents.toString()       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }       var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); }     var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); } var filename, i, len; for (i = 0, len = list.length; i < len; i++) {   filename = list[i];   (function(filename) {     if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {       return fs.readFile(filename, function(err, contents) {         return compile(filename, contents.toString());       });     }   })(filename); } varfilenameilenfori=0len=listlengthi<leni++filename=listifunctionfilenameiffilename!=='.DS_Store'&&filename!=='Thumbs.db'&&filename!=='ehthumbs.db'returnfsreadFilefilenamefunctionerrcontentsreturncompilefilenamecontentstoStringfilename","dataLevel":1,"level":2,"parent":"language"},{"section":"slices","title":"Array Slicing and Splicing with Ranges","content":"Ranges can also be used to extract slices of arrays. With two dots (3..6), the range is inclusive (3, 4, 5, 6); with three dots (3...6), the range excludes the end (3, 4, 5). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.3..63, 4, 5, 63...63, 4, 5               numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]                 var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);                           \t middle                       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]                 var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);               numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]       numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..]     numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] start   = numbers[0..2] middle  = numbers[3...-2] end     = numbers[-2..] copy    = numbers[..] numbers=[1,2,3,4,5,6,7,8,9]start=numbers[0..2]middle=numbers[3...-2]end=numbers[-2..]copy=numbers[..]       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);       var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0);     var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0); var copy, end, middle, numbers, start; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]; start = numbers.slice(0, 3); middle = numbers.slice(3, -2); end = numbers.slice(-2); copy = numbers.slice(0); varcopyendmiddlenumbersstartnumbers=123456789start=numbersslice03middle=numbersslice3-2end=numbersslice-2copy=numbersslice0             \t middle                \t middle      \t middle \t \t The same syntax can be used with assignment to replace a segment of an array with new values, splicing it.               numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]                 var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;                           \t numbers                       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]                 var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;               numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]       numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6]     numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6] numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[3..6] = [-3, -4, -5, -6] numbers=[0,1,2,3,4,5,6,7,8,9]numbers[3..6]=[-3,-4,-5,-6]       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;       var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;     var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref; var numbers, ref,   splice = [].splice; numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref; varnumbersrefsplice=splicenumbers=0123456789spliceapplynumbers34concatref=-3-4-5-6ref             \t numbers                \t numbers      \t numbers \t \t Note that JavaScript strings are immutable, and can’t be spliced.","dataLevel":1,"level":2,"parent":"language"},{"section":"expressions","title":"Everything is an Expression (at least, as much as possible)","content":"Everything is an Expression (at least, as much as possible)You might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the return gets pushed down into each possible branch of execution in the function below.return               grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"                 var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";                           \t eldest                       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"                 var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";               grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"       grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\"     grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\" grade = (student) ->   if student.excellentWork     \"A+\"   else if student.okayStuff     if student.triedHard then \"B\" else \"B-\"   else     \"C\" eldest = if 24 > 21 then \"Liz\" else \"Ike\" grade=(student)->ifstudent.excellentWork\"A+\"  elseifstudent.okayStuff    ifstudent.triedHardthen\"B\"else\"B-\"  else\"C\"eldest=if24>21then\"Liz\"else\"Ike\"       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";       var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\";     var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\"; var eldest, grade; grade = function(student) {   if (student.excellentWork) {     return \"A+\";   } else if (student.okayStuff) {     if (student.triedHard) {       return \"B\";     } else {       return \"B-\";     }   } else {     return \"C\";   } }; eldest = 24 > 21 ? \"Liz\" : \"Ike\"; vareldestgradegrade=functionstudentifstudentexcellentWorkreturn\"A+\"elseifstudentokayStuffifstudenttriedHardreturn\"B\"elsereturn\"B-\"elsereturn\"C\"eldest=24>21?\"Liz\"\"Ike\"             \t eldest                \t eldest      \t eldest \t \t Even though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (return value), when you know that you’re done.return valueBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:               six = (one = 1) + (two = 2) + (three = 3)       six = (one = 1) + (two = 2) + (three = 3)                 var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);                           \t six                       six = (one = 1) + (two = 2) + (three = 3)       six = (one = 1) + (two = 2) + (three = 3)                 var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);               six = (one = 1) + (two = 2) + (three = 3)       six = (one = 1) + (two = 2) + (three = 3)     six = (one = 1) + (two = 2) + (three = 3) six = (one = 1) + (two = 2) + (three = 3) six=(one=1)+(two=2)+(three=3)       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);       var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3);     var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3); var one, six, three, two; six = (one = 1) + (two = 2) + (three = 3); varonesixthreetwosix=one=1+two=2+three=3             \t six                \t six      \t six \t \t Things that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:               # The first ten global properties. globals = (name for name of window)[0...10]       # The first ten global properties. globals = (name for name of window)[0...10]                 // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);                           \t globals                       # The first ten global properties. globals = (name for name of window)[0...10]       # The first ten global properties. globals = (name for name of window)[0...10]                 // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);               # The first ten global properties. globals = (name for name of window)[0...10]       # The first ten global properties. globals = (name for name of window)[0...10]     # The first ten global properties. globals = (name for name of window)[0...10] # The first ten global properties. globals = (name for name of window)[0...10] # The first ten global properties.globals=(namefornameofwindow)[0...10]       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);       // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10);     // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10); // The first ten global properties. var globals, name; globals = ((function() {   var results;   results = [];   for (name in window) {     results.push(name);   }   return results; })()).slice(0, 10); // The first ten global properties.varglobalsnameglobals=functionvarresultsresults=fornameinwindowresultspushnamereturnresultsslice010             \t globals                \t globals      \t globals \t \t As well as silly things, like passing a try/catch statement directly into a function call:trycatch               alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )                 var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());                           \t                       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )                 var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());               alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )       alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" )     alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" ) alert(   try     nonexistent / undefined   catch error     \"And the error is ... #{error}\" ) alert(try    nonexistent/undefined  catcherror\"And the error is ... #{error}\")       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());       var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })());     var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })()); var error; alert((function() {   try {     return nonexistent / void 0;   } catch (error1) {     error = error1;     return `And the error is ... ${error}`;   } })()); varerroralertfunctiontryreturnnonexistent/void0catcherror1error=error1return`And the error is ... ${error}`             \t                \t      \t \t \t There are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely break, continue, and return. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.breakcontinuereturn","dataLevel":1,"level":2,"parent":"language"},{"section":"operators","title":"Operators and Aliases","content":"Because the == operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles == into ===, and != into !==. In addition, is compiles into ===, and isnt into !==.=======!=!==is===isnt!==You can use not as an alias for !.not!For logic, and compiles to &&, and or into ||.and&&or||Instead of a newline or semicolon, then can be used to separate conditions from expressions, in while, if/else, and switch/when statements.thenwhileifelseswitchwhenAs in YAML, on and yes are the same as boolean true, while off and no are boolean false.YAMLonyestrueoffnofalseunless can be used as the inverse of if.unlessifAs a shortcut for this.property, you can use @property.this.property@propertyYou can use in to test for array presence, and of to test for JavaScript object-key presence.inofIn a for loop, from compiles to the ES2015 of. (Yes, it’s unfortunate; the CoffeeScript of predates the ES2015 of.)forfromES2015 ofofofofTo simplify math expressions, ** can be used for exponentiation and // performs floor division. % works just like in JavaScript, while %% provides “dividend dependent modulo”:**//%%%“dividend dependent modulo”               -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)                 var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));                       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)                 var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));               -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)       -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)     -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length) -7 % 5 == -2 # The remainder of 7 / 5 -7 %% 5 == 3 # n %% 5 is always between 0 and 4 tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length) -7%5==-2# The remainder of 7 / 5-7%%5==3# n %% 5 is always between 0 and 4tabs.selectTabAtIndex((tabs.currentIndex-count)%%tabs.length)       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));       var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));     var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length)); var modulo = function(a, b) { return (+a % (b = +b) + b) % b; }; -7 % 5 === -2; // The remainder of 7 / 5 modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4 tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length)); varmodulo=functionabreturn+a%b=+b+b%b-7%5===-2// The remainder of 7 / 5modulo-75===3// n %% 5 is always between 0 and 4tabsselectTabAtIndexmodulotabscurrentIndex-counttabslengthAll together now: CoffeeScript JavaScript is === isnt !== not ! and && or || true, yes, on true false, no, off  false @, this this a in b [].indexOf.call(b, a) >= 0 a of b a in b for a from b for (a of b) a ** b a ** b a // b Math.floor(a / b) a %% b (a % b + b) % b CoffeeScript JavaScript CoffeeScript JavaScript CoffeeScriptJavaScript is === isnt !== not ! and && or || true, yes, on true false, no, off  false @, this this a in b [].indexOf.call(b, a) >= 0 a of b a in b for a from b for (a of b) a ** b a ** b a // b Math.floor(a / b) a %% b (a % b + b) % b is === isis====== isnt !== isntisnt!==!== not ! notnot!! and && andand&&&& or || oror|||| true, yes, on true true, yes, ontrueyesontruetrue false, no, off  false false, no, off falsenoofffalsefalse @, this this @, this@thisthisthis a in b [].indexOf.call(b, a) >= 0 a in ba in b[].indexOf.call(b, a) >= 0[].indexOf.call(b, a) >= 0 a of b a in b a of ba of ba in ba in b for a from b for (a of b) for a from bfor a from bfor (a of b)for (a of b) a ** b a ** b a ** ba ** ba ** ba ** b a // b Math.floor(a / b) a // ba // bMath.floor(a / b)Math.floor(a / b) a %% b (a % b + b) % b a %% ba %% b(a % b + b) % b(a % b + b) % b               launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"                 var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));                       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"                 var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));               launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"       launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\"     launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\" launch() if ignition is on volume = 10 if band isnt SpinalTap letTheWildRumpusBegin() unless answer is no if car.speed < limit then accelerate() winner = yes if pick in [47, 92, 13] print inspect \"My name is #{@name}\" launch()ifignitionisonvolume=10ifbandisntSpinalTapletTheWildRumpusBegin()unlessanswerisnoifcar.speed<limitthenaccelerate()winner=yesifpickin[47,92,13]printinspect\"My name is #{@name}\"       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));       var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`));     var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`)); var volume, winner; if (ignition === true) {   launch(); } if (band !== SpinalTap) {   volume = 10; } if (answer !== false) {   letTheWildRumpusBegin(); } if (car.speed < limit) {   accelerate(); } if (pick === 47 || pick === 92 || pick === 13) {   winner = true; } print(inspect(`My name is ${this.name}`)); varvolumewinnerifignition===truelaunchifband!==SpinalTapvolume=10ifanswer!==falseletTheWildRumpusBeginifcarspeed<limitaccelerateifpick===47||pick===92||pick===13winner=trueprintinspect`My name is ${thisname}`","dataLevel":1,"level":2,"parent":"language"},{"section":"existential-operator","title":"The Existential Operator","content":"It’s a little difficult to check for the existence of a variable in JavaScript. if (variable) … comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator ? returns true unless a variable is null or undefined or undeclared, which makes it analogous to Ruby’s nil?.if (variable) …?nullundefinednil?It can also be used for safer conditional assignment than the JavaScript pattern a = a || value provides, for cases where you may be handling numbers or strings.a = a || value               solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"                 var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";                           \t footprints                       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"                 var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";               solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"       solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\"     solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\" solipsism = true if mind? and not world? speed = 0 speed ?= 15 footprints = yeti ? \"bear\" solipsism=trueifmind?andnotworld?speed=0speed?=15footprints=yeti?\"bear\"       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";       var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";     var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\"; var footprints, solipsism, speed; if ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {   solipsism = true; } speed = 0; if (speed == null) {   speed = 15; } footprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\"; varfootprintssolipsismspeediftypeofmind!==\"undefined\"&&mind!==null&&typeofworld===\"undefined\"||world===nullsolipsism=truespeed=0ifspeed==nullspeed=15footprints=typeofyeti!==\"undefined\"&&yeti!==null?yeti\"bear\"             \t footprints                \t footprints      \t footprints \t \t Note that if the compiler knows that a is in scope and therefore declared, a? compiles to a != null, not a !== null. The != makes a loose comparison to null, which does double duty also comparing against undefined. The reverse also holds for not a? or unless a?.aa?a != nullnota !== null!=nullundefinednot a?unless a?               major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'                 var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }                       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'                 var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }               major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'       major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines'     major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines' major = 'Computer Science' unless major?   signUpForClass 'Introduction to Wines' major='Computer Science'unlessmajor?signUpForClass'Introduction to Wines'       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }       var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); }     var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); } var major; major = 'Computer Science'; if (major == null) {   signUpForClass('Introduction to Wines'); } varmajormajor='Computer Science'ifmajor==nullsignUpForClass'Introduction to Wines'If a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders should be typing when they want to check if a mystery variable exists.should               if window?   environment = 'browser (probably)'       if window?   environment = 'browser (probably)'                 var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }                       if window?   environment = 'browser (probably)'       if window?   environment = 'browser (probably)'                 var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }               if window?   environment = 'browser (probably)'       if window?   environment = 'browser (probably)'     if window?   environment = 'browser (probably)' if window?   environment = 'browser (probably)' ifwindow?environment='browser (probably)'       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }       var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; }     var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; } var environment; if (typeof window !== \"undefined\" && window !== null) {   environment = 'browser (probably)'; } varenvironmentiftypeofwindow!==\"undefined\"&&window!==nullenvironment='browser (probably)'The accessor variant of the existential operator ?. can be used to soak up null references in a chain of properties. Use it instead of the dot accessor . in cases where the base value may be null or undefined. If all of the properties exist then you’ll get the expected result, if the chain is broken, undefined is returned instead of the TypeError that would be raised otherwise.?..nullundefinedundefinedTypeError               zip = lottery.drawWinner?().address?.zipcode       zip = lottery.drawWinner?().address?.zipcode                 var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;                       zip = lottery.drawWinner?().address?.zipcode       zip = lottery.drawWinner?().address?.zipcode                 var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;               zip = lottery.drawWinner?().address?.zipcode       zip = lottery.drawWinner?().address?.zipcode     zip = lottery.drawWinner?().address?.zipcode zip = lottery.drawWinner?().address?.zipcode zip=lottery.drawWinner?().address?.zipcode       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;       var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;     var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0; var ref, zip; zip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0; varrefzipzip=typeoflotterydrawWinner===\"function\"?ref=lotterydrawWinneraddress!=null?refzipcodevoid0void0For completeness: Example Definition a? tests that a is in scope and a != null a ? b returns a if a is in scope and a != null; otherwise, b a?.b or a?['b'] returns a.b if a is in scope and a != null; otherwise, undefined a?(b, c) or a? b, c  returns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefined a ?= b assigns the value of b to a if a is not in scope or if a == null; produces the new value of a Example Definition Example Definition ExampleDefinition a? tests that a is in scope and a != null a ? b returns a if a is in scope and a != null; otherwise, b a?.b or a?['b'] returns a.b if a is in scope and a != null; otherwise, undefined a?(b, c) or a? b, c  returns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefined a ?= b assigns the value of b to a if a is not in scope or if a == null; produces the new value of a a? tests that a is in scope and a != null a?a?tests that a is in scope and a != nullaa != null a ? b returns a if a is in scope and a != null; otherwise, b a ? ba ? breturns a if a is in scope and a != null; otherwise, baaa != nullb a?.b or a?['b'] returns a.b if a is in scope and a != null; otherwise, undefined a?.b or a?['b']a?.ba?['b']returns a.b if a is in scope and a != null; otherwise, undefineda.baa != nullundefined a?(b, c) or a? b, c  returns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefined a?(b, c) or a? b, c a?(b, c)a? b, creturns the result of calling a (with arguments b and c) if a is in scope and callable; otherwise, undefinedabcaundefined a ?= b assigns the value of b to a if a is not in scope or if a == null; produces the new value of a a ?= ba ?= bassigns the value of b to a if a is not in scope or if a == null; produces the new value of abaaa == nulla","dataLevel":1,"level":2,"parent":"language"},{"section":"chaining","title":"Chaining Function Calls","content":"Leading . closes all open calls, allowing for simpler chaining syntax..               $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'                 $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');                       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'                 $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');               $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'       $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white'     $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white' $ 'body' .click (e) ->   $ '.box'   .fadeIn 'fast'   .addClass 'show' .css 'background', 'white' $'body'.click(e)->$'.box'.fadeIn'fast'.addClass'show'.css'background','white'       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');       $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white');     $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white'); $('body').click(function(e) {   return $('.box').fadeIn('fast').addClass('show'); }).css('background', 'white'); $'body'clickfunctionereturn$'.box'fadeIn'fast'addClass'show'css'background''white'","dataLevel":1,"level":2,"parent":"language"},{"section":"destructuring","title":"Destructuring Assignment","content":"Just like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:               theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]                 var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];                           \t theBait                       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]                 var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];               theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]       theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait]     theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait] theBait   = 1000 theSwitch = 0 [theBait, theSwitch] = [theSwitch, theBait] theBait=1000theSwitch=0[theBait,theSwitch]=[theSwitch,theBait]       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];       var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait];     var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait]; var theBait, theSwitch; theBait = 1000; theSwitch = 0; [theBait, theSwitch] = [theSwitch, theBait]; vartheBaittheSwitchtheBait=1000theSwitch=0theBaittheSwitch=theSwitchtheBait             \t theBait                \t theBait      \t theBait \t \t But it’s also helpful for dealing with functions that return multiple values.               weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"                 var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");                           \t forecast                       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"                 var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");               weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"       weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\"     weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\" weatherReport = (location) ->   # Make an Ajax request to fetch the weather...   [location, 72, \"Mostly Sunny\"] [city, temp, forecast] = weatherReport \"Berkeley, CA\" weatherReport=(location)-># Make an Ajax request to fetch the weather...[location,72,\"Mostly Sunny\"][city,temp,forecast]=weatherReport\"Berkeley, CA\"       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");       var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\");     var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\"); var city, forecast, temp, weatherReport; weatherReport = function(location) {   // Make an Ajax request to fetch the weather...   return [location, 72, \"Mostly Sunny\"]; }; [city, temp, forecast] = weatherReport(\"Berkeley, CA\"); varcityforecasttempweatherReportweatherReport=functionlocation// Make an Ajax request to fetch the weather...returnlocation72\"Mostly Sunny\"citytempforecast=weatherReport\"Berkeley, CA\"             \t forecast                \t forecast      \t forecast \t \t Destructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.               futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists                 var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);                           \t name + \"-\" + street                       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists                 var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);               futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists       futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists     futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists futurists =   sculptor: \"Umberto Boccioni\"   painter:  \"Vladimir Burliuk\"   poet:     name:   \"F.T. Marinetti\"     address: [       \"Via Roma 42R\"       \"Bellagio, Italy 22021\"     ] {sculptor} = futurists {poet: {name, address: [street, city]}} = futurists futurists=  sculptor:\"Umberto Boccioni\"painter:\"Vladimir Burliuk\"poet:    name:\"F.T. Marinetti\"address:[\"Via Roma 42R\"\"Bellagio, Italy 22021\"    ]{sculptor}=futurists{poet:{name,address:[street,city]}}=futurists       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);       var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists);     var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists); var city, futurists, name, sculptor, street; futurists = {   sculptor: \"Umberto Boccioni\",   painter: \"Vladimir Burliuk\",   poet: {     name: \"F.T. Marinetti\",     address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]   } }; ({sculptor} = futurists); ({   poet: {     name,     address: [street, city]   } } = futurists); varcityfuturistsnamesculptorstreetfuturists=sculptor\"Umberto Boccioni\"painter\"Vladimir Burliuk\"poetname\"F.T. Marinetti\"address\"Via Roma 42R\"\"Bellagio, Italy 22021\"sculptor=futuristspoetnameaddressstreetcity=futurists             \t name + \"-\" + street                \t name + \"-\" + street      \t name + \"-\" + street \t \t Destructuring assignment can even be combined with splats.               tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")                 var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);                           \t contents.join(\"\")                       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")                 var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);               tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")       tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\")     tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\") tag = \"<impossible>\" [open, contents..., close] = tag.split(\"\") tag=\"<impossible>\"[open,contents...,close]=tag.split(\"\")       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);       var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);     var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1); var close, contents, open, ref, tag,   splice = [].splice; tag = \"<impossible>\"; ref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1); varclosecontentsopenreftagsplice=splicetag=\"<impossible>\"ref=tagsplit\"\"open...contents=refclose=splicecallcontents-1             \t contents.join(\"\")                \t contents.join(\"\")      \t contents.join(\"\") \t \t Expansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.               text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"                 var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);                           \t first + \" \" + last                       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"                 var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);               text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"       text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \"     text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \" text = \"Every literary critic believes he will         outwit history and have the last word\" [first, ..., last] = text.split \" \" text=\"Every literary critic believes he will        outwit history and have the last word\"[first,...,last]=text.split\" \"       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);       var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);     var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1); var first, last, ref, text,   slice = [].slice; text = \"Every literary critic believes he will outwit history and have the last word\"; ref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1); varfirstlastreftextslice=slicetext=\"Every literary critic believes he will outwit history and have the last word\"ref=textsplit\" \"first=reflast=slicecallref-1             \t first + \" \" + last                \t first + \" \" + last      \t first + \" \" + last \t \t Destructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.               class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4                 var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });                           \t tim.age + \" \" + tim.height                       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4                 var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });               class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4       class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4     class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4 class Person   constructor: (options) ->     {@name, @age, @height = 'average'} = options tim = new Person name: 'Tim', age: 4 classPersonconstructor:(options)->{@name,@age,@height='average'}=optionstim=newPersonname:'Tim',age:4       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });       var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 });     var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 }); var Person, tim; Person = class Person {   constructor(options) {     ({name: this.name, age: this.age, height: this.height = 'average'} = options);   } }; tim = new Person({   name: 'Tim',   age: 4 }); varPersontimPerson=classPersonconstructoroptionsnamethisnameagethisageheightthisheight='average'=optionstim=newPersonname'Tim'age4             \t tim.age + \" \" + tim.height                \t tim.age + \" \" + tim.height      \t tim.age + \" \" + tim.height \t \t The above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or undefined—passing null will set a value of null, not the default.undefinedpassing null will set a value of nullnullnull","dataLevel":1,"level":2,"parent":"language"},{"section":"fat-arrow","title":"Bound (Fat Arrow) Functions","content":"Bound (Fat Arrow) FunctionsIn JavaScript, the this keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of this will be lost. If you’re not familiar with this behavior, this Digital Web article gives a good overview of the quirks.thisthisthis Digital Web articleThe fat arrow => can be used to both define a function, and to bind it to the current value of this, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to each, or event-handler functions to use with on. Functions created with the fat arrow are able to access properties of the this where they’re defined.=>thiseachonthis               Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart                 var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };                       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart                 var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };               Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart       Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart     Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart Account = (customer, cart) ->   @customer = customer   @cart = cart   $('.shopping_cart').on 'click', (event) =>     @customer.purchase @cart Account=(customer,cart)->@customer=customer@cart=cart$('.shopping_cart').on'click',(event)=>@customer.purchase@cart       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };       var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); };     var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); }; var Account; Account = function(customer, cart) {   this.customer = customer;   this.cart = cart;   return $('.shopping_cart').on('click', (event) => {     return this.customer.purchase(this.cart);   }); }; varAccountAccount=functioncustomercartthiscustomer=customerthiscart=cartreturn$'.shopping_cart'on'click'event=>returnthiscustomerpurchasethiscartIf we had used -> in the callback above, @customer would have referred to the undefined “customer” property of the DOM element, and trying to call purchase() on it would have raised an exception.->@customerpurchase()The fat arrow was one of the most popular features of CoffeeScript, and ES2015 adopted it; so CoffeeScript 2 compiles => to ES =>.adopted it=>=>","dataLevel":1,"level":2,"parent":"language"},{"section":"generators","title":"Generator Functions","content":"CoffeeScript supports ES2015 generator functions through the yield keyword. There’s no function*(){} nonsense — a generator in CoffeeScript is simply a function that yields.generator functionsyieldfunction*(){}               perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()                 var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());                           \t ps.next().value                       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()                 var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());               perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()       perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares()     perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares() perfectSquares = ->   num = 0   loop     num += 1     yield num * num   return window.ps or= perfectSquares() perfectSquares=->num=0loopnum+=1yieldnum*num  returnwindow.psor=perfectSquares()       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());       var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares());     var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares()); var perfectSquares; perfectSquares = function*() {   var num;   num = 0;   while (true) {     num += 1;     yield num * num;   } }; window.ps || (window.ps = perfectSquares()); varperfectSquaresperfectSquares=function*varnumnum=0whiletruenum+=1yieldnum*numwindowps||windowps=perfectSquares             \t ps.next().value                \t ps.next().value      \t ps.next().value \t \t yield* is called yield from, and yield return may be used if you need to force a generator that doesn’t yield.yield*yield fromyield returnYou can iterate over a generator function using for…from.for…from               fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results                 var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };                           \t getFibonacciNumbers(10)                       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results                 var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };               fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results       fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results     fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results fibonacci = ->   [previous, current] = [1, 1]   loop     [previous, current] = [current, previous + current]     yield current   return getFibonacciNumbers = (length) ->   results = [1]   for n from fibonacci()     results.push n     break if results.length is length   results fibonacci=->[previous,current]=[1,1]loop[previous,current]=[current,previous+current]yieldcurrent  returngetFibonacciNumbers=(length)->results=[1]fornfromfibonacci()results.pushnbreakifresults.lengthislength  results       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };       var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; };     var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; }; var fibonacci, getFibonacciNumbers; fibonacci = function*() {   var current, previous;   [previous, current] = [1, 1];   while (true) {     [previous, current] = [current, previous + current];     yield current;   } }; getFibonacciNumbers = function(length) {   var n, ref, results;   results = [1];   ref = fibonacci();   for (n of ref) {     results.push(n);     if (results.length === length) {       break;     }   }   return results; }; varfibonaccigetFibonacciNumbersfibonacci=function*varcurrentpreviouspreviouscurrent=11whiletruepreviouscurrent=currentprevious+currentyieldcurrentgetFibonacciNumbers=functionlengthvarnrefresultsresults=1ref=fibonaccifornofrefresultspushnifresultslength===lengthbreakreturnresults             \t getFibonacciNumbers(10)                \t getFibonacciNumbers(10)      \t getFibonacciNumbers(10) \t \t ","dataLevel":1,"level":2,"parent":"language"},{"section":"async-functions","title":"Async Functions","content":"ES2017’s async functions are supported through the await keyword. Like with generators, there’s no need for an async keyword; an async function in CoffeeScript is simply a function that awaits.async functionsawaitasyncSimilar to how yield return forces a generator, await return may be used to force a function to be async.yield returnawait return               # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3                 // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);                           \t                       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3                 // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);               # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3       # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3     # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3 # Your browser must support async/await and speech synthesis # to run this example. sleep = (ms) ->   new Promise (resolve) ->     window.setTimeout resolve, ms say = (text) ->   window.speechSynthesis.cancel()   window.speechSynthesis.speak new SpeechSynthesisUtterance text countdown = (seconds) ->   for i in [seconds..1]     say i     await sleep 1000 # wait one second   say \"Blastoff!\" countdown 3 # Your browser must support async/await and speech synthesis# to run this example.sleep=(ms)->newPromise(resolve)->window.setTimeoutresolve,mssay=(text)->window.speechSynthesis.cancel()window.speechSynthesis.speaknewSpeechSynthesisUtterancetextcountdown=(seconds)->foriin[seconds..1]sayiawaitsleep1000# wait one second  say\"Blastoff!\"countdown3       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);       // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3);     // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3); // Your browser must support async/await and speech synthesis // to run this example. var countdown, say, sleep; sleep = function(ms) {   return new Promise(function(resolve) {     return window.setTimeout(resolve, ms);   }); }; say = function(text) {   window.speechSynthesis.cancel();   return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }; countdown = async function(seconds) {   var i, j, ref;   for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {     say(i);     await sleep(1000); // wait one second   }   return say(\"Blastoff!\"); }; countdown(3); // Your browser must support async/await and speech synthesis// to run this example.varcountdownsaysleepsleep=functionmsreturnnewPromisefunctionresolvereturnwindowsetTimeoutresolvemssay=functiontextwindowspeechSynthesiscancelreturnwindowspeechSynthesisspeaknewSpeechSynthesisUtterancetextcountdown=asyncfunctionsecondsvarijreffori=j=ref=secondsref<=1?j<=1j>=1i=ref<=1?++j--jsayiawaitsleep1000// wait one secondreturnsay\"Blastoff!\"countdown3             \t                \t      \t \t \t ","dataLevel":1,"level":2,"parent":"language"},{"section":"classes","title":"Classes","content":"CoffeeScript 1 provided the class and extends keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its class and extends keywords to ES2015 classes.classextendsclassextends               class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()                 var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();                           \t                       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()                 var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();               class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()       class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move()     class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move() class Animal   constructor: (@name) ->   move: (meters) ->     alert @name + \" moved #{meters}m.\" class Snake extends Animal   move: ->     alert \"Slithering...\"     super 5 class Horse extends Animal   move: ->     alert \"Galloping...\"     super 45 sam = new Snake \"Sammy the Python\" tom = new Horse \"Tommy the Palomino\" sam.move() tom.move() classAnimalconstructor:(@name)->  move:(meters)->alert@name+\" moved #{meters}m.\"classSnakeextendsAnimalmove:->alert\"Slithering...\"super5classHorseextendsAnimalmove:->alert\"Galloping...\"super45sam=newSnake\"Sammy the Python\"tom=newHorse\"Tommy the Palomino\"sam.move()tom.move()       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();       var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move();     var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move(); var Animal, Horse, Snake, sam, tom; Animal = class Animal {   constructor(name) {     this.name = name;   }   move(meters) {     return alert(this.name + ` moved ${meters}m.`);   } }; Snake = class Snake extends Animal {   move() {     alert(\"Slithering...\");     return super.move(5);   } }; Horse = class Horse extends Animal {   move() {     alert(\"Galloping...\");     return super.move(45);   } }; sam = new Snake(\"Sammy the Python\"); tom = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move(); varAnimalHorseSnakesamtomAnimal=classAnimalconstructornamethisname=namemovemetersreturnalertthisname+` moved ${meters}m.`Snake=classSnakeextendsAnimalmovealert\"Slithering...\"returnsupermove5Horse=classHorseextendsAnimalmovealert\"Galloping...\"returnsupermove45sam=newSnake\"Sammy the Python\"tom=newHorse\"Tommy the Palomino\"sammovetommove             \t                \t      \t \t \t Static methods can be defined using @ before the method name:@               class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '                 var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };                           \t Teenager.say(\"Are we there yet?\")                       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '                 var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };               class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '       class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', '     class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', ' class Teenager   @say: (speech) ->     words = speech.split ' '     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']     output = []     for word, index in words       output.push word       output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1     output.join ', ' classTeenager@say:(speech)->words=speech.split' 'fillers=['uh','um','like','actually','so','maybe']output=[]forword,indexinwordsoutput.pushwordoutput.pushfillers[Math.floor(Math.random()*fillers.length)]unlessindexiswords.length-1    output.join', '       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };       var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } };     var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } }; var Teenager; Teenager = class Teenager {   static say(speech) {     var fillers, i, index, len, output, word, words;     words = speech.split(' ');     fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];     output = [];     for (index = i = 0, len = words.length; i < len; index = ++i) {       word = words[index];       output.push(word);       if (index !== words.length - 1) {         output.push(fillers[Math.floor(Math.random() * fillers.length)]);       }     }     return output.join(', ');   } }; varTeenagerTeenager=classTeenagerstaticsayspeechvarfillersiindexlenoutputwordwordswords=speechsplit' 'fillers='uh''um''like''actually''so''maybe'output=forindex=i=0len=wordslengthi<lenindex=++iword=wordsindexoutputpushwordifindex!==wordslength-1outputpushfillersMathfloorMathrandom*fillerslengthreturnoutputjoin', '             \t Teenager.say(\"Are we there yet?\")                \t Teenager.say(\"Are we there yet?\")      \t Teenager.say(\"Are we there yet?\") \t \t Finally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, this is the class object itself; therefore, you can assign static properties by using @property: value.this@property: value","dataLevel":1,"level":2,"parent":"language"},{"section":"prototypal-inheritance","title":"Prototypal Inheritance","content":"In addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The :: operator gives you quick access to an object’s prototype:::               String::dasherize = ->   this.replace /_/g, \"-\"       String::dasherize = ->   this.replace /_/g, \"-\"                 String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };                           \t \"one_two\".dasherize()                       String::dasherize = ->   this.replace /_/g, \"-\"       String::dasherize = ->   this.replace /_/g, \"-\"                 String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };               String::dasherize = ->   this.replace /_/g, \"-\"       String::dasherize = ->   this.replace /_/g, \"-\"     String::dasherize = ->   this.replace /_/g, \"-\" String::dasherize = ->   this.replace /_/g, \"-\" String::dasherize=->this.replace/_/g,\"-\"       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };       String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); };     String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); }; String.prototype.dasherize = function() {   return this.replace(/_/g, \"-\"); }; Stringprototypedasherize=functionreturnthisreplace/_/g\"-\"             \t \"one_two\".dasherize()                \t \"one_two\".dasherize()      \t \"one_two\".dasherize() \t \t ","dataLevel":1,"level":2,"parent":"language"},{"section":"switch","title":"Switch/When/Else","content":"switch statements in JavaScript are a bit awkward. You need to remember to break at the end of every case statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the switch into a returnable, assignable expression. The format is: switch condition, when clauses, else the default case.switchbreakcaseswitchswitchwhenelseAs in Ruby, switch statements in CoffeeScript can take multiple values for each when clause. If any of the values match, the clause runs.switchwhen               switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work                 switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }                       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work                 switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }               switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work       switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work     switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work switch day   when \"Mon\" then go work   when \"Tue\" then go relax   when \"Thu\" then go iceFishing   when \"Fri\", \"Sat\"     if day is bingoDay       go bingo       go dancing   when \"Sun\" then go church   else go work switchdaywhen\"Mon\"thengoworkwhen\"Tue\"thengorelaxwhen\"Thu\"thengoiceFishingwhen\"Fri\",\"Sat\"    ifdayisbingoDaygobingogodancing  when\"Sun\"thengochurchelsegowork       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }       switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); }     switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); } switch (day) {   case \"Mon\":     go(work);     break;   case \"Tue\":     go(relax);     break;   case \"Thu\":     go(iceFishing);     break;   case \"Fri\":   case \"Sat\":     if (day === bingoDay) {       go(bingo);       go(dancing);     }     break;   case \"Sun\":     go(church);     break;   default:     go(work); } switchdaycase\"Mon\"goworkbreakcase\"Tue\"gorelaxbreakcase\"Thu\"goiceFishingbreakcase\"Fri\"case\"Sat\"ifday===bingoDaygobingogodancingbreakcase\"Sun\"gochurchbreakdefaultgoworkswitch statements can also be used without a control expression, turning them in to a cleaner alternative to if/else chains.switchifelse               score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'                 var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'                       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'                 var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'               score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'       score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C'     score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C' score = 76 grade = switch   when score < 60 then 'F'   when score < 70 then 'D'   when score < 80 then 'C'   when score < 90 then 'B'   else 'A' # grade == 'C' score=76grade=switchwhenscore<60then'F'whenscore<70then'D'whenscore<80then'C'whenscore<90then'B'else'A'# grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'       var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C'     var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C' var grade, score; score = 76; grade = (function() {   switch (false) {     case !(score < 60):       return 'F';     case !(score < 70):       return 'D';     case !(score < 80):       return 'C';     case !(score < 90):       return 'B';     default:       return 'A';   } })(); // grade == 'C' vargradescorescore=76grade=functionswitchfalsecase!score<60return'F'case!score<70return'D'case!score<80return'C'case!score<90return'B'defaultreturn'A'// grade == 'C'","dataLevel":1,"level":2,"parent":"language"},{"section":"try","title":"Try/Catch/Finally","content":"try expressions have the same semantics as try statements in JavaScript, though in CoffeeScript, you may omit both the catch and finally parts. The catch part may also omit the error parameter if it is not needed.trytryboth               try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()                 var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }                       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()                 var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }               try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()       try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp()     try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp() try   allHellBreaksLoose()   catsAndDogsLivingTogether() catch error   print error finally   cleanUp() tryallHellBreaksLoose()catsAndDogsLivingTogether()catcherrorprinterrorfinallycleanUp()       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }       var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); }     var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); } var error; try {   allHellBreaksLoose();   catsAndDogsLivingTogether(); } catch (error1) {   error = error1;   print(error); } finally {   cleanUp(); } varerrortryallHellBreaksLoosecatsAndDogsLivingTogethercatcherror1error=error1printerrorfinallycleanUp","dataLevel":1,"level":2,"parent":"language"},{"section":"comparisons","title":"Chained Comparisons","content":"CoffeeScript borrows chained comparisons from Python — making it easy to test if a value falls within a certain range.chained comparisons               cholesterol = 127 healthy = 200 > cholesterol > 60       cholesterol = 127 healthy = 200 > cholesterol > 60                 var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);                           \t healthy                       cholesterol = 127 healthy = 200 > cholesterol > 60       cholesterol = 127 healthy = 200 > cholesterol > 60                 var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);               cholesterol = 127 healthy = 200 > cholesterol > 60       cholesterol = 127 healthy = 200 > cholesterol > 60     cholesterol = 127 healthy = 200 > cholesterol > 60 cholesterol = 127 healthy = 200 > cholesterol > 60 cholesterol=127healthy=200>cholesterol>60       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);       var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60);     var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60); var cholesterol, healthy; cholesterol = 127; healthy = (200 > cholesterol && cholesterol > 60); varcholesterolhealthycholesterol=127healthy=200>cholesterol&&cholesterol>60             \t healthy                \t healthy      \t healthy \t \t ","dataLevel":1,"level":2,"parent":"language"},{"section":"regexes","title":"Block Regular Expressions","content":"Similar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s /x modifier, CoffeeScript’s block regexes are delimited by /// and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:/x///               NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i                 var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal                       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i                 var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal               NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i       NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i     NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i NUMBER     = ///   ^ 0b[01]+    |              # binary   ^ 0o[0-7]+   |              # octal   ^ 0x[\\da-f]+ |              # hex   ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal ///i NUMBER=///  ^0b[01]+|# binary^0o[0-7]+|# octal^0x[\\da-f]+|# hex^\\d*\\.?\\d+(?:e[+-]?\\d+)?# decimal///i       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal       var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal     var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal var NUMBER; NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary // octal // hex // decimal varNUMBERNUMBER=/^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i// binary// octal// hex// decimal","dataLevel":1,"level":2,"parent":"language"},{"section":"tagged-template-literals","title":"Tagged Template Literals","content":"CoffeeScript supports ES2015 tagged template literals, which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will behave accordingly: the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.ES2015 tagged template literalsbehave accordingly               upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"                 var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };                           \t greet(\"greg\", \"awesome\")                       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"                 var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };               upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"       upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\"     upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\" upperCaseExpr = (textParts, expressions...) ->   textParts.reduce (text, textPart, i) ->     text + expressions[i - 1].toUpperCase() + textPart greet = (name, adjective) ->   upperCaseExpr\"\"\"                Hi #{name}. You look #{adjective}!                \"\"\" upperCaseExpr=(textParts,expressions...)->textParts.reduce(text,textPart,i)->text+expressions[i-1].toUpperCase()+textPartgreet=(name,adjective)->upperCaseExpr\"\"\"               Hi #{name}. You look #{adjective}!               \"\"\"       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };       var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; };     var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; }; var greet, upperCaseExpr; upperCaseExpr = function(textParts, ...expressions) {   return textParts.reduce(function(text, textPart, i) {     return text + expressions[i - 1].toUpperCase() + textPart;   }); }; greet = function(name, adjective) {   return upperCaseExpr`Hi ${name}. You look ${adjective}!`; }; vargreetupperCaseExprupperCaseExpr=functiontextParts...expressionsreturntextPartsreducefunctiontexttextPartireturntext+expressionsi-1toUpperCase+textPartgreet=functionnameadjectivereturnupperCaseExpr`Hi ${name}. You look ${adjective}!`             \t greet(\"greg\", \"awesome\")                \t greet(\"greg\", \"awesome\")      \t greet(\"greg\", \"awesome\") \t \t ","dataLevel":1,"level":2,"parent":"language"},{"section":"modules","title":"Modules","content":"ES2015 modules are supported in CoffeeScript, with very similar import and export syntax:importexport               import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'                 import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';                       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'                 import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';               import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'       import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore'     import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore' import 'local-file.coffee' import 'coffeescript' import _ from 'underscore' import * as underscore from 'underscore' import { now } from 'underscore' import { now as currentTimestamp } from 'underscore' import { first, last } from 'underscore' import utilityBelt, { each } from 'underscore' export default Math export square = (x) -> x * x export class Mathematics   least: (x, y) -> if x < y then x else y export { sqrt } export { sqrt as squareRoot } export { Mathematics as default, sqrt as squareRoot } export * from 'underscore' export { max, min } from 'underscore' import'local-file.coffee'import'coffeescript'import_from'underscore'import*asunderscorefrom'underscore'import{now}from'underscore'import{nowascurrentTimestamp}from'underscore'import{first,last}from'underscore'importutilityBelt,{each}from'underscore'exportdefaultMathexportsquare=(x)->x*xexportclassMathematicsleast:(x,y)->ifx<ythenxelseyexport{sqrt}export{sqrtassquareRoot}export{Mathematicsasdefault,sqrtassquareRoot}export*from'underscore'export{max,min}from'underscore'       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';       import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore';     import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore'; import 'local-file.coffee'; import 'coffeescript'; import _ from 'underscore'; import * as underscore from 'underscore'; import {   now } from 'underscore'; import {   now as currentTimestamp } from 'underscore'; import {   first,   last } from 'underscore'; import utilityBelt, {   each } from 'underscore'; export default Math; export var square = function(x) {   return x * x; }; export var Mathematics = class Mathematics {   least(x, y) {     if (x < y) {       return x;     } else {       return y;     }   } }; export {   sqrt }; export {   sqrt as squareRoot }; export {   Mathematics as default,   sqrt as squareRoot }; export * from 'underscore'; export {   max,   min } from 'underscore'; import'local-file.coffee'import'coffeescript'import_from'underscore'import*asunderscorefrom'underscore'importnowfrom'underscore'importnowascurrentTimestampfrom'underscore'importfirstlastfrom'underscore'importutilityBelteachfrom'underscore'exportdefaultMathexportvarsquare=functionxreturnx*xexportvarMathematics=classMathematicsleastxyifx<yreturnxelsereturnyexportsqrtexportsqrtassquareRootexportMathematicsasdefaultsqrtassquareRootexport*from'underscore'exportmaxminfrom'underscore'Note that the CoffeeScript compiler does not resolve modules; writing an import or export statement in CoffeeScript will produce an import or export statement in the resulting output. It is your responsibility to transpile this ES2015 syntax into code that will work in your target runtimes.does not resolve modulesimportexportimportexporttranspileAlso note that any file with an import or export statement will be output without a top-level function safety wrapper; in other words, importing or exporting modules will automatically trigger bare mode for that file. This is because per the ES2015 spec, import or export statements must occur at the topmost scope.importexporttop-level function safety wrapperbareimportexport","dataLevel":1,"level":2,"parent":"language"},{"section":"embedded","title":"Embedded JavaScript","content":"Hopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.               hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`                 var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };                           \t hi()                       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`                 var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };               hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`       hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }`     hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }` hi = `function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }` hi=`function(){return[document.title,\"Hello JavaScript\"].join(\": \");}`       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };       var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); };     var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }; var hi; hi = function() {   return [document.title, \"Hello JavaScript\"].join(\": \"); }; varhihi=functionreturndocumenttitle\"Hello JavaScript\"join\": \"             \t hi()                \t hi()      \t hi() \t \t Escape backticks with backslashes: \\`​ becomes `​.\\`​`​Escape backslashes before backticks with more backslashes: \\\\\\`​ becomes \\`​.\\\\\\`​\\`​               markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`                 var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };                           \t markdown()                       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`                 var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };               markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`       markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }`     markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }` markdown = `function () {   return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`; }` markdown=`function(){return\\`InMarkdown,writecodelike\\\\\\`this\\\\\\`\\`;}`       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };       var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; };     var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; }; var markdown; markdown = function () {   return `In Markdown, write code like \\`this\\``; }; varmarkdownmarkdown=functionreturn`In Markdown, write code like \\`this\\``             \t markdown()                \t markdown()      \t markdown() \t \t You can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.               ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```                 function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;                           \t time()                       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```                 function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;               ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```       ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ```     ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ``` ``` function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ``` ```functiontime(){return`Thetimeis${newDate().toLocaleTimeString()}`;}```       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;       function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ;     function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ; function time() {   return `The time is ${new Date().toLocaleTimeString()}`; } ; functiontimereturn`The time is ${newDatetoLocaleTimeString}`             \t time()                \t time()      \t time() \t \t ","dataLevel":1,"level":2,"parent":"language"},{"section":"jsx","title":"JSX","content":"JSX is JavaScript containing interspersed XML elements. While conceived for React, it is not specific to any particular library or framework.JSXReactCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by Babel with the React JSX transform. CoffeeScript does not output React.createElement calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.Babel with the React JSX transformnotReact.createElementJust like in JSX and HTML, denote XML tags using < and >. You can interpolate CoffeeScript code inside a tag using { and }. To avoid compiler errors, when using < and > to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So i < len, not i<len. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.<>{}<>i < leni<len               renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>                 var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };                       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>                 var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };               renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>       renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside>     renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside> renderStarRating = ({ rating, maxStars }) ->   <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>     {for wholeStar in [0...Math.floor(rating)]       <Star className=\"wholeStar\" key={wholeStar} />}     {if rating % 1 isnt 0       <Star className=\"halfStar\" />}     {for emptyStar in [Math.ceil(rating)...maxStars]       <Star className=\"emptyStar\" key={emptyStar} />}   </aside> renderStarRating=({rating,maxStars})-><asidetitle={\"Rating: #{rating} of #{maxStars} stars\"}>    {forwholeStarin[0...Math.floor(rating)]      <StarclassName=\"wholeStar\"key={wholeStar}/>}{ifrating%1isnt0      <StarclassName=\"halfStar\"/>}{foremptyStarin[Math.ceil(rating)...maxStars]      <StarclassName=\"emptyStar\"key={emptyStar}/>}  </aside>       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };       var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; };     var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; }; var renderStarRating; renderStarRating = function({rating, maxStars}) {   var emptyStar, wholeStar;   return <aside title={`Rating: ${rating} of ${maxStars} stars`}>     {(function() {     var i, ref, results;     results = [];     for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {       results.push(<Star className=\"wholeStar\" key={wholeStar} />);     }     return results;   })()}     {(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}     {(function() {     var i, ref, ref1, results;     results = [];     for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {       results.push(<Star className=\"emptyStar\" key={emptyStar} />);     }     return results;   })()}   </aside>; }; varrenderStarRatingrenderStarRating=functionratingmaxStarsvaremptyStarwholeStarreturn<asidetitle=`Rating: ${ratingof$maxStarsstars`}>{(function() {var i, ref, results;results = [];for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {results.push(<Star className=\"wholeStar\" key={wholeStar} />);}return results;})()}{(rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0)}{(function() {var i, ref, ref1, results;results = [];for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {results.push(<Star className=\"emptyStar\" key={emptyStar} />);}return results;})()}</aside>;};Older plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a .cjsx file extension, but this is no longer necessary; regular .coffee will do..cjsx.coffee","dataLevel":1,"level":2,"parent":"language"},{"section":"type-annotations","title":"Type Annotations","content":"Static type checking can be achieved in CoffeeScript by using Flow’s Comment Types syntax:FlowComment Types syntax               # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num       # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num                 // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; };       // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; };                       # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num       # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num                 // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; };       // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; };               # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num       # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num     # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num # @flow ###:: type Obj = {   num: number, }; ### fn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->   str + obj.num # @flow###::type Obj = {  num: number,};###fn=(str###: string ###,obj###: Obj ###)###: string ###->str+obj.num       // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; };       // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; };     // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; }; // @flow /*:: type Obj = {   num: number, }; */ var fn; fn = function(str/*: string */, obj/*: Obj */)/*: string */ {   return str + obj.num; }; // @flow/*::type Obj = {  num: number,};*/varfnfn=functionstr/*: string */obj/*: Obj *//*: string */returnstr+objnumCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a build tool for this, but here’s how to do it the simplest way possible using the CoffeeScript and Flow command-line tools, assuming you’ve already installed Flow and the latest CoffeeScript in your project folder:build toolCoffeeScriptFlowinstalled Flowlatest CoffeeScriptcoffee --bare --no-header --compile app.coffee && npm run flow coffee --bare --no-header --compile app.coffee && npm run flow coffee --bare --no-header --compile app.coffee && npm run flow --bare and --no-header are important because Flow requires the first line of the file to be the comment // @flow. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.--bare--no-header// @flowIf you know of another way to achieve static type checking with CoffeeScript, please create an issue and let us know.create an issue","dataLevel":1,"level":1,"parent":false},{"section":"literate","title":"Literate CoffeeScript","content":"Besides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a .litcoffee extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line..litcoffeeJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it as a document, raw, and properly highlighted in a text editor.as a documentrawproperly highlighted in a text editorA few caveats: Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces). Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not. List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block. Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.","dataLevel":1,"level":1,"parent":false},{"section":"source-maps","title":"Source Maps","content":"CoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the --map or -m flag to the compiler.--map-mFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the HTML5 Tutorial.HTML5 Tutorial","dataLevel":1,"level":1,"parent":false},{"section":"cake","title":"Cake, and Cakefiles","content":"CoffeeScript includes a (very) simple build system similar to Make and Rake. Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named Cakefile, and can be invoked by running cake [task] from within the directory. To print a list of all the tasks and options, just type cake.MakeRakeCakefilecake [task]cakeTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the options object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:options               fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code       fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code                 var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); });       var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); });                       fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code       fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code                 var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); });       var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); });               fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code       fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code     fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code fs = require 'fs' option '-o', '--output [DIR]', 'directory for compiled code' task 'build:parser', 'rebuild the Jison parser', (options) ->   require 'jison'   code = require('./lib/grammar').parser.generate()   dir  = options.output or 'lib'   fs.writeFile \"#{dir}/parser.js\", code fs=require'fs'option'-o','--output [DIR]','directory for compiled code'task'build:parser','rebuild the Jison parser',(options)->require'jison'code=require('./lib/grammar').parser.generate()dir=options.outputor'lib'fs.writeFile\"#{dir}/parser.js\",code       var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); });       var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); });     var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); }); var fs; fs = require('fs'); option('-o', '--output [DIR]', 'directory for compiled code'); task('build:parser', 'rebuild the Jison parser', function(options) {   var code, dir;   require('jison');   code = require('./lib/grammar').parser.generate();   dir = options.output || 'lib';   return fs.writeFile(`${dir}/parser.js`, code); }); varfsfs=require'fs'option'-o''--output [DIR]''directory for compiled code'task'build:parser''rebuild the Jison parser'functionoptionsvarcodedirrequire'jison'code=require'./lib/grammar'parsergeneratedir=optionsoutput||'lib'returnfswriteFile`${dir}/parser.js`codeIf you need to invoke one task before another — for example, running build before test, you can use the invoke function: invoke 'build'. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so don’t expect any fanciness built-in. If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.buildtestinvokeinvoke 'build'don’t expect any fanciness built-in","dataLevel":1,"level":1,"parent":false},{"section":"scripts","title":"\"text/coffeescript\" Script Tags","content":"\"text/coffeescript\"While it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using <script type=\"text/coffeescript\"> tags. The source includes a compressed and minified version of the compiler (Download current version here, 51k when gzipped) as docs/v2/browser-compiler/coffeescript.js. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.<script type=\"text/coffeescript\">Download current version here, 51k when gzippeddocs/v2/browser-compiler/coffeescript.jsThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the window object.window","dataLevel":1,"level":1,"parent":false},{"section":"resources","title":"Resources","content":" CoffeeScript on GitHub CoffeeScript Issues Bug reports, feature proposals, and ideas for changes to the language belong here. CoffeeScript Google Group If you’d like to ask a question, the mailing list is a good place to get help. The CoffeeScript Wiki If you’ve ever learned a neat CoffeeScript tip or trick, or ran into a gotcha — share it on the wiki. The wiki also serves as a directory of handy text editor extensions, web framework plugins, and general CoffeeScript build tools. The FAQ Perhaps your CoffeeScript-related question has been asked before. Check the FAQ first. JS2Coffee Is a very well done reverse JavaScript-to-CoffeeScript compiler. It’s not going to be perfect (infer what your JavaScript classes are, when you need bound functions, and so on…) — but it’s a great starting point for converting simple scripts. High-Rez Logo The CoffeeScript logo is available in SVG for use in presentations. CoffeeScript on GitHubCoffeeScript on GitHubCoffeeScript Issues Bug reports, feature proposals, and ideas for changes to the language belong here.CoffeeScript IssuesCoffeeScript Google Group If you’d like to ask a question, the mailing list is a good place to get help.CoffeeScript Google GroupThe CoffeeScript Wiki If you’ve ever learned a neat CoffeeScript tip or trick, or ran into a gotcha — share it on the wiki. The wiki also serves as a directory of handy text editor extensions, web framework plugins, and general CoffeeScript build tools.The CoffeeScript Wikitext editor extensionsweb framework pluginsCoffeeScript build toolsThe FAQ Perhaps your CoffeeScript-related question has been asked before. Check the FAQ first.The FAQJS2Coffee Is a very well done reverse JavaScript-to-CoffeeScript compiler. It’s not going to be perfect (infer what your JavaScript classes are, when you need bound functions, and so on…) — but it’s a great starting point for converting simple scripts.JS2CoffeeHigh-Rez Logo The CoffeeScript logo is available in SVG for use in presentations.High-Rez LogoBooksThere are a number of excellent resources to help you get started with CoffeeScript, some of which are freely available online. The Little Book on CoffeeScript is a brief 5-chapter introduction to CoffeeScript, written with great clarity and precision by Alex MacCaw. Smooth CoffeeScript is a reimagination of the excellent book Eloquent JavaScript, as if it had been written in CoffeeScript instead. Covers language features as well as the functional and object oriented programming styles. By E. Hoigaard. CoffeeScript: Accelerated JavaScript Development is Trevor Burnham’s thorough introduction to the language. By the end of the book, you’ll have built a fast-paced multiplayer word game, writing both the client-side and Node.js portions in CoffeeScript. CoffeeScript Programming with jQuery, Rails, and Node.js is a new book by Michael Erasmus that covers CoffeeScript with an eye towards real-world usage both in the browser (jQuery) and on the server-side (Rails, Node). CoffeeScript Ristretto is a deep dive into CoffeeScript’s semantics from simple functions up through closures, higher-order functions, objects, classes, combinators, and decorators. By Reg Braithwaite. Testing with CoffeeScript is a succinct and freely downloadable guide to building testable applications with CoffeeScript and Jasmine. CoffeeScript Application Development from Packt, introduces CoffeeScript while walking through the process of building a demonstration web application. A CoffeeScript Application Development Coookbook with over 90 “recipes” is also available. CoffeeScript in Action from Manning Publications, covers CoffeeScript syntax, composition techniques and application development. CoffeeScript: Die Alternative zu JavaScript from dpunkt.verlag, is the first CoffeeScript book in Deutsch. The Little Book on CoffeeScript is a brief 5-chapter introduction to CoffeeScript, written with great clarity and precision by Alex MacCaw.The Little Book on CoffeeScriptAlex MacCawSmooth CoffeeScript is a reimagination of the excellent book Eloquent JavaScript, as if it had been written in CoffeeScript instead. Covers language features as well as the functional and object oriented programming styles. By E. Hoigaard.Smooth CoffeeScriptEloquent JavaScriptE. HoigaardCoffeeScript: Accelerated JavaScript Development is Trevor Burnham’s thorough introduction to the language. By the end of the book, you’ll have built a fast-paced multiplayer word game, writing both the client-side and Node.js portions in CoffeeScript.CoffeeScript: Accelerated JavaScript DevelopmentTrevor BurnhamCoffeeScript Programming with jQuery, Rails, and Node.js is a new book by Michael Erasmus that covers CoffeeScript with an eye towards real-world usage both in the browser (jQuery) and on the server-side (Rails, Node).CoffeeScript Programming with jQuery, Rails, and Node.jsCoffeeScript Ristretto is a deep dive into CoffeeScript’s semantics from simple functions up through closures, higher-order functions, objects, classes, combinators, and decorators. By Reg Braithwaite.CoffeeScript RistrettoReg BraithwaiteTesting with CoffeeScript is a succinct and freely downloadable guide to building testable applications with CoffeeScript and Jasmine.Testing with CoffeeScriptCoffeeScript Application Development from Packt, introduces CoffeeScript while walking through the process of building a demonstration web application. A CoffeeScript Application Development Coookbook with over 90 “recipes” is also available.CoffeeScript Application DevelopmentCoffeeScript Application Development CoookbookCoffeeScript in Action from Manning Publications, covers CoffeeScript syntax, composition techniques and application development.CoffeeScript in ActionCoffeeScript: Die Alternative zu JavaScript from dpunkt.verlag, is the first CoffeeScript book in Deutsch.CoffeeScript: Die Alternative zu JavaScriptScreencasts A Sip of CoffeeScript is a Code School Course which combines 6 screencasts with in-browser coding to make learning fun. The first level is free to try out. Meet CoffeeScript is a 75-minute long screencast by PeepCode, now PluralSight. Highly memorable for its animations which demonstrate transforming CoffeeScript into the equivalent JS. If you’re looking for less of a time commitment, RailsCasts’ CoffeeScript Basics should have you covered, hitting all of the important notes about CoffeeScript in 11 minutes. A Sip of CoffeeScript is a Code School Course which combines 6 screencasts with in-browser coding to make learning fun. The first level is free to try out.A Sip of CoffeeScriptCode School CourseMeet CoffeeScript is a 75-minute long screencast by PeepCode, now PluralSight. Highly memorable for its animations which demonstrate transforming CoffeeScript into the equivalent JS.Meet CoffeeScriptPluralSightIf you’re looking for less of a time commitment, RailsCasts’ CoffeeScript Basics should have you covered, hitting all of the important notes about CoffeeScript in 11 minutes.CoffeeScript BasicsExamplesThe best list of open-source CoffeeScript examples can be found on GitHub. But just to throw out a few more:best list of open-source CoffeeScript examples GitHub’s Hubot, a friendly IRC robot that can perform any number of useful and useless tasks. sstephenson’s Pow, a zero-configuration Rack server, with comprehensive annotated source. technoweenie’s Coffee-Resque, a port of Resque for Node.js. stephank’s Orona, a remake of the Bolo tank game for modern browsers. GitHub’s Atom, a hackable text editor built on web technologies. Basecamp’s Trix, a rich text editor for web apps. GitHub’s Hubot, a friendly IRC robot that can perform any number of useful and useless tasks.GitHubHubotsstephenson’s Pow, a zero-configuration Rack server, with comprehensive annotated source.sstephensonPowtechnoweenie’s Coffee-Resque, a port of Resque for Node.js.technoweenieCoffee-ResqueResquestephank’s Orona, a remake of the Bolo tank game for modern browsers.stephankOronaGitHub’s Atom, a hackable text editor built on web technologies.GitHubAtomBasecamp’s Trix, a rich text editor for web apps.BasecampTrixWeb Chat (IRC)Quick help and advice can often be found in the CoffeeScript IRC room #coffeescript on irc.freenode.net, which you can join via your web browser.#coffeescriptirc.freenode.netjoin via your web browserAnnotated SourceYou can browse the CoffeeScript 2.3.1 source in readable, annotated form here. You can also jump directly to a particular source file:here Grammar Rules — src/grammar Lexing Tokens — src/lexer The Rewriter — src/rewriter The Syntax Tree — src/nodes Lexical Scope — src/scope Helpers & Utility Functions — src/helpers The CoffeeScript Module — src/coffeescript Cake & Cakefiles — src/cake “coffee” Command-Line Utility — src/command Option Parsing — src/optparse Interactive REPL — src/repl Source Maps — src/sourcemap Grammar Rules — src/grammarGrammar Rules — src/grammarLexing Tokens — src/lexerLexing Tokens — src/lexerThe Rewriter — src/rewriterThe Rewriter — src/rewriterThe Syntax Tree — src/nodesThe Syntax Tree — src/nodesLexical Scope — src/scopeLexical Scope — src/scopeHelpers & Utility Functions — src/helpersHelpers & Utility Functions — src/helpersThe CoffeeScript Module — src/coffeescriptThe CoffeeScript Module — src/coffeescriptCake & Cakefiles — src/cakeCake & Cakefiles — src/cake“coffee” Command-Line Utility — src/command“coffee” Command-Line Utility — src/commandOption Parsing — src/optparseOption Parsing — src/optparseInteractive REPL — src/replInteractive REPL — src/replSource Maps — src/sourcemapSource Maps — src/sourcemapContributingContributions are welcome! Feel free to fork the repo and submit a pull request.the repoSome features of ECMAScript are intentionally unsupported. Please review both the open and closed issues on GitHub to see if the feature you’re looking for has already been discussed. As a general rule, we don’t support ECMAScript syntax for features that aren’t yet finalized (at Stage 4 in the proposal approval process).Some features of ECMAScript are intentionally unsupportedissues on GitHubFor more resources on adding to CoffeeScript, please see the Wiki, especially How The Parser Works.the WikiHow The Parser WorksThere are several things you can do to increase your odds of having your pull request accepted: Create tests! Any pull request should probably include basic tests to verify you didn’t break anything, or future changes won’t break your code. Follow the style of the rest of the CoffeeScript codebase. Ensure any ECMAScript syntax is mature (at Stage 4), with no further potential changes. Add only features that have broad utility, rather than a feature aimed at a specific use case or framework. Create tests! Any pull request should probably include basic tests to verify you didn’t break anything, or future changes won’t break your code.Follow the style of the rest of the CoffeeScript codebase.Ensure any ECMAScript syntax is mature (at Stage 4), with no further potential changes.Add only features that have broad utility, rather than a feature aimed at a specific use case or framework.Of course, it’s entirely possible that you have a great addition, but it doesn’t fit within these constraints. Feel free to roll your own solution; you will have plenty of company.plenty of company","dataLevel":2,"level":1,"parent":false},{"section":"books","title":"Books","content":"There are a number of excellent resources to help you get started with CoffeeScript, some of which are freely available online. The Little Book on CoffeeScript is a brief 5-chapter introduction to CoffeeScript, written with great clarity and precision by Alex MacCaw. Smooth CoffeeScript is a reimagination of the excellent book Eloquent JavaScript, as if it had been written in CoffeeScript instead. Covers language features as well as the functional and object oriented programming styles. By E. Hoigaard. CoffeeScript: Accelerated JavaScript Development is Trevor Burnham’s thorough introduction to the language. By the end of the book, you’ll have built a fast-paced multiplayer word game, writing both the client-side and Node.js portions in CoffeeScript. CoffeeScript Programming with jQuery, Rails, and Node.js is a new book by Michael Erasmus that covers CoffeeScript with an eye towards real-world usage both in the browser (jQuery) and on the server-side (Rails, Node). CoffeeScript Ristretto is a deep dive into CoffeeScript’s semantics from simple functions up through closures, higher-order functions, objects, classes, combinators, and decorators. By Reg Braithwaite. Testing with CoffeeScript is a succinct and freely downloadable guide to building testable applications with CoffeeScript and Jasmine. CoffeeScript Application Development from Packt, introduces CoffeeScript while walking through the process of building a demonstration web application. A CoffeeScript Application Development Coookbook with over 90 “recipes” is also available. CoffeeScript in Action from Manning Publications, covers CoffeeScript syntax, composition techniques and application development. CoffeeScript: Die Alternative zu JavaScript from dpunkt.verlag, is the first CoffeeScript book in Deutsch. The Little Book on CoffeeScript is a brief 5-chapter introduction to CoffeeScript, written with great clarity and precision by Alex MacCaw.The Little Book on CoffeeScriptAlex MacCawSmooth CoffeeScript is a reimagination of the excellent book Eloquent JavaScript, as if it had been written in CoffeeScript instead. Covers language features as well as the functional and object oriented programming styles. By E. Hoigaard.Smooth CoffeeScriptEloquent JavaScriptE. HoigaardCoffeeScript: Accelerated JavaScript Development is Trevor Burnham’s thorough introduction to the language. By the end of the book, you’ll have built a fast-paced multiplayer word game, writing both the client-side and Node.js portions in CoffeeScript.CoffeeScript: Accelerated JavaScript DevelopmentTrevor BurnhamCoffeeScript Programming with jQuery, Rails, and Node.js is a new book by Michael Erasmus that covers CoffeeScript with an eye towards real-world usage both in the browser (jQuery) and on the server-side (Rails, Node).CoffeeScript Programming with jQuery, Rails, and Node.jsCoffeeScript Ristretto is a deep dive into CoffeeScript’s semantics from simple functions up through closures, higher-order functions, objects, classes, combinators, and decorators. By Reg Braithwaite.CoffeeScript RistrettoReg BraithwaiteTesting with CoffeeScript is a succinct and freely downloadable guide to building testable applications with CoffeeScript and Jasmine.Testing with CoffeeScriptCoffeeScript Application Development from Packt, introduces CoffeeScript while walking through the process of building a demonstration web application. A CoffeeScript Application Development Coookbook with over 90 “recipes” is also available.CoffeeScript Application DevelopmentCoffeeScript Application Development CoookbookCoffeeScript in Action from Manning Publications, covers CoffeeScript syntax, composition techniques and application development.CoffeeScript in ActionCoffeeScript: Die Alternative zu JavaScript from dpunkt.verlag, is the first CoffeeScript book in Deutsch.CoffeeScript: Die Alternative zu JavaScript","dataLevel":2,"level":2,"parent":"resources"},{"section":"screencasts","title":"Screencasts","content":" A Sip of CoffeeScript is a Code School Course which combines 6 screencasts with in-browser coding to make learning fun. The first level is free to try out. Meet CoffeeScript is a 75-minute long screencast by PeepCode, now PluralSight. Highly memorable for its animations which demonstrate transforming CoffeeScript into the equivalent JS. If you’re looking for less of a time commitment, RailsCasts’ CoffeeScript Basics should have you covered, hitting all of the important notes about CoffeeScript in 11 minutes. A Sip of CoffeeScript is a Code School Course which combines 6 screencasts with in-browser coding to make learning fun. The first level is free to try out.A Sip of CoffeeScriptCode School CourseMeet CoffeeScript is a 75-minute long screencast by PeepCode, now PluralSight. Highly memorable for its animations which demonstrate transforming CoffeeScript into the equivalent JS.Meet CoffeeScriptPluralSightIf you’re looking for less of a time commitment, RailsCasts’ CoffeeScript Basics should have you covered, hitting all of the important notes about CoffeeScript in 11 minutes.CoffeeScript Basics","dataLevel":2,"level":2,"parent":"resources"},{"section":"examples","title":"Examples","content":"The best list of open-source CoffeeScript examples can be found on GitHub. But just to throw out a few more:best list of open-source CoffeeScript examples GitHub’s Hubot, a friendly IRC robot that can perform any number of useful and useless tasks. sstephenson’s Pow, a zero-configuration Rack server, with comprehensive annotated source. technoweenie’s Coffee-Resque, a port of Resque for Node.js. stephank’s Orona, a remake of the Bolo tank game for modern browsers. GitHub’s Atom, a hackable text editor built on web technologies. Basecamp’s Trix, a rich text editor for web apps. GitHub’s Hubot, a friendly IRC robot that can perform any number of useful and useless tasks.GitHubHubotsstephenson’s Pow, a zero-configuration Rack server, with comprehensive annotated source.sstephensonPowtechnoweenie’s Coffee-Resque, a port of Resque for Node.js.technoweenieCoffee-ResqueResquestephank’s Orona, a remake of the Bolo tank game for modern browsers.stephankOronaGitHub’s Atom, a hackable text editor built on web technologies.GitHubAtomBasecamp’s Trix, a rich text editor for web apps.BasecampTrix","dataLevel":2,"level":2,"parent":"resources"},{"section":"chat","title":"Web Chat (IRC)","content":"Web Chat (IRC)Quick help and advice can often be found in the CoffeeScript IRC room #coffeescript on irc.freenode.net, which you can join via your web browser.#coffeescriptirc.freenode.netjoin via your web browser","dataLevel":2,"level":2,"parent":"resources"},{"section":"annotated-source","title":"Annotated Source","content":"You can browse the CoffeeScript 2.3.1 source in readable, annotated form here. You can also jump directly to a particular source file:here Grammar Rules — src/grammar Lexing Tokens — src/lexer The Rewriter — src/rewriter The Syntax Tree — src/nodes Lexical Scope — src/scope Helpers & Utility Functions — src/helpers The CoffeeScript Module — src/coffeescript Cake & Cakefiles — src/cake “coffee” Command-Line Utility — src/command Option Parsing — src/optparse Interactive REPL — src/repl Source Maps — src/sourcemap Grammar Rules — src/grammarGrammar Rules — src/grammarLexing Tokens — src/lexerLexing Tokens — src/lexerThe Rewriter — src/rewriterThe Rewriter — src/rewriterThe Syntax Tree — src/nodesThe Syntax Tree — src/nodesLexical Scope — src/scopeLexical Scope — src/scopeHelpers & Utility Functions — src/helpersHelpers & Utility Functions — src/helpersThe CoffeeScript Module — src/coffeescriptThe CoffeeScript Module — src/coffeescriptCake & Cakefiles — src/cakeCake & Cakefiles — src/cake“coffee” Command-Line Utility — src/command“coffee” Command-Line Utility — src/commandOption Parsing — src/optparseOption Parsing — src/optparseInteractive REPL — src/replInteractive REPL — src/replSource Maps — src/sourcemapSource Maps — src/sourcemap","dataLevel":2,"level":2,"parent":"resources"},{"section":"contributing","title":"Contributing","content":"Contributions are welcome! Feel free to fork the repo and submit a pull request.the repoSome features of ECMAScript are intentionally unsupported. Please review both the open and closed issues on GitHub to see if the feature you’re looking for has already been discussed. As a general rule, we don’t support ECMAScript syntax for features that aren’t yet finalized (at Stage 4 in the proposal approval process).Some features of ECMAScript are intentionally unsupportedissues on GitHubFor more resources on adding to CoffeeScript, please see the Wiki, especially How The Parser Works.the WikiHow The Parser WorksThere are several things you can do to increase your odds of having your pull request accepted: Create tests! Any pull request should probably include basic tests to verify you didn’t break anything, or future changes won’t break your code. Follow the style of the rest of the CoffeeScript codebase. Ensure any ECMAScript syntax is mature (at Stage 4), with no further potential changes. Add only features that have broad utility, rather than a feature aimed at a specific use case or framework. Create tests! Any pull request should probably include basic tests to verify you didn’t break anything, or future changes won’t break your code.Follow the style of the rest of the CoffeeScript codebase.Ensure any ECMAScript syntax is mature (at Stage 4), with no further potential changes.Add only features that have broad utility, rather than a feature aimed at a specific use case or framework.Of course, it’s entirely possible that you have a great addition, but it doesn’t fit within these constraints. Feel free to roll your own solution; you will have plenty of company.plenty of company","dataLevel":2,"level":2,"parent":"resources"},{"section":"unsupported","title":"Unsupported ECMAScript Features","content":"There are a few ECMAScript features that CoffeeScript intentionally doesn’t support.let and const: block-scoped and reassignment-protected variablesletconstWhen CoffeeScript was designed, var was intentionally omitted. This was to spare developers the mental housekeeping of needing to worry about variable declaration (var foo) as opposed to variable assignment (foo = 1). The CoffeeScript compiler automatically takes care of declaration for you, by generating var statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.varintentionally omitteddeclarationvar fooassignmentfoo = 1varlet and const add a useful ability to JavaScript in that you can use them to declare variables within a block scope, for example within an if statement body or a for loop body, whereas var always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.letconstblockifforvarKeep in mind that const only protects you from reassigning a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:constreassigningconst obj = {foo: 'bar'}; obj.foo = 'baz'; // Allowed! obj = {}; // Throws error const obj = {foo: 'bar'}; obj.foo = 'baz'; // Allowed! obj = {}; // Throws error const obj = {foo: 'bar'}; obj.foo = 'baz'; // Allowed! obj = {}; // Throws error constfoo'bar''baz'// Allowed!// Throws errorNamed functions and function declarationsNewcomers to CoffeeScript often wonder how to generate the JavaScript function foo() {}, as opposed to the foo = function() {} that CoffeeScript produces. The first form is a function declaration, and the second is a function expression. As stated above, in CoffeeScript everything is an expression, so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the subtle differences between the two forms.function foo() {}foo = function() {}function declarationfunction expressioneverything is an expressionsubtle differences between the two formsTechnically, foo = function() {} is creating an anonymous function that gets assigned to a variable named foo. Some very early versions of CoffeeScript named this function, e.g. foo = function foo() {}, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes infer the names of such anonymous functions from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.foo = function() {}foofoo = function foo() {}infer the names of such anonymous functionsget and set keyword shorthand syntaxgetsetget and set, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.getsetThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. get(function foo() {})); and because there is an alternate syntax that is slightly more verbose but just as effective:get(function foo() {})alternate syntax               screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio                 var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });                           \t screen.height                       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio                 var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });               screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio     screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio screen=  width:1200ratio:16/9Object.definePropertyscreen,'height',  get:->this.width/this.ratio  set:(val)->this.width=val*this.ratio       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });     var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } }); var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } }); varscreenscreen=width1200ratio16/9ObjectdefinePropertyscreen'height'getfunctionreturnthiswidth/thisratiosetfunctionvalreturnthiswidth=val*thisratio             \t screen.height                \t screen.height      \t screen.height \t \t ","dataLevel":2,"level":1,"parent":false},{"section":"unsupported-let-const","title":"let and const: block-scoped and reassignment-protected variables","content":"letconstWhen CoffeeScript was designed, var was intentionally omitted. This was to spare developers the mental housekeeping of needing to worry about variable declaration (var foo) as opposed to variable assignment (foo = 1). The CoffeeScript compiler automatically takes care of declaration for you, by generating var statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.varintentionally omitteddeclarationvar fooassignmentfoo = 1varlet and const add a useful ability to JavaScript in that you can use them to declare variables within a block scope, for example within an if statement body or a for loop body, whereas var always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.letconstblockifforvarKeep in mind that const only protects you from reassigning a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:constreassigningconst obj = {foo: 'bar'}; obj.foo = 'baz'; // Allowed! obj = {}; // Throws error const obj = {foo: 'bar'}; obj.foo = 'baz'; // Allowed! obj = {}; // Throws error const obj = {foo: 'bar'}; obj.foo = 'baz'; // Allowed! obj = {}; // Throws error constfoo'bar''baz'// Allowed!// Throws error","dataLevel":2,"level":2,"parent":"unsupported"},{"section":"unsupported-named-functions","title":"Named functions and function declarations","content":"Newcomers to CoffeeScript often wonder how to generate the JavaScript function foo() {}, as opposed to the foo = function() {} that CoffeeScript produces. The first form is a function declaration, and the second is a function expression. As stated above, in CoffeeScript everything is an expression, so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the subtle differences between the two forms.function foo() {}foo = function() {}function declarationfunction expressioneverything is an expressionsubtle differences between the two formsTechnically, foo = function() {} is creating an anonymous function that gets assigned to a variable named foo. Some very early versions of CoffeeScript named this function, e.g. foo = function foo() {}, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes infer the names of such anonymous functions from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.foo = function() {}foofoo = function foo() {}infer the names of such anonymous functions","dataLevel":2,"level":2,"parent":"unsupported"},{"section":"unsupported-get-set","title":"get and set keyword shorthand syntax","content":"getsetget and set, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.getsetThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. get(function foo() {})); and because there is an alternate syntax that is slightly more verbose but just as effective:get(function foo() {})alternate syntax               screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio                 var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });                           \t screen.height                       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio                 var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });               screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio       screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio     screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio screen =   width: 1200   ratio: 16/9 Object.defineProperty screen, 'height',   get: ->     this.width / this.ratio   set: (val) ->     this.width = val * this.ratio screen=  width:1200ratio:16/9Object.definePropertyscreen,'height',  get:->this.width/this.ratio  set:(val)->this.width=val*this.ratio       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });       var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } });     var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } }); var screen; screen = {   width: 1200,   ratio: 16 / 9 }; Object.defineProperty(screen, 'height', {   get: function() {     return this.width / this.ratio;   },   set: function(val) {     return this.width = val * this.ratio;   } }); varscreenscreen=width1200ratio16/9ObjectdefinePropertyscreen'height'getfunctionreturnthiswidth/thisratiosetfunctionvalreturnthiswidth=val*thisratio             \t screen.height                \t screen.height      \t screen.height \t \t ","dataLevel":2,"level":2,"parent":"unsupported"},{"section":"breaking-changes","title":"Breaking Changes From CoffeeScript 1.x to 2","content":"CoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.Bound (fat arrow) functionsIn CoffeeScript 1.x, => compiled to a regular function but with references to this/@ rewritten to use the outer scope’s this, or with the inner function bound to the outer scope via .bind (hence the name “bound function”). In CoffeeScript 2, => compiles to ES2015’s =>, which behaves slightly differently. The largest difference is that in ES2015, => functions lack an arguments object:=>functionthis@this.bind=>ES2015’s =>=>=>arguments               outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2                 var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2                           \t outer(1, 2)                       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2                 var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2               outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2     outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 outer=->inner==>Array.fromargumentsinner()outer(1,2)# Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2     var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 varouterouter=functionvarinnerinner==>returnArrayfromargumentsreturninnerouter12// Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2             \t outer(1, 2)                \t outer(1, 2)      \t outer(1, 2) \t \t Default values for function parameters and destructured elementsPer the ES2015 spec regarding function default parameters and destructuring default values, default values are only applied when a value is missing or undefined. In CoffeeScript 1.x, the default value would be applied in those cases but also if the  value was null.ES2015 spec regarding function default parametersdestructuring default valuesundefinednull               f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2                           \t f(null)                       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2               f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2     f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 f=(a=1)->af(null)# Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2     var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 varff=functiona=1returnafnull// Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2             \t f(null)                \t f(null)      \t f(null) \t \t               {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2                           \t a                       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2               {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2     {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 {a=1}={a:null}a# Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2     var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 varaa=1=anulla// Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2             \t a                \t a      \t a \t \t Bound generator functionsBound generator functions, a.k.a. generator arrow functions, aren’t allowed in ECMAScript. You can write function* or =>, but not both. Therefore, CoffeeScript code like this:aren’t allowed in ECMAScriptfunction*=>f = => yield this # Throws a compiler error f = => yield this # Throws a compiler error f = => yield this # Throws a compiler error f = =>fyieldthis# Throws a compiler errorNeeds to be rewritten the old-fashioned way:               self = this f = -> yield self       self = this f = -> yield self                 var f, self; self = this; f = function*() {   return (yield self); };       var f, self; self = this; f = function*() {   return (yield self); };                       self = this f = -> yield self       self = this f = -> yield self                 var f, self; self = this; f = function*() {   return (yield self); };       var f, self; self = this; f = function*() {   return (yield self); };               self = this f = -> yield self       self = this f = -> yield self     self = this f = -> yield self self = this f = -> yield self self=thisf=->yieldself       var f, self; self = this; f = function*() {   return (yield self); };       var f, self; self = this; f = function*() {   return (yield self); };     var f, self; self = this; f = function*() {   return (yield self); }; var f, self; self = this; f = function*() {   return (yield self); }; varfselfself=thisf=function*returnyieldselfClasses are compiled to ES2015 classesES2015 classes and their methods have some restrictions beyond those on regular functions.Class constructors can’t be invoked without new:new(class)() # Throws a TypeError at runtime (class)() # Throws a TypeError at runtime (class)() # Throws a TypeError at runtime class)()class# Throws a TypeError at runtimeES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:class Base   constructor: ->     @onClick()      # This works     clickHandler = @onClick     clickHandler()  # This throws a runtime error class Component extends Base   onClick: =>     console.log 'Clicked!', @ class Base   constructor: ->     @onClick()      # This works     clickHandler = @onClick     clickHandler()  # This throws a runtime error class Component extends Base   onClick: =>     console.log 'Clicked!', @ class Base   constructor: ->     @onClick()      # This works     clickHandler = @onClick     clickHandler()  # This throws a runtime error class Component extends Base   onClick: =>     console.log 'Clicked!', @ class BaseclassBase-># This works# This throws a runtime errorclass Component extends BaseclassComponentextendsBase=>console'Clicked!'Class methods can’t be used with new (uncommon):newclass Namespace   @Klass = -> new Namespace.Klass  # Throws a TypeError at runtime class Namespace   @Klass = -> new Namespace.Klass  # Throws a TypeError at runtime class Namespace   @Klass = -> new Namespace.Klass  # Throws a TypeError at runtime class NamespaceclassNamespace->new# Throws a TypeError at runtimeDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.class A   name = 'method'   \"#{name}\": ->   # This method will be named 'undefined'   @::[name] = ->  # This will work; assigns to `A.prototype.method` class A   name = 'method'   \"#{name}\": ->   # This method will be named 'undefined'   @::[name] = ->  # This will work; assigns to `A.prototype.method` class A   name = 'method'   \"#{name}\": ->   # This method will be named 'undefined'   @::[name] = ->  # This will work; assigns to `A.prototype.method` class AclassA'method'\"#{name}\"#{name}-># This method will be named 'undefined'-># This will work; assigns to `A.prototype.method`super and thissuperthisIn the constructor of a derived class (a class that extends another class), this cannot be used before calling super:extendsthissuperclass B extends A   constructor: -> this  # Throws a compiler error class B extends A   constructor: -> this  # Throws a compiler error class B extends A   constructor: -> this  # Throws a compiler error class B extends AclassBextendsA->this# Throws a compiler errorThis also means you cannot pass a reference to this as an argument to super in the constructor of a derived class:thissuperclass B extends A   constructor: (@arg) ->     super @arg  # Throws a compiler error class B extends A   constructor: (@arg) ->     super @arg  # Throws a compiler error class B extends A   constructor: (@arg) ->     super @arg  # Throws a compiler error class B extends AclassBextendsA(@arg) ->(@arg)super# Throws a compiler errorThis is a limitation of ES2015 classes. As a workaround, assign to this after the super call:thissuper               class B extends A   constructor: (arg) ->     super arg     @arg = arg       class B extends A   constructor: (arg) ->     super arg     @arg = arg                 var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };                       class B extends A   constructor: (arg) ->     super arg     @arg = arg       class B extends A   constructor: (arg) ->     super arg     @arg = arg                 var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };               class B extends A   constructor: (arg) ->     super arg     @arg = arg       class B extends A   constructor: (arg) ->     super arg     @arg = arg     class B extends A   constructor: (arg) ->     super arg     @arg = arg class B extends A   constructor: (arg) ->     super arg     @arg = arg classBextendsAconstructor:(arg)->superarg@arg=arg       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };     var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } }; var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } }; varBB=classBextendsAconstructorargsuperargthisarg=argsuper and extendssuperextendsDue to a syntax clash with super with accessors, “bare” super (the keyword super without parentheses) no longer compiles to a super call forwarding all arguments.supersupersuperclass B extends A   foo: -> super   # Throws a compiler error class B extends A   foo: -> super   # Throws a compiler error class B extends A   foo: -> super   # Throws a compiler error class B extends AclassBextendsA->super# Throws a compiler errorArguments can be forwarded explicitly using splats:               class B extends A   foo: -> super arguments...       class B extends A   foo: -> super arguments...                 var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };                       class B extends A   foo: -> super arguments...       class B extends A   foo: -> super arguments...                 var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };               class B extends A   foo: -> super arguments...       class B extends A   foo: -> super arguments...     class B extends A   foo: -> super arguments... class B extends A   foo: -> super arguments... classBextendsAfoo:->superarguments...       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };     var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; varBB=classBextendsAfooreturnsuperfoo...argumentsOr if you know that the parent function doesn’t require arguments, just call super():super()               class B extends A   foo: -> super()       class B extends A   foo: -> super()                 var B; B = class B extends A {   foo() {     return super.foo();   } };       var B; B = class B extends A {   foo() {     return super.foo();   } };                       class B extends A   foo: -> super()       class B extends A   foo: -> super()                 var B; B = class B extends A {   foo() {     return super.foo();   } };       var B; B = class B extends A {   foo() {     return super.foo();   } };               class B extends A   foo: -> super()       class B extends A   foo: -> super()     class B extends A   foo: -> super() class B extends A   foo: -> super() classBextendsAfoo:->super()       var B; B = class B extends A {   foo() {     return super.foo();   } };       var B; B = class B extends A {   foo() {     return super.foo();   } };     var B; B = class B extends A {   foo() {     return super.foo();   } }; var B; B = class B extends A {   foo() {     return super.foo();   } }; varBB=classBextendsAfooreturnsuperfooCoffeeScript 1.x allowed the extends keyword to set up prototypal inheritance between functions, and super could be used manually prototype-assigned functions:extendssuperA = -> B = -> B extends A B.prototype.foo = -> super arguments... # Last two lines each throw compiler errors in CoffeeScript 2 A = -> B = -> B extends A B.prototype.foo = -> super arguments... # Last two lines each throw compiler errors in CoffeeScript 2 A = -> B = -> B extends A B.prototype.foo = -> super arguments... # Last two lines each throw compiler errors in CoffeeScript 2 A = ->AB = ->B->super# Last two lines each throw compiler errors in CoffeeScript 2Due to the switch to ES2015 extends and super, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:extendssuper               # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments                 // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };                       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments                 // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };               # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments     # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments # Helper functionshasProp={}.hasOwnPropertyextend=(child,parent)->ctor=->@constructor=childreturnforkeyofparentifhasProp.call(parent,key)child[key]=parent[key]  ctor.prototype=parent.prototypechild.prototype=newctorchildA=->B=->extendB,AB.prototype.foo=->A::foo.applythis,arguments       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };     // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); }; // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); }; // Helper functionsvarABextendhasProphasProp=hasOwnPropertyextend=functionchildparentvarctorkeyctor=functionthisconstructor=childforkeyinparentifhasPropcallparentkeychildkey=parentkeyctorprototype=parentprototypechildprototype=newctorreturnchildA=functionB=functionextendBABprototypefoo=functionreturnAprototypefooapplythisargumentsor               class A class B extends A   foo: -> super arguments...       class A class B extends A   foo: -> super arguments...                 var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };                       class A class B extends A   foo: -> super arguments...       class A class B extends A   foo: -> super arguments...                 var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };               class A class B extends A   foo: -> super arguments...       class A class B extends A   foo: -> super arguments...     class A class B extends A   foo: -> super arguments... class A class B extends A   foo: -> super arguments... classAclassBextendsAfoo:->superarguments...       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };     var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; varABA=classAB=classBextendsAfooreturnsuperfoo...argumentsJSX and the < and > operators<>With the addition of JSX, the < and > characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like <div>. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: i < len, not i<len. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.JSX<><div>i < leni<lenLiterate CoffeeScript parsingCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.Code blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.Code blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.Argument parsing and shebang (#!) lines#!In CoffeeScript 1.x, -- was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:--coffee [options] path/to/script.coffee -- [args] coffee [options] path/to/script.coffee -- [args] coffee [options] path/to/script.coffee -- [args] Now you would just type:coffee [options] path/to/script.coffee [args] coffee [options] path/to/script.coffee [args] coffee [options] path/to/script.coffee [args] The deprecated version will still work, but it will print a warning before running the script.On non-Windows platforms, a .coffee file can be made executable by adding a shebang (#!) line at the top of the file and marking the file as executable. For example:.coffee#!#!/usr/bin/env coffee x = 2 + 2 console.log x #!/usr/bin/env coffee x = 2 + 2 console.log x #!/usr/bin/env coffee x = 2 + 2 console.log x #!/usr/bin/env coffee22consoleIf this were saved as executable.coffee, it could be made executable and run:executable.coffee▶ chmod +x ./executable.coffee ▶ ./executable.coffee 4 ▶ chmod +x ./executable.coffee ▶ ./executable.coffee 4 ▶ chmod +x ./executable.coffee ▶ ./executable.coffee 4 In CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using #!/usr/bin/env coffee -- as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing --, we recommend simply changing the shebang lines in such scripts to just #!/usr/bin/env coffee.#!/usr/bin/env coffee ----#!/usr/bin/env coffee","dataLevel":3,"level":1,"parent":false},{"section":"breaking-changes-fat-arrow","title":"Bound (fat arrow) functions","content":"Bound (fat arrow) functionsIn CoffeeScript 1.x, => compiled to a regular function but with references to this/@ rewritten to use the outer scope’s this, or with the inner function bound to the outer scope via .bind (hence the name “bound function”). In CoffeeScript 2, => compiles to ES2015’s =>, which behaves slightly differently. The largest difference is that in ES2015, => functions lack an arguments object:=>functionthis@this.bind=>ES2015’s =>=>=>arguments               outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2                 var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2                           \t outer(1, 2)                       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2                 var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2               outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2     outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 outer = ->   inner = => Array.from arguments   inner() outer(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 outer=->inner==>Array.fromargumentsinner()outer(1,2)# Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2       var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2     var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 var outer; outer = function() {   var inner;   inner = () => {     return Array.from(arguments);   };   return inner(); }; outer(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2 varouterouter=functionvarinnerinner==>returnArrayfromargumentsreturninnerouter12// Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2             \t outer(1, 2)                \t outer(1, 2)      \t outer(1, 2) \t \t ","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-default-values","title":"Default values for function parameters and destructured elements","content":"Per the ES2015 spec regarding function default parameters and destructuring default values, default values are only applied when a value is missing or undefined. In CoffeeScript 1.x, the default value would be applied in those cases but also if the  value was null.ES2015 spec regarding function default parametersdestructuring default valuesundefinednull               f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2                           \t f(null)                       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2               f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2     f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 f = (a = 1) -> a f(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 f=(a=1)->af(null)# Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2       var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2     var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 var f; f = function(a = 1) {   return a; }; f(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2 varff=functiona=1returnafnull// Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2             \t f(null)                \t f(null)      \t f(null) \t \t               {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2                           \t a                       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2                 var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2               {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2     {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 {a = 1} = {a: null} a  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 {a=1}={a:null}a# Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2       var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2     var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 var a; ({a = 1} = {   a: null }); a; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2 varaa=1=anulla// Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2             \t a                \t a      \t a \t \t ","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-bound-generator-functions","title":"Bound generator functions","content":"Bound generator functions, a.k.a. generator arrow functions, aren’t allowed in ECMAScript. You can write function* or =>, but not both. Therefore, CoffeeScript code like this:aren’t allowed in ECMAScriptfunction*=>f = => yield this # Throws a compiler error f = => yield this # Throws a compiler error f = => yield this # Throws a compiler error f = =>fyieldthis# Throws a compiler errorNeeds to be rewritten the old-fashioned way:               self = this f = -> yield self       self = this f = -> yield self                 var f, self; self = this; f = function*() {   return (yield self); };       var f, self; self = this; f = function*() {   return (yield self); };                       self = this f = -> yield self       self = this f = -> yield self                 var f, self; self = this; f = function*() {   return (yield self); };       var f, self; self = this; f = function*() {   return (yield self); };               self = this f = -> yield self       self = this f = -> yield self     self = this f = -> yield self self = this f = -> yield self self=thisf=->yieldself       var f, self; self = this; f = function*() {   return (yield self); };       var f, self; self = this; f = function*() {   return (yield self); };     var f, self; self = this; f = function*() {   return (yield self); }; var f, self; self = this; f = function*() {   return (yield self); }; varfselfself=thisf=function*returnyieldself","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-classes","title":"Classes are compiled to ES2015 classes","content":"ES2015 classes and their methods have some restrictions beyond those on regular functions.Class constructors can’t be invoked without new:new(class)() # Throws a TypeError at runtime (class)() # Throws a TypeError at runtime (class)() # Throws a TypeError at runtime class)()class# Throws a TypeError at runtimeES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:class Base   constructor: ->     @onClick()      # This works     clickHandler = @onClick     clickHandler()  # This throws a runtime error class Component extends Base   onClick: =>     console.log 'Clicked!', @ class Base   constructor: ->     @onClick()      # This works     clickHandler = @onClick     clickHandler()  # This throws a runtime error class Component extends Base   onClick: =>     console.log 'Clicked!', @ class Base   constructor: ->     @onClick()      # This works     clickHandler = @onClick     clickHandler()  # This throws a runtime error class Component extends Base   onClick: =>     console.log 'Clicked!', @ class BaseclassBase-># This works# This throws a runtime errorclass Component extends BaseclassComponentextendsBase=>console'Clicked!'Class methods can’t be used with new (uncommon):newclass Namespace   @Klass = -> new Namespace.Klass  # Throws a TypeError at runtime class Namespace   @Klass = -> new Namespace.Klass  # Throws a TypeError at runtime class Namespace   @Klass = -> new Namespace.Klass  # Throws a TypeError at runtime class NamespaceclassNamespace->new# Throws a TypeError at runtimeDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.class A   name = 'method'   \"#{name}\": ->   # This method will be named 'undefined'   @::[name] = ->  # This will work; assigns to `A.prototype.method` class A   name = 'method'   \"#{name}\": ->   # This method will be named 'undefined'   @::[name] = ->  # This will work; assigns to `A.prototype.method` class A   name = 'method'   \"#{name}\": ->   # This method will be named 'undefined'   @::[name] = ->  # This will work; assigns to `A.prototype.method` class AclassA'method'\"#{name}\"#{name}-># This method will be named 'undefined'-># This will work; assigns to `A.prototype.method`","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-super-this","title":"super and this","content":"superthisIn the constructor of a derived class (a class that extends another class), this cannot be used before calling super:extendsthissuperclass B extends A   constructor: -> this  # Throws a compiler error class B extends A   constructor: -> this  # Throws a compiler error class B extends A   constructor: -> this  # Throws a compiler error class B extends AclassBextendsA->this# Throws a compiler errorThis also means you cannot pass a reference to this as an argument to super in the constructor of a derived class:thissuperclass B extends A   constructor: (@arg) ->     super @arg  # Throws a compiler error class B extends A   constructor: (@arg) ->     super @arg  # Throws a compiler error class B extends A   constructor: (@arg) ->     super @arg  # Throws a compiler error class B extends AclassBextendsA(@arg) ->(@arg)super# Throws a compiler errorThis is a limitation of ES2015 classes. As a workaround, assign to this after the super call:thissuper               class B extends A   constructor: (arg) ->     super arg     @arg = arg       class B extends A   constructor: (arg) ->     super arg     @arg = arg                 var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };                       class B extends A   constructor: (arg) ->     super arg     @arg = arg       class B extends A   constructor: (arg) ->     super arg     @arg = arg                 var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };               class B extends A   constructor: (arg) ->     super arg     @arg = arg       class B extends A   constructor: (arg) ->     super arg     @arg = arg     class B extends A   constructor: (arg) ->     super arg     @arg = arg class B extends A   constructor: (arg) ->     super arg     @arg = arg classBextendsAconstructor:(arg)->superarg@arg=arg       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };       var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } };     var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } }; var B; B = class B extends A {   constructor(arg) {     super(arg);     this.arg = arg;   } }; varBB=classBextendsAconstructorargsuperargthisarg=arg","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-super-extends","title":"super and extends","content":"superextendsDue to a syntax clash with super with accessors, “bare” super (the keyword super without parentheses) no longer compiles to a super call forwarding all arguments.supersupersuperclass B extends A   foo: -> super   # Throws a compiler error class B extends A   foo: -> super   # Throws a compiler error class B extends A   foo: -> super   # Throws a compiler error class B extends AclassBextendsA->super# Throws a compiler errorArguments can be forwarded explicitly using splats:               class B extends A   foo: -> super arguments...       class B extends A   foo: -> super arguments...                 var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };                       class B extends A   foo: -> super arguments...       class B extends A   foo: -> super arguments...                 var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };               class B extends A   foo: -> super arguments...       class B extends A   foo: -> super arguments...     class B extends A   foo: -> super arguments... class B extends A   foo: -> super arguments... classBextendsAfoo:->superarguments...       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } };     var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; var B; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; varBB=classBextendsAfooreturnsuperfoo...argumentsOr if you know that the parent function doesn’t require arguments, just call super():super()               class B extends A   foo: -> super()       class B extends A   foo: -> super()                 var B; B = class B extends A {   foo() {     return super.foo();   } };       var B; B = class B extends A {   foo() {     return super.foo();   } };                       class B extends A   foo: -> super()       class B extends A   foo: -> super()                 var B; B = class B extends A {   foo() {     return super.foo();   } };       var B; B = class B extends A {   foo() {     return super.foo();   } };               class B extends A   foo: -> super()       class B extends A   foo: -> super()     class B extends A   foo: -> super() class B extends A   foo: -> super() classBextendsAfoo:->super()       var B; B = class B extends A {   foo() {     return super.foo();   } };       var B; B = class B extends A {   foo() {     return super.foo();   } };     var B; B = class B extends A {   foo() {     return super.foo();   } }; var B; B = class B extends A {   foo() {     return super.foo();   } }; varBB=classBextendsAfooreturnsuperfooCoffeeScript 1.x allowed the extends keyword to set up prototypal inheritance between functions, and super could be used manually prototype-assigned functions:extendssuperA = -> B = -> B extends A B.prototype.foo = -> super arguments... # Last two lines each throw compiler errors in CoffeeScript 2 A = -> B = -> B extends A B.prototype.foo = -> super arguments... # Last two lines each throw compiler errors in CoffeeScript 2 A = -> B = -> B extends A B.prototype.foo = -> super arguments... # Last two lines each throw compiler errors in CoffeeScript 2 A = ->AB = ->B->super# Last two lines each throw compiler errors in CoffeeScript 2Due to the switch to ES2015 extends and super, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:extendssuper               # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments                 // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };                       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments                 // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };               # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments       # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments     # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments # Helper functions hasProp = {}.hasOwnProperty extend = (child, parent) ->   ctor = ->     @constructor = child     return   for key of parent     if hasProp.call(parent, key)       child[key] = parent[key]   ctor.prototype = parent.prototype   child.prototype = new ctor   child A = -> B = -> extend B, A B.prototype.foo = -> A::foo.apply this, arguments # Helper functionshasProp={}.hasOwnPropertyextend=(child,parent)->ctor=->@constructor=childreturnforkeyofparentifhasProp.call(parent,key)child[key]=parent[key]  ctor.prototype=parent.prototypechild.prototype=newctorchildA=->B=->extendB,AB.prototype.foo=->A::foo.applythis,arguments       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };       // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); };     // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); }; // Helper functions var A, B, extend, hasProp; hasProp = {}.hasOwnProperty; extend = function(child, parent) {   var ctor, key;   ctor = function() {     this.constructor = child;   };   for (key in parent) {     if (hasProp.call(parent, key)) {       child[key] = parent[key];     }   }   ctor.prototype = parent.prototype;   child.prototype = new ctor;   return child; }; A = function() {}; B = function() {}; extend(B, A); B.prototype.foo = function() {   return A.prototype.foo.apply(this, arguments); }; // Helper functionsvarABextendhasProphasProp=hasOwnPropertyextend=functionchildparentvarctorkeyctor=functionthisconstructor=childforkeyinparentifhasPropcallparentkeychildkey=parentkeyctorprototype=parentprototypechildprototype=newctorreturnchildA=functionB=functionextendBABprototypefoo=functionreturnAprototypefooapplythisargumentsor               class A class B extends A   foo: -> super arguments...       class A class B extends A   foo: -> super arguments...                 var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };                       class A class B extends A   foo: -> super arguments...       class A class B extends A   foo: -> super arguments...                 var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };               class A class B extends A   foo: -> super arguments...       class A class B extends A   foo: -> super arguments...     class A class B extends A   foo: -> super arguments... class A class B extends A   foo: -> super arguments... classAclassBextendsAfoo:->superarguments...       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };       var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } };     var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; var A, B; A = class A {}; B = class B extends A {   foo() {     return super.foo(...arguments);   } }; varABA=classAB=classBextendsAfooreturnsuperfoo...arguments","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-jsx-and-the-less-than-and-greater-than-operators","title":"JSX and the < and > operators","content":"<>With the addition of JSX, the < and > characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like <div>. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: i < len, not i<len. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.JSX<><div>i < leni<len","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-literate-coffeescript","title":"Literate CoffeeScript parsing","content":"CoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.Code blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.Code blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"breaking-changes-argument-parsing-and-shebang-lines","title":"Argument parsing and shebang (#!) lines","content":"Argument parsing and shebang (#!) lines#!In CoffeeScript 1.x, -- was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:--coffee [options] path/to/script.coffee -- [args] coffee [options] path/to/script.coffee -- [args] coffee [options] path/to/script.coffee -- [args] Now you would just type:coffee [options] path/to/script.coffee [args] coffee [options] path/to/script.coffee [args] coffee [options] path/to/script.coffee [args] The deprecated version will still work, but it will print a warning before running the script.On non-Windows platforms, a .coffee file can be made executable by adding a shebang (#!) line at the top of the file and marking the file as executable. For example:.coffee#!#!/usr/bin/env coffee x = 2 + 2 console.log x #!/usr/bin/env coffee x = 2 + 2 console.log x #!/usr/bin/env coffee x = 2 + 2 console.log x #!/usr/bin/env coffee22consoleIf this were saved as executable.coffee, it could be made executable and run:executable.coffee▶ chmod +x ./executable.coffee ▶ ./executable.coffee 4 ▶ chmod +x ./executable.coffee ▶ ./executable.coffee 4 ▶ chmod +x ./executable.coffee ▶ ./executable.coffee 4 In CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using #!/usr/bin/env coffee -- as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing --, we recommend simply changing the shebang lines in such scripts to just #!/usr/bin/env coffee.#!/usr/bin/env coffee ----#!/usr/bin/env coffee","dataLevel":3,"level":2,"parent":"breaking-changes"},{"section":"changelog","title":"Changelog","content":"2.3.1    — 2018-05-21 2.3.1 — 2018-05-212018-05-21 Returning a JSX tag that is adjacent to another JSX tag, as opposed to returning a root JSX tag or fragment, is invalid JSX syntax. Babel throws an error on this, and now the CoffeeScript compiler does too. Invalid indentation inside a JSX interpolation (the middle of <tag>{ ... }</tag>) now throws an error. The browser compiler, used in Try CoffeeScript and similar web-based CoffeeScript editors, now evaluates code in a global scope rather than the scope of the browser compiler. This improves performance of code executed via the browser compiler. Syntax cleanup: it is now possible for an implicit function call to take a body-less class as an argument, and ?:: now behaves identically to :: with regard to implying a line continuation. Returning a JSX tag that is adjacent to another JSX tag, as opposed to returning a root JSX tag or fragment, is invalid JSX syntax. Babel throws an error on this, and now the CoffeeScript compiler does too.Invalid indentation inside a JSX interpolation (the middle of <tag>{ ... }</tag>) now throws an error.<tag>{ ... }</tag>The browser compiler, used in Try CoffeeScript and similar web-based CoffeeScript editors, now evaluates code in a global scope rather than the scope of the browser compiler. This improves performance of code executed via the browser compiler.Try CoffeeScriptSyntax cleanup: it is now possible for an implicit function call to take a body-less class as an argument, and ?:: now behaves identically to :: with regard to implying a line continuation.?::::2.3.0    — 2018-04-29 2.3.0 — 2018-04-292018-04-29 This release adds support for all the new features and syntaxes in ES2018 that weren’t already possible in CoffeeScript. For all of the below features, make sure that you transpile unless you know that your target runtime(s) support each feature. Asynchronous iterators are now supported. You can now yield an await call, e.g. do -> until file.EOF then yield await file.readLine(). Object splats/destructuring, a.k.a. object rest/spread syntax, has been standardized as part of ES2018 and therefore this release removes the polyfill that had previously been supporting this syntax. Code like {a, b, rest...} = obj now outputs more or less just like it appears, rather than being converted into an Object.assign call. Note that there are some subtle differences between the Object.assign polyfill and the native implementation. The exponentiation operator, **, and exponentiation assignment operator **= are new to JavaScript in ES2018. Now code like a ** 3 is output as it appears, rather than being converted into Math.pow(a, 3) as it was before. The s (dotAll) flag is now supported in regular expressions. This release adds support for all the new features and syntaxes in ES2018 that weren’t already possible in CoffeeScript. For all of the below features, make sure that you transpile unless you know that your target runtime(s) support each feature.transpileAsynchronous iterators are now supported. You can now yield an await call, e.g. do -> until file.EOF then yield await file.readLine().yieldawaitdo -> until file.EOF then yield await file.readLine()Object splats/destructuring, a.k.a. object rest/spread syntax, has been standardized as part of ES2018 and therefore this release removes the polyfill that had previously been supporting this syntax. Code like {a, b, rest...} = obj now outputs more or less just like it appears, rather than being converted into an Object.assign call. Note that there are some subtle differences between the Object.assign polyfill and the native implementation.{a, b, rest...} = objObject.assignsome subtle differencesObject.assignThe exponentiation operator, **, and exponentiation assignment operator **= are new to JavaScript in ES2018. Now code like a ** 3 is output as it appears, rather than being converted into Math.pow(a, 3) as it was before.****=a ** 3Math.pow(a, 3)The s (dotAll) flag is now supported in regular expressions.s2.2.4    — 2018-03-29 2.2.4 — 2018-03-292018-03-29 When the by value in a for loop is a literal number, e.g. for x in [2..1] by -1, fewer checks are necessary to determine if the loop is in range. Bugfix for regression in 2.2.0 where a statement inside parentheses, e.g. (fn(); break) while condition, was compiling. Pure statements like break or return cannot turn a parenthesized block into an expression, and should throw an error. When the by value in a for loop is a literal number, e.g. for x in [2..1] by -1, fewer checks are necessary to determine if the loop is in range.byforfor x in [2..1] by -1Bugfix for regression in 2.2.0 where a statement inside parentheses, e.g. (fn(); break) while condition, was compiling. Pure statements like break or return cannot turn a parenthesized block into an expression, and should throw an error.(fn(); break) while conditionbreakreturn2.2.3    — 2018-03-11 2.2.3 — 2018-03-112018-03-11 Bugfix for object destructuring with an empty array as a key’s value: { key: [] } = obj. Bugfix for array destructuring onto targets attached to this: [ @most... , @penultimate, @last ] = arr. Bugfix for object destructuring with an empty array as a key’s value: { key: [] } = obj.{ key: [] } = objBugfix for array destructuring onto targets attached to this: [ @most... , @penultimate, @last ] = arr.this[ @most... , @penultimate, @last ] = arr2.2.2    — 2018-02-21 2.2.2 — 2018-02-212018-02-21 Bugfix for regression in 2.2.0 where a range with a by (step) value that increments or decrements in the opposite direction as the range was returning an array containing the first value of the range, whereas it should be returning an empty array. In other words, x for x in [2..1] by 1 should equal [], not [2] (because the step value is positive 1, counting up, whereas the range goes from 2 to 1, counting down). Bugfixes for allowing backslashes in import and export statements and lines that trigger the start of an indented block, like an if statement. Bugfix for regression in 2.2.0 where a range with a by (step) value that increments or decrements in the opposite direction as the range was returning an array containing the first value of the range, whereas it should be returning an empty array. In other words, x for x in [2..1] by 1 should equal [], not [2] (because the step value is positive 1, counting up, whereas the range goes from 2 to 1, counting down).byx for x in [2..1] by 1[][2]Bugfixes for allowing backslashes in import and export statements and lines that trigger the start of an indented block, like an if statement.importexportif2.2.1    — 2018-02-06 2.2.1 — 2018-02-062018-02-06 Bugfix for regression in 2.2.0 involving an error thrown by the compiler in certain cases when using destructuring with a splat or expansion in an array. Bugfix for regression in 2.2.0 where in certain cases a range iterator variable was declared in the global scope. Bugfix for regression in 2.2.0 involving an error thrown by the compiler in certain cases when using destructuring with a splat or expansion in an array.Bugfix for regression in 2.2.0 where in certain cases a range iterator variable was declared in the global scope.2.2.0    — 2018-02-01 2.2.0 — 2018-02-012018-02-01 This release fixes all currently open bugs, dating as far back as 2014, 2012 and 2011. Potential breaking change: An inline if or switch statement with an ambiguous else, such as if no then if yes then alert 1 else alert 2, now compiles where the else always corresponds to the closest open then. Previously the behavior of an ambiguous else was unpredictable. If your code has any if … then or switch … then statements with multiple thens (and one or more elses) the compiled output might be different now, unless you had resolved ambiguity via parentheses. We made this change because the previous behavior was inconsistent and basically a bug: depending on what grammar was where, for example if there was an inline function or something that implied a block, the else might bind to an earlier then rather than a later then. Now an else essentially closes a block opened by a then, similar to closing an open parenthesis. When a required then is missing, the error more accurately points out the location of the mistake. An error is thrown when the coffee command is run in an environment that doesn’t support some ES2015 JavaScript features that the CoffeeScript compiler itself requires. This can happen if CoffeeScript is installed in Node older than version 6. Destructuring with a non-final splat/spread, e.g. [open, contents..., close] = tag.split('') is now output using ES2015 rest syntax. Functions named get or set can be used without parentheses in more cases, including when attached to this or @ or ?.; or when the first argument is an implicit object, e.g. @set key: 'val'. Statements such as break can now be used inside parentheses, e.g. (doSomething(); break) while condition or (pick(key); break) for key of obj. Bugfix for assigning to a property attached to this/@ in destructuring, e.g. ({@prop = yes, @otherProp = no}) ->. Bugfix for incorrect errors being thrown about calling super with a parameter attached to this when said parameter is in a lower scope, e.g. class Child extends Parent then constructor: -> super(-> @prop). Bugfix to prevent a possible infinite loop when a for loop is given a variable to step by, e.g. for x in [1..3] by step (as opposed to by 0.5 or some other primitive numeric value). Bugfix to no longer declare iterator variables twice when evaluating a range, e.g. end = 3; fn [0..end]. Bugfix for incorrect scope of variables in chained calls, e.g. start(x = 3).then(-> x = 4). Bugfix for incorrect scope of variables in a function passed to do, e.g. for [1..3] then masked = 10; do -> alert masked. Bugfix to no longer throw a syntax error for a trailing comma in a function call, e.g. fn arg1, arg2,. Bugfix for an expression in a property access, e.g. a[!b in c..]. Bugfix to allow a line continuation backslash (\\) at any point in a for line. This release fixes all currently open bugs, dating as far back as 2014, 2012 and 2011.allPotential breaking change: An inline if or switch statement with an ambiguous else, such as if no then if yes then alert 1 else alert 2, now compiles where the else always corresponds to the closest open then. Previously the behavior of an ambiguous else was unpredictable. If your code has any if … then or switch … then statements with multiple thens (and one or more elses) the compiled output might be different now, unless you had resolved ambiguity via parentheses. We made this change because the previous behavior was inconsistent and basically a bug: depending on what grammar was where, for example if there was an inline function or something that implied a block, the else might bind to an earlier then rather than a later then. Now an else essentially closes a block opened by a then, similar to closing an open parenthesis.Potential breaking change:ifswitchelseif no then if yes then alert 1 else alert 2elsethenelseif … thenswitch … thenthenelseelsethenthenelsethenWhen a required then is missing, the error more accurately points out the location of the mistake.thenAn error is thrown when the coffee command is run in an environment that doesn’t support some ES2015 JavaScript features that the CoffeeScript compiler itself requires. This can happen if CoffeeScript is installed in Node older than version 6.coffeeDestructuring with a non-final splat/spread, e.g. [open, contents..., close] = tag.split('') is now output using ES2015 rest syntax.[open, contents..., close] = tag.split('')Functions named get or set can be used without parentheses in more cases, including when attached to this or @ or ?.; or when the first argument is an implicit object, e.g. @set key: 'val'.getsetthis@?.@set key: 'val'Statements such as break can now be used inside parentheses, e.g. (doSomething(); break) while condition or (pick(key); break) for key of obj.break(doSomething(); break) while condition(pick(key); break) for key of objBugfix for assigning to a property attached to this/@ in destructuring, e.g. ({@prop = yes, @otherProp = no}) ->.this@({@prop = yes, @otherProp = no}) ->Bugfix for incorrect errors being thrown about calling super with a parameter attached to this when said parameter is in a lower scope, e.g. class Child extends Parent then constructor: -> super(-> @prop).superthisclass Child extends Parent then constructor: -> super(-> @prop)Bugfix to prevent a possible infinite loop when a for loop is given a variable to step by, e.g. for x in [1..3] by step (as opposed to by 0.5 or some other primitive numeric value).forfor x in [1..3] by stepby 0.5Bugfix to no longer declare iterator variables twice when evaluating a range, e.g. end = 3; fn [0..end].end = 3; fn [0..end]Bugfix for incorrect scope of variables in chained calls, e.g. start(x = 3).then(-> x = 4).start(x = 3).then(-> x = 4)Bugfix for incorrect scope of variables in a function passed to do, e.g. for [1..3] then masked = 10; do -> alert masked.dofor [1..3] then masked = 10; do -> alert maskedBugfix to no longer throw a syntax error for a trailing comma in a function call, e.g. fn arg1, arg2,.fn arg1, arg2,Bugfix for an expression in a property access, e.g. a[!b in c..].a[!b in c..]Bugfix to allow a line continuation backslash (\\) at any point in a for line.\\for2.1.1    — 2017-12-29 2.1.1 — 2017-12-292017-12-29 Bugfix to set the correct context for executable class bodies. So in class @B extends @A then @property = 1, the @ in @property now refers to the class, not the global object. Bugfix where anonymous classes were getting created using the same automatic variable name. They now each receive unique names, so as not to override each other. Bugfix to set the correct context for executable class bodies. So in class @B extends @A then @property = 1, the @ in @property now refers to the class, not the global object.class @B extends @A then @property = 1@@propertyBugfix where anonymous classes were getting created using the same automatic variable name. They now each receive unique names, so as not to override each other.2.1.0    — 2017-12-10 2.1.0 — 2017-12-102017-12-10 Computed property keys in object literals are now supported: obj = { ['key' + i]: 42 }, or obj = [Symbol.iterator]: -> yield i++. Skipping of array elements, a.k.a. elision, is now supported: arr = [a, , b], or [, protocol] = url.match /^(.*):\\/\\//. JSX fragments syntax is now supported. Bugfix where /// within a # line comment inside a /// block regex was erroneously closing the regex, rather than being treated as part of the comment. Bugfix for incorrect output for object rest destructuring inside array destructuring. Computed property keys in object literals are now supported: obj = { ['key' + i]: 42 }, or obj = [Symbol.iterator]: -> yield i++.obj = { ['key' + i]: 42 }obj = [Symbol.iterator]: -> yield i++Skipping of array elements, a.k.a. elision, is now supported: arr = [a, , b], or [, protocol] = url.match /^(.*):\\/\\//.arr = [a, , b][, protocol] = url.match /^(.*):\\/\\//JSX fragments syntax is now supported.JSX fragments syntaxBugfix where /// within a # line comment inside a /// block regex was erroneously closing the regex, rather than being treated as part of the comment.///#///Bugfix for incorrect output for object rest destructuring inside array destructuring.2.0.3    — 2017-11-26 2.0.3 — 2017-11-262017-11-26 Bugfix for export default followed by an implicit object that contains an explicit object, for example exportedMember: { obj... }. Bugfix for key, val of obj after an implicit object member, e.g. foo: bar for key, val of obj. Bugfix for combining array and object destructuring, e.g. [ ..., {a, b} ] = arr. Bugfix for an edge case where it was possible to create a bound (=>) generator function, which should throw an error as such functions aren’t allowed in ES2015. Bugfix for source maps: .map files should always have the same base filename as the requested output filename. So coffee --map --output foo.js test.coffee should generate foo.js and foo.js.map. Bugfix for incorrect source maps generated when using --transpile with --map for multiple input files. Bugfix for comments at the beginning or end of input into the REPL (coffee --interactive). Bugfix for export default followed by an implicit object that contains an explicit object, for example exportedMember: { obj... }.export defaultexportedMember: { obj... }Bugfix for key, val of obj after an implicit object member, e.g. foo: bar for key, val of obj.key, val of objfoo: bar for key, val of objBugfix for combining array and object destructuring, e.g. [ ..., {a, b} ] = arr.[ ..., {a, b} ] = arrBugfix for an edge case where it was possible to create a bound (=>) generator function, which should throw an error as such functions aren’t allowed in ES2015.=>Bugfix for source maps: .map files should always have the same base filename as the requested output filename. So coffee --map --output foo.js test.coffee should generate foo.js and foo.js.map..mapcoffee --map --output foo.js test.coffeefoo.jsfoo.js.mapBugfix for incorrect source maps generated when using --transpile with --map for multiple input files.--transpile--mapBugfix for comments at the beginning or end of input into the REPL (coffee --interactive).coffee --interactive2.0.2    — 2017-10-26 2.0.2 — 2017-10-262017-10-26 --transpile now also applies to required or imported CoffeeScript files. --transpile can be used with the REPL: coffee --interactive --transpile. Improvements to comments output that should now cover all of the Flow comment-based syntax. Inline ### comments near variable initial assignments are now output in the variable declaration statement, and ### comments near a class and method names are now output where Flow expects them. Importing CoffeeScript keywords is now allowed, so long as they’re aliased: import { and as andFn } from 'lib'. (You could also do import lib from 'lib' and then reference lib.and.) Calls to functions named get and set no longer throw an error when given a bracketless object literal as an argument: obj.set propertyName: propertyValue. In the constructor of a derived class (a class that extends another class), you cannot call super with an argument that references this: class Child extends Parent then constructor: (@arg) -> super(@arg). This isn’t allowed in JavaScript, and now the CoffeeScript compiler will throw an error. Instead, assign to this after calling super: (arg) -> super(arg); @arg = arg. Bugfix for incorrect output when backticked statements and hoisted expressions were both in the same class body. This allows a backticked line like `field = 3`, for people using the experimental class fields syntax, in the same class along with traditional class body expressions like prop: 3 that CoffeeScript outputs as part of the class prototype. Bugfix for comments not output before a complex ? operation, e.g. @a ? b. All tests now pass in Windows. --transpile now also applies to required or imported CoffeeScript files.--transpilerequireimport--transpile can be used with the REPL: coffee --interactive --transpile.--transpilecoffee --interactive --transpileImprovements to comments output that should now cover all of the Flow comment-based syntax. Inline ### comments near variable initial assignments are now output in the variable declaration statement, and ### comments near a class and method names are now output where Flow expects them.Flow comment-based syntax###variable###class and method namesImporting CoffeeScript keywords is now allowed, so long as they’re aliased: import { and as andFn } from 'lib'. (You could also do import lib from 'lib' and then reference lib.and.)import { and as andFn } from 'lib'import lib from 'lib'lib.andCalls to functions named get and set no longer throw an error when given a bracketless object literal as an argument: obj.set propertyName: propertyValue.getsetobj.set propertyName: propertyValueIn the constructor of a derived class (a class that extends another class), you cannot call super with an argument that references this: class Child extends Parent then constructor: (@arg) -> super(@arg). This isn’t allowed in JavaScript, and now the CoffeeScript compiler will throw an error. Instead, assign to this after calling super: (arg) -> super(arg); @arg = arg.extendssuperthisclass Child extends Parent then constructor: (@arg) -> super(@arg)thissuper(arg) -> super(arg); @arg = argBugfix for incorrect output when backticked statements and hoisted expressions were both in the same class body. This allows a backticked line like `field = 3`, for people using the experimental class fields syntax, in the same class along with traditional class body expressions like prop: 3 that CoffeeScript outputs as part of the class prototype.`field = 3`class fieldsprop: 3Bugfix for comments not output before a complex ? operation, e.g. @a ? b.?@a ? bAll tests now pass in Windows.2.0.1    — 2017-09-26 2.0.1 — 2017-09-262017-09-26 babel-core is no longer listed in package.json, even as an optionalDependency, to avoid it being automatically installed for most users. If you wish to use --transpile, simply install babel-core manually. See Transpilation. --transpile now relies on Babel to find its options, i.e. the .babelrc file in the path of the file(s) being compiled. (Previously the CoffeeScript compiler was duplicating this logic, so nothing has changed from a user’s perspective.) This provides automatic support for additional ways to pass options to Babel in future versions, such as the .babelrc.js file coming in Babel 7. Backticked expressions in a class body, outside any class methods, are now output in the JavaScript class body itself. This allows for passing through experimental JavaScript syntax like the class fields proposal, assuming your transpiler supports it. babel-core is no longer listed in package.json, even as an optionalDependency, to avoid it being automatically installed for most users. If you wish to use --transpile, simply install babel-core manually. See Transpilation.babel-corepackage.jsonoptionalDependency--transpilebabel-coreTranspilation--transpile now relies on Babel to find its options, i.e. the .babelrc file in the path of the file(s) being compiled. (Previously the CoffeeScript compiler was duplicating this logic, so nothing has changed from a user’s perspective.) This provides automatic support for additional ways to pass options to Babel in future versions, such as the .babelrc.js file coming in Babel 7.--transpile.babelrc.babelrc.jsBackticked expressions in a class body, outside any class methods, are now output in the JavaScript class body itself. This allows for passing through experimental JavaScript syntax like the class fields proposal, assuming your transpiler supports it.class fields proposaltranspiler supports it2.0.0    — 2017-09-18 2.0.0 — 2017-09-182017-09-18 Added --transpile flag or transpile Node API option to tell the CoffeeScript compiler to pipe its output through Babel before saving or returning it; see Transpilation. Also changed the -t short flag to refer to --transpile instead of --tokens. Always populate source maps’ sourcesContent property. Bugfixes for destructuring and for comments in JSX. Note that these are only the changes between 2.0.0-beta5 and 2.0.0. See below for all changes since 1.x. Added --transpile flag or transpile Node API option to tell the CoffeeScript compiler to pipe its output through Babel before saving or returning it; see Transpilation. Also changed the -t short flag to refer to --transpile instead of --tokens.--transpiletranspileTranspilation-t--transpile--tokensAlways populate source maps’ sourcesContent property.sourcesContentBugfixes for destructuring and for comments in JSX.Note that these are only the changes between 2.0.0-beta5 and 2.0.0. See below for all changes since 1.x.Note that these are only the changes between 2.0.0-beta5 and 2.0.0. See below for all changes since 1.x.2.0.0-beta5    — 2017-09-02 2.0.0-beta5 — 2017-09-022017-09-02 Node 6 is now supported, and we will try to maintain that as the minimum required version for CoffeeScript 2 via the coffee command or Node API. Older versions of Node, or non-evergreen browsers, can compile via the browser compiler. The command line --output flag now allows you to specify an output filename, not just an output folder. The command line --require flag now properly handles filenames or module names that are invalid identifiers (like an NPM module with a hyphen in the name). Object.assign, output when object destructuring is used, is polyfilled using the same polyfill that Babel outputs. This means that polyfills shouldn’t be required unless support for Internet Explorer 8 or below is desired (or your own code uses a feature that requires a polyfill). See ES2015+ Output. A string or JSX interpolation that contains only a comment (\"a#{### comment ###}b\" or <div>{### comment ###}</div>) is now output (`a${/* comment */}b`) Interpolated strings (ES2015 template literals) that contain quotation marks no longer have the quotation marks escaped: `say \"${message}\"` It is now possible to chain after a function literal (for example, to define a function and then call .call on it). The results of the async tests are included in the output when you run cake test. Bugfixes for object destructuring; expansions in function parameters; generated reference variables in function parameters; chained functions after do; splats after existential operator soaks in arrays ([a?.b...]); trailing if with splat in arrays or function parameters ([a if b...]); attempting to throw an if, for, switch, while or other invalid construct. Bugfixes for syntactical edge cases: semicolons after = and other “mid-expression” tokens; spaces after ::; and scripts that begin with : or *. Bugfixes for source maps generated via the Node API; and stack trace line numbers when compiling CoffeeScript via the Node API from within a .coffee file. Node 6 is now supported, and we will try to maintain that as the minimum required version for CoffeeScript 2 via the coffee command or Node API. Older versions of Node, or non-evergreen browsers, can compile via the browser compiler.coffeebrowser compilerThe command line --output flag now allows you to specify an output filename, not just an output folder.--outputThe command line --require flag now properly handles filenames or module names that are invalid identifiers (like an NPM module with a hyphen in the name).--requireObject.assign, output when object destructuring is used, is polyfilled using the same polyfill that Babel outputs. This means that polyfills shouldn’t be required unless support for Internet Explorer 8 or below is desired (or your own code uses a feature that requires a polyfill). See ES2015+ Output.Object.assignES2015+ OutputA string or JSX interpolation that contains only a comment (\"a#{### comment ###}b\" or <div>{### comment ###}</div>) is now output (`a${/* comment */}b`)\"a#{### comment ###}b\"<div>{### comment ###}</div>`a${/* comment */}b`Interpolated strings (ES2015 template literals) that contain quotation marks no longer have the quotation marks escaped: `say \"${message}\"``say \"${message}\"`It is now possible to chain after a function literal (for example, to define a function and then call .call on it)..callThe results of the async tests are included in the output when you run cake test.cake testBugfixes for object destructuring; expansions in function parameters; generated reference variables in function parameters; chained functions after do; splats after existential operator soaks in arrays ([a?.b...]); trailing if with splat in arrays or function parameters ([a if b...]); attempting to throw an if, for, switch, while or other invalid construct.do[a?.b...]if[a if b...]throwifforswitchwhileBugfixes for syntactical edge cases: semicolons after = and other “mid-expression” tokens; spaces after ::; and scripts that begin with : or *.=:::*Bugfixes for source maps generated via the Node API; and stack trace line numbers when compiling CoffeeScript via the Node API from within a .coffee file..coffee2.0.0-beta4    — 2017-08-03 2.0.0-beta4 — 2017-08-032017-08-03 This release includes all the changes from 1.12.6 to 1.12.7. Line comments (starting with #) are now output in the generated JavaScript. Block comments (delimited by ###) are now allowed anywhere, including inline where they previously weren’t possible. This provides support for static type annotations using Flow’s comments-based syntax. Spread syntax (... for objects) is now supported in JSX tags: <div {props...} />. Argument parsing for scripts run via coffee is improved. See breaking changes. CLI: Propagate SIGINT and SIGTERM signals when node is forked. await in the REPL is now allowed without requiring a wrapper function. do super is now allowed, and other accesses of super like super.x.y or super['x'].y now work. Splat/spread syntax triple dots are now allowed on either the left or the right (so props... or ...props are both valid). Tagged template literals are recognized as callable functions. Bugfixes for object spread syntax in nested properties. Bugfixes for destructured function parameter default values. This release includes all the changes from 1.12.6 to 1.12.7.all the changes from 1.12.6 to 1.12.7Line comments (starting with #) are now output in the generated JavaScript.Line comments#Block comments (delimited by ###) are now allowed anywhere, including inline where they previously weren’t possible. This provides support for static type annotations using Flow’s comments-based syntax.Block comments###static type annotationsSpread syntax (... for objects) is now supported in JSX tags: <div {props...} />....<div {props...} />Argument parsing for scripts run via coffee is improved. See breaking changes.coffeebreaking changesCLI: Propagate SIGINT and SIGTERM signals when node is forked.SIGINTSIGTERMawait in the REPL is now allowed without requiring a wrapper function.awaitdo super is now allowed, and other accesses of super like super.x.y or super['x'].y now work.do supersupersuper.x.ysuper['x'].ySplat/spread syntax triple dots are now allowed on either the left or the right (so props... or ...props are both valid).props......propsTagged template literals are recognized as callable functions.Bugfixes for object spread syntax in nested properties.Bugfixes for destructured function parameter default values.2.0.0-beta3    — 2017-06-30 2.0.0-beta3 — 2017-06-302017-06-30 JSX is now supported. Object rest/spread properties are now supported. Bound (fat arrow) methods are once again supported in classes; though an error will be thrown if you attempt to call the method before it is bound. See breaking changes for classes. The REPL no longer warns about assigning to _. Bugfixes for destructured nested default values and issues related to chaining or continuing expressions across multiple lines. JSX is now supported.JSXObject rest/spread properties are now supported.Object rest/spread propertiesBound (fat arrow) methods are once again supported in classes; though an error will be thrown if you attempt to call the method before it is bound. See breaking changes for classes.breaking changes for classesThe REPL no longer warns about assigning to _._Bugfixes for destructured nested default values and issues related to chaining or continuing expressions across multiple lines.2.0.0-beta2    — 2017-05-16 2.0.0-beta2 — 2017-05-162017-05-16 This release includes all the changes from 1.12.5 to 1.12.6. Bound (fat arrow) methods in classes must be declared in the class constructor, after super() if the class is extending a parent class. See breaking changes for classes. All unnecessary utility helper functions have been removed, including the polyfills for indexOf and bind. The extends keyword now only works in the context of classes; it cannot be used to extend a function prototype. See breaking changes for extends. Literate CoffeeScript is now parsed entirely based on indentation, similar to the 1.x implementation; there is no longer a dependency for parsing Markdown. See breaking changes for Literate CoffeeScript parsing. JavaScript reserved words used as properties are no longer wrapped in quotes. require('coffeescript') should now work in non-Node environments such as the builds created by Webpack or Browserify. This provides a more convenient way to include the browser compiler in builds intending to run in a browser environment. Unreachable break statements are no longer added after switch cases that throw exceptions. The browser compiler is now compiled using Babili and transpiled down to Babel’s env preset (should be safe for use in all browsers in current use, not just evergreen versions). Calling functions @get or @set no longer throws an error about required parentheses. (Bare get or set, not attached to an object or @, still intentionally throws a compiler error.) If $XDG_CACHE_HOME is set, the REPL .coffee_history file is saved there. This release includes all the changes from 1.12.5 to 1.12.6.all the changes from 1.12.5 to 1.12.6Bound (fat arrow) methods in classes must be declared in the class constructor, after super() if the class is extending a parent class. See breaking changes for classes.super()breaking changes for classesAll unnecessary utility helper functions have been removed, including the polyfills for indexOf and bind.indexOfbindThe extends keyword now only works in the context of classes; it cannot be used to extend a function prototype. See breaking changes for extends.extendsbreaking changes for extendsextendsLiterate CoffeeScript is now parsed entirely based on indentation, similar to the 1.x implementation; there is no longer a dependency for parsing Markdown. See breaking changes for Literate CoffeeScript parsing.breaking changes for Literate CoffeeScript parsingJavaScript reserved words used as properties are no longer wrapped in quotes.require('coffeescript') should now work in non-Node environments such as the builds created by Webpack or Browserify. This provides a more convenient way to include the browser compiler in builds intending to run in a browser environment.require('coffeescript')Unreachable break statements are no longer added after switch cases that throw exceptions.breakswitchthrowThe browser compiler is now compiled using Babili and transpiled down to Babel’s env preset (should be safe for use in all browsers in current use, not just evergreen versions).envCalling functions @get or @set no longer throws an error about required parentheses. (Bare get or set, not attached to an object or @, still intentionally throws a compiler error.)@get@setgetset@still intentionally throws a compiler errorIf $XDG_CACHE_HOME is set, the REPL .coffee_history file is saved there.$XDG_CACHE_HOME.coffee_history2.0.0-beta1    — 2017-04-14 2.0.0-beta1 — 2017-04-142017-04-14 Initial beta release of CoffeeScript 2. No further breaking changes are anticipated. Destructured objects and arrays now output using ES2015+ syntax whenever possible. Literate CoffeeScript now has much better support for parsing Markdown, thanks to using Markdown-It to detect Markdown sections rather than just looking at indentation. Calling a function named get or set now requires parentheses, to disambiguate from the get or set keywords (which are disallowed). The compiler now requires Node 7.6+, the first version of Node to support asynchronous functions without requiring a flag. Initial beta release of CoffeeScript 2. No further breaking changes are anticipated.Destructured objects and arrays now output using ES2015+ syntax whenever possible.Literate CoffeeScript now has much better support for parsing Markdown, thanks to using Markdown-It to detect Markdown sections rather than just looking at indentation.Markdown-ItCalling a function named get or set now requires parentheses, to disambiguate from the get or set keywords (which are disallowed).getsetgetsetdisallowedThe compiler now requires Node 7.6+, the first version of Node to support asynchronous functions without requiring a flag.2.0.0-alpha1    — 2017-02-21 2.0.0-alpha1 — 2017-02-212017-02-21 Initial alpha release of CoffeeScript 2. The CoffeeScript compiler now outputs ES2015+ syntax whenever possible. See breaking changes. Classes are output using ES2015 class and extends keywords. Added support for async/await. Bound (arrow) functions now output as => functions. Function parameters with default values now use ES2015 default values syntax. Splat function parameters now use ES2015 spread syntax. Computed properties now use ES2015 syntax. Interpolated strings (template literals) now use ES2015 backtick syntax. Improved support for recognizing Markdown in Literate CoffeeScript files. Mixing tabs and spaces in indentation is now disallowed. Browser compiler is now minified using the Google Closure Compiler (JavaScript version). Node 7+ required for CoffeeScript 2. Initial alpha release of CoffeeScript 2. The CoffeeScript compiler now outputs ES2015+ syntax whenever possible. See breaking changes.breaking changesClasses are output using ES2015 class and extends keywords.classextendsAdded support for async/await.asyncawaitBound (arrow) functions now output as => functions.=>Function parameters with default values now use ES2015 default values syntax.Splat function parameters now use ES2015 spread syntax.Computed properties now use ES2015 syntax.Interpolated strings (template literals) now use ES2015 backtick syntax.Improved support for recognizing Markdown in Literate CoffeeScript files.Mixing tabs and spaces in indentation is now disallowed.Browser compiler is now minified using the Google Closure Compiler (JavaScript version).Node 7+ required for CoffeeScript 2.1.12.7    — 2017-07-16 1.12.7 — 2017-07-162017-07-16 Fix regressions in 1.12.6 related to chained function calls and indented return and throw arguments. The REPL no longer warns about assigning to _. Fix regressions in 1.12.6 related to chained function calls and indented return and throw arguments.returnthrowThe REPL no longer warns about assigning to _._1.12.6    — 2017-05-15 1.12.6 — 2017-05-152017-05-15 The return and export keywords can now accept implicit objects (defined by indentation, without needing braces). Support Unicode code point escapes (e.g. \\u{1F4A9}). The coffee command now first looks to see if CoffeeScript is installed under node_modules in the current folder, and executes the coffee binary there if so; or otherwise it runs the globally installed one. This allows you to have one version of CoffeeScript installed globally and a different one installed locally for a particular project. (Likewise for the cake command.) Bugfixes for chained function calls not closing implicit objects or ternaries. Bugfixes for incorrect code generated by the ? operator within a termary if statement. Fixed some tests, and failing tests now result in a nonzero exit code. The return and export keywords can now accept implicit objects (defined by indentation, without needing braces).returnexportSupport Unicode code point escapes (e.g. \\u{1F4A9}).\\u{1F4A9}The coffee command now first looks to see if CoffeeScript is installed under node_modules in the current folder, and executes the coffee binary there if so; or otherwise it runs the globally installed one. This allows you to have one version of CoffeeScript installed globally and a different one installed locally for a particular project. (Likewise for the cake command.)coffeenode_modulescoffeecakeBugfixes for chained function calls not closing implicit objects or ternaries.Bugfixes for incorrect code generated by the ? operator within a termary if statement.?ifFixed some tests, and failing tests now result in a nonzero exit code.1.12.5    — 2017-04-10 1.12.5 — 2017-04-102017-04-10 Better handling of default, from, as and * within import and export statements. You can now import or export a member named default and the compiler won’t interpret it as the default keyword. Fixed a bug where invalid octal escape sequences weren’t throwing errors in the compiler. Better handling of default, from, as and * within import and export statements. You can now import or export a member named default and the compiler won’t interpret it as the default keyword.defaultfromas*importexportdefaultdefaultFixed a bug where invalid octal escape sequences weren’t throwing errors in the compiler.1.12.4    — 2017-02-18 1.12.4 — 2017-02-182017-02-18 The cake commands have been updated, with new watch options for most tasks. Clone the CoffeeScript repo and run cake at the root of the repo to see the options. Fixed a bug where exporting a referenced variable was preventing the variable from being declared. Fixed a bug where the coffee command wasn’t working for a .litcoffee file. Bugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools. The cake commands have been updated, with new watch options for most tasks. Clone the CoffeeScript repo and run cake at the root of the repo to see the options.cakewatchCoffeeScript repocakeFixed a bug where exporting a referenced variable was preventing the variable from being declared.exportFixed a bug where the coffee command wasn’t working for a .litcoffee file.coffee.litcoffeeBugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools.1.12.3    — 2017-01-24 1.12.3 — 2017-01-242017-01-24 @ values can now be used as indices in for expressions. This loosens the compilation of for expressions to allow the index variable to be an @ value, e.g. do @visit for @node, @index in nodes. Within @visit, the index of the current node (@node) would be available as @index. CoffeeScript’s patched Error.prepareStackTrace has been restored, with some revisions that should prevent the erroneous exceptions that were making life difficult for some downstream projects. This fixes the incorrect line numbers in stack traces since 1.12.2. The //= operator’s output now wraps parentheses around the right operand, like the other assignment operators. @ values can now be used as indices in for expressions. This loosens the compilation of for expressions to allow the index variable to be an @ value, e.g. do @visit for @node, @index in nodes. Within @visit, the index of the current node (@node) would be available as @index.@forfor@do @visit for @node, @index in nodes@visit@node@indexCoffeeScript’s patched Error.prepareStackTrace has been restored, with some revisions that should prevent the erroneous exceptions that were making life difficult for some downstream projects. This fixes the incorrect line numbers in stack traces since 1.12.2.Error.prepareStackTraceThe //= operator’s output now wraps parentheses around the right operand, like the other assignment operators.//=1.12.2    — 2016-12-16 1.12.2 — 2016-12-162016-12-16 The browser compiler can once again be built unminified via MINIFY=false cake build:browser. The error-prone patched version of Error.prepareStackTrace has been removed. Command completion in the REPL (pressing tab to get suggestions) has been fixed for Node 6.9.1+. The browser-based tests now include all the tests as the Node-based version. The browser compiler can once again be built unminified via MINIFY=false cake build:browser.MINIFY=false cake build:browserThe error-prone patched version of Error.prepareStackTrace has been removed.Error.prepareStackTraceCommand completion in the REPL (pressing tab to get suggestions) has been fixed for Node 6.9.1+.The browser-based tests now include all the tests as the Node-based version.browser-based tests1.12.1    — 2016-12-07 1.12.1 — 2016-12-072016-12-07 You can now import a module member named default, e.g. import { default } from 'lib'. Though like in ES2015, you cannot import an entire module and name it default (so import default from 'lib' is not allowed). Fix regression where from as a variable name was breaking for loop declarations. For the record, from is not a reserved word in CoffeeScript; you may use it for variable names. from behaves like a keyword within the context of import and export statements, and in the declaration of a for loop; though you should also be able to use variables named from in those contexts, and the compiler should be able to tell the difference. You can now import a module member named default, e.g. import { default } from 'lib'. Though like in ES2015, you cannot import an entire module and name it default (so import default from 'lib' is not allowed).defaultimport { default } from 'lib'defaultimport default from 'lib'Fix regression where from as a variable name was breaking for loop declarations. For the record, from is not a reserved word in CoffeeScript; you may use it for variable names. from behaves like a keyword within the context of import and export statements, and in the declaration of a for loop; though you should also be able to use variables named from in those contexts, and the compiler should be able to tell the difference.fromforfromfromimportexportforfrom1.12.0    — 2016-12-04 1.12.0 — 2016-12-042016-12-04 CoffeeScript now supports ES2015 tagged template literals. Note that using tagged template literals in your code makes you responsible for ensuring that either your runtime supports tagged template literals or that you transpile the output JavaScript further to a version your target runtime(s) support. CoffeeScript now provides a for…from syntax for outputting ES2015 for…of. (Sorry they couldn’t match, but we came up with for…of first for something else.) This allows iterating over generators or any other iterable object. Note that using for…from in your code makes you responsible for ensuring that either your runtime supports for…of or that you transpile the output JavaScript further to a version your target runtime(s) support. Triple backticks (```​) allow the creation of embedded JavaScript blocks where escaping single backticks is not required, which should improve interoperability with ES2015 template literals and with Markdown. Within single-backtick embedded JavaScript, backticks can now be escaped via \\`​. The browser tests now run in the browser again, and are accessible here if you would like to test your browser. CoffeeScript-only keywords in ES2015 imports and exports are now ignored. The compiler now throws an error on trying to export an anonymous class. Bugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools. CoffeeScript now supports ES2015 tagged template literals. Note that using tagged template literals in your code makes you responsible for ensuring that either your runtime supports tagged template literals or that you transpile the output JavaScript further to a version your target runtime(s) support.tagged template literalsCoffeeScript now provides a for…from syntax for outputting ES2015 for…of. (Sorry they couldn’t match, but we came up with for…of first for something else.) This allows iterating over generators or any other iterable object. Note that using for…from in your code makes you responsible for ensuring that either your runtime supports for…of or that you transpile the output JavaScript further to a version your target runtime(s) support.for…fromfor…fromfor…offor…offor…offor…fromfor…ofTriple backticks (```​) allow the creation of embedded JavaScript blocks where escaping single backticks is not required, which should improve interoperability with ES2015 template literals and with Markdown.```​Within single-backtick embedded JavaScript, backticks can now be escaped via \\`​.\\`​The browser tests now run in the browser again, and are accessible here if you would like to test your browser.hereCoffeeScript-only keywords in ES2015 imports and exports are now ignored.importexportThe compiler now throws an error on trying to export an anonymous class.Bugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools.1.11.1    — 2016-10-02 1.11.1 — 2016-10-022016-10-02 Bugfix for shorthand object syntax after interpolated keys. Bugfix for indentation-stripping in \"\"\" strings. Bugfix for not being able to use the name “arguments” for a prototype property of class. Correctly compile large hexadecimal numbers literals to 2e308 (just like all other large number literals do). Bugfix for shorthand object syntax after interpolated keys.Bugfix for indentation-stripping in \"\"\" strings.\"\"\"Bugfix for not being able to use the name “arguments” for a prototype property of class.Correctly compile large hexadecimal numbers literals to 2e308 (just like all other large number literals do).2e3081.11.0    — 2016-09-24 1.11.0 — 2016-09-242016-09-24 CoffeeScript now supports ES2015 import and export syntax. Added the -M, --inline-map flag to the compiler, allowing you embed the source map directly into the output JavaScript, rather than as a separate file. A bunch of fixes for yield: yield return can no longer mistakenly be used as an expression. yield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present. &&=, ||=, and= and or= no longer accidentally allow a space before the equals sign. Improved several error messages. Just like undefined compiles to void 0, NaN now compiles into 0/0 and Infinity into 2e308. Bugfix for renamed destructured parameters with defaults. ({a: b = 1}) -> no longer crashes the compiler. Improved the internal representation of a CoffeeScript program. This is only noticeable to tools that use CoffeeScript.tokens or CoffeeScript.nodes. Such tools need to update to take account for changed or added tokens and nodes. Several minor bug fixes, including: The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks. Unassignable parameter destructuring no longer crashes the compiler. Source maps are now used correctly for errors thrown from .coffee.md files. coffee -e 'throw null' no longer crashes. The REPL no longer crashes when using .exit to exit it. Invalid JavaScript is no longer output when lots of for loops are used in the same scope. A unicode issue when using stdin with the CLI. CoffeeScript now supports ES2015 import and export syntax.import and export syntaximportexportAdded the -M, --inline-map flag to the compiler, allowing you embed the source map directly into the output JavaScript, rather than as a separate file.-M, --inline-mapA bunch of fixes for yield: yield return can no longer mistakenly be used as an expression. yield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present. yield yield return can no longer mistakenly be used as an expression. yield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present. yield return can no longer mistakenly be used as an expression.yield returnyield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 yieldreturnyield undefinedyieldreturndoubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present.yield&&=, ||=, and= and or= no longer accidentally allow a space before the equals sign.&&=||=and=or=Improved several error messages.Just like undefined compiles to void 0, NaN now compiles into 0/0 and Infinity into 2e308.undefinedvoid 0NaN0/0Infinity2e308Bugfix for renamed destructured parameters with defaults. ({a: b = 1}) -> no longer crashes the compiler.({a: b = 1}) ->Improved the internal representation of a CoffeeScript program. This is only noticeable to tools that use CoffeeScript.tokens or CoffeeScript.nodes. Such tools need to update to take account for changed or added tokens and nodes.CoffeeScript.tokensCoffeeScript.nodesSeveral minor bug fixes, including: The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks. Unassignable parameter destructuring no longer crashes the compiler. Source maps are now used correctly for errors thrown from .coffee.md files. coffee -e 'throw null' no longer crashes. The REPL no longer crashes when using .exit to exit it. Invalid JavaScript is no longer output when lots of for loops are used in the same scope. A unicode issue when using stdin with the CLI. The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks. Unassignable parameter destructuring no longer crashes the compiler. Source maps are now used correctly for errors thrown from .coffee.md files. coffee -e 'throw null' no longer crashes. The REPL no longer crashes when using .exit to exit it. Invalid JavaScript is no longer output when lots of for loops are used in the same scope. A unicode issue when using stdin with the CLI. The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks.catchundefinedcatchtryUnassignable parameter destructuring no longer crashes the compiler.Source maps are now used correctly for errors thrown from .coffee.md files.coffee -e 'throw null' no longer crashes.coffee -e 'throw null'The REPL no longer crashes when using .exit to exit it..exitInvalid JavaScript is no longer output when lots of for loops are used in the same scope.forA unicode issue when using stdin with the CLI.1.10.0    — 2015-09-03 1.10.0 — 2015-09-032015-09-03 CoffeeScript now supports ES2015-style destructuring defaults. (offsetHeight: height) -> no longer compiles. That syntax was accidental and partly broken. Use ({offsetHeight: height}) -> instead. Object destructuring always requires braces. Several minor bug fixes, including: A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier. A problem with multiple JS contexts in the jest test framework. An error in io.js where strict mode is set on internal modules. A variable name clash for the caught error in catch blocks. CoffeeScript now supports ES2015-style destructuring defaults.(offsetHeight: height) -> no longer compiles. That syntax was accidental and partly broken. Use ({offsetHeight: height}) -> instead. Object destructuring always requires braces.(offsetHeight: height) ->({offsetHeight: height}) ->Several minor bug fixes, including: A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier. A problem with multiple JS contexts in the jest test framework. An error in io.js where strict mode is set on internal modules. A variable name clash for the caught error in catch blocks. A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier. A problem with multiple JS contexts in the jest test framework. An error in io.js where strict mode is set on internal modules. A variable name clash for the caught error in catch blocks. A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier.A problem with multiple JS contexts in the jest test framework.An error in io.js where strict mode is set on internal modules.A variable name clash for the caught error in catch blocks.catch1.9.3    — 2015-05-27 1.9.3 — 2015-05-272015-05-27 Bugfix for interpolation in the first key of an object literal in an implicit call. Fixed broken error messages in the REPL, as well as a few minor bugs with the REPL. Fixed source mappings for tokens at the beginning of lines when compiling with the --bare option. This has the nice side effect of generating smaller source maps. Slight formatting improvement of compiled block comments. Better error messages for on, off, yes and no. Bugfix for interpolation in the first key of an object literal in an implicit call.Fixed broken error messages in the REPL, as well as a few minor bugs with the REPL.Fixed source mappings for tokens at the beginning of lines when compiling with the --bare option. This has the nice side effect of generating smaller source maps.--bareSlight formatting improvement of compiled block comments.Better error messages for on, off, yes and no.onoffyesno1.9.2    — 2015-04-15 1.9.2 — 2015-04-152015-04-15 Fixed a watch mode error introduced in 1.9.1 when compiling multiple files with the same filename. Bugfix for yield around expressions containing this. Added a Ruby-style -r option to the REPL, which allows requiring a module before execution with --eval or --interactive. In <script type=\"text/coffeescript\"> tags, to avoid possible duplicate browser requests for .coffee files, you can now use the data-src attribute instead of src. Minor bug fixes for IE8, strict ES5 regular expressions and Browserify. Fixed a watch mode error introduced in 1.9.1 when compiling multiple files with the same filename.watchBugfix for yield around expressions containing this.yieldthisAdded a Ruby-style -r option to the REPL, which allows requiring a module before execution with --eval or --interactive.-r--eval--interactiveIn <script type=\"text/coffeescript\"> tags, to avoid possible duplicate browser requests for .coffee files, you can now use the data-src attribute instead of src.<script type=\"text/coffeescript\">data-srcsrcMinor bug fixes for IE8, strict ES5 regular expressions and Browserify.1.9.1    — 2015-02-18 1.9.1 — 2015-02-182015-02-18 Interpolation now works in object literal keys (again). You can use this to dynamically name properties. Internal compiler variable names no longer start with underscores. This makes the generated JavaScript a bit prettier, and also fixes an issue with the completely broken and ungodly way that AngularJS “parses” function arguments. Fixed a few yield-related edge cases with yield return and yield throw. Minor bug fixes and various improvements to compiler error messages. Interpolation now works in object literal keys (again). You can use this to dynamically name properties.Internal compiler variable names no longer start with underscores. This makes the generated JavaScript a bit prettier, and also fixes an issue with the completely broken and ungodly way that AngularJS “parses” function arguments.Fixed a few yield-related edge cases with yield return and yield throw.yieldyield returnyield throwMinor bug fixes and various improvements to compiler error messages.1.9.0    — 2015-01-29 1.9.0 — 2015-01-292015-01-29 CoffeeScript now supports ES2015 generators. A generator is simply a function that yields. More robust parsing and improved error messages for strings and regexes — especially with respect to interpolation. Changed strategy for the generation of internal compiler variable names. Note that this means that @example function parameters are no longer available as naked example variables within the function body. Fixed REPL compatibility with latest versions of Node and Io.js. Various minor bug fixes. CoffeeScript now supports ES2015 generators. A generator is simply a function that yields.yieldMore robust parsing and improved error messages for strings and regexes — especially with respect to interpolation.Changed strategy for the generation of internal compiler variable names. Note that this means that @example function parameters are no longer available as naked example variables within the function body.@exampleexampleFixed REPL compatibility with latest versions of Node and Io.js.Various minor bug fixes.1.8.0    — 2014-08-26 1.8.0 — 2014-08-262014-08-26 The --join option of the CLI is now deprecated. Source maps now use .js.map as file extension, instead of just .map. The CLI now exits with the exit code 1 when it fails to write a file to disk. The compiler no longer crashes on unterminated, single-quoted strings. Fixed location data for string interpolations, which made source maps out of sync. The error marker in error messages is now correctly positioned if the code is indented with tabs. Fixed a slight formatting error in CoffeeScript’s source map-patched stack traces. The %% operator now coerces its right operand only once. It is now possible to require CoffeeScript files from Cakefiles without having to register the compiler first. The CoffeeScript REPL is now exported and can be required using require 'coffeescript/repl'. Fixes for the REPL in Node 0.11. The --join option of the CLI is now deprecated.--joinSource maps now use .js.map as file extension, instead of just .map..js.map.mapThe CLI now exits with the exit code 1 when it fails to write a file to disk.The compiler no longer crashes on unterminated, single-quoted strings.Fixed location data for string interpolations, which made source maps out of sync.The error marker in error messages is now correctly positioned if the code is indented with tabs.Fixed a slight formatting error in CoffeeScript’s source map-patched stack traces.The %% operator now coerces its right operand only once.%%It is now possible to require CoffeeScript files from Cakefiles without having to register the compiler first.The CoffeeScript REPL is now exported and can be required using require 'coffeescript/repl'.require 'coffeescript/repl'Fixes for the REPL in Node 0.11.1.7.1    — 2014-01-29 1.7.1 — 2014-01-292014-01-29 Fixed a typo that broke node module lookup when running a script directly with the coffee binary. Fixed a typo that broke node module lookup when running a script directly with the coffee binary.coffee1.7.0    — 2014-01-28 1.7.0 — 2014-01-282014-01-28 When requiring CoffeeScript files in Node you must now explicitly register the compiler. This can be done with require 'coffeescript/register' or CoffeeScript.register(). Also for configuration such as Mocha’s, use coffeescript/register. Improved error messages, source maps and stack traces. Source maps now use the updated //# syntax. Leading . now closes all open calls, allowing for simpler chaining syntax. Added **, // and %% operators and ... expansion in parameter lists and destructuring expressions. Multiline strings are now joined by a single space and ignore all indentation. A backslash at the end of a line can denote the amount of whitespace between lines, in both strings and heredocs. Backslashes correctly escape whitespace in block regexes. Closing brackets can now be indented and therefore no longer cause unexpected error. Several breaking compilation fixes. Non-callable literals (strings, numbers etc.) don’t compile in a call now and multiple postfix conditionals compile properly. Postfix conditionals and loops always bind object literals. Conditional assignment compiles properly in subexpressions. super is disallowed outside of methods and works correctly inside for loops. Formatting of compiled block comments has been improved. No more -p folders on Windows. The options object passed to CoffeeScript is no longer mutated. When requiring CoffeeScript files in Node you must now explicitly register the compiler. This can be done with require 'coffeescript/register' or CoffeeScript.register(). Also for configuration such as Mocha’s, use coffeescript/register.require 'coffeescript/register'CoffeeScript.register()coffeescript/registerImproved error messages, source maps and stack traces. Source maps now use the updated //# syntax.//#Leading . now closes all open calls, allowing for simpler chaining syntax..Added **, // and %% operators and ... expansion in parameter lists and destructuring expressions.**//%%...Multiline strings are now joined by a single space and ignore all indentation. A backslash at the end of a line can denote the amount of whitespace between lines, in both strings and heredocs. Backslashes correctly escape whitespace in block regexes.Closing brackets can now be indented and therefore no longer cause unexpected error.Several breaking compilation fixes. Non-callable literals (strings, numbers etc.) don’t compile in a call now and multiple postfix conditionals compile properly. Postfix conditionals and loops always bind object literals. Conditional assignment compiles properly in subexpressions. super is disallowed outside of methods and works correctly inside for loops.superforFormatting of compiled block comments has been improved.No more -p folders on Windows.-pThe options object passed to CoffeeScript is no longer mutated.options1.6.3    — 2013-06-02 1.6.3 — 2013-06-022013-06-02 The CoffeeScript REPL now remembers your history between sessions. Just like a proper REPL should. You can now use require in Node to load .coffee.md Literate CoffeeScript files. In the browser, text/literate-coffeescript script tags. The old coffee --lint command has been removed. It was useful while originally working on the compiler, but has been surpassed by JSHint. You may now use -l to pass literate files in over stdio. Bugfixes for Windows path separators, catch without naming the error, and executable-class-bodies-with- prototypal-property-attachment. The CoffeeScript REPL now remembers your history between sessions. Just like a proper REPL should.You can now use require in Node to load .coffee.md Literate CoffeeScript files. In the browser, text/literate-coffeescript script tags.require.coffee.mdtext/literate-coffeescriptThe old coffee --lint command has been removed. It was useful while originally working on the compiler, but has been surpassed by JSHint. You may now use -l to pass literate files in over stdio.coffee --lint-lstdioBugfixes for Windows path separators, catch without naming the error, and executable-class-bodies-with- prototypal-property-attachment.catch1.6.2    — 2013-03-18 1.6.2 — 2013-03-182013-03-18 Source maps have been used to provide automatic line-mapping when running CoffeeScript directly via the coffee command, and for automatic line-mapping when running CoffeeScript directly in the browser. Also, to provide better error messages for semantic errors thrown by the compiler — with colors, even. Improved support for mixed literate/vanilla-style CoffeeScript projects, and generating source maps for both at the same time. Fixes for 1.6.x regressions with overriding inherited bound functions, and for Windows file path management. The coffee command can now correctly fork() both .coffee and .js files. (Requires Node.js 0.9+) Source maps have been used to provide automatic line-mapping when running CoffeeScript directly via the coffee command, and for automatic line-mapping when running CoffeeScript directly in the browser. Also, to provide better error messages for semantic errors thrown by the compiler — with colors, even.coffeewith colors, evenImproved support for mixed literate/vanilla-style CoffeeScript projects, and generating source maps for both at the same time.Fixes for 1.6.x regressions with overriding inherited bound functions, and for Windows file path management.1.6.xThe coffee command can now correctly fork() both .coffee and .js files. (Requires Node.js 0.9+)coffeefork().coffee.js1.6.1    — 2013-03-05 1.6.1 — 2013-03-052013-03-05 First release of source maps. Pass the --map flag to the compiler, and off you go. Direct all your thanks over to Jason Walton. Fixed a 1.5.0 regression with multiple implicit calls against an indented implicit object. Combinations of implicit function calls and implicit objects should generally be parsed better now — but it still isn’t good style to nest them too heavily. .coffee.md is now also supported as a Literate CoffeeScript file extension, for existing tooling. .litcoffee remains the canonical one. Several minor fixes surrounding member properties, bound methods and super in class declarations. First release of source maps. Pass the --map flag to the compiler, and off you go. Direct all your thanks over to Jason Walton.source maps--mapJason WaltonFixed a 1.5.0 regression with multiple implicit calls against an indented implicit object. Combinations of implicit function calls and implicit objects should generally be parsed better now — but it still isn’t good style to nest them too heavily.style.coffee.md is now also supported as a Literate CoffeeScript file extension, for existing tooling. .litcoffee remains the canonical one..coffee.md.litcoffeeSeveral minor fixes surrounding member properties, bound methods and super in class declarations.super1.5.0    — 2013-02-25 1.5.0 — 2013-02-252013-02-25 First release of Literate CoffeeScript. The CoffeeScript REPL is now based on the Node.js REPL, and should work better and more familiarly. Returning explicit values from constructors is now forbidden. If you want to return an arbitrary value, use a function, not a constructor. You can now loop over an array backwards, without having to manually deal with the indexes: for item in list by -1 Source locations are now preserved in the CoffeeScript AST, although source maps are not yet being emitted. First release of Literate CoffeeScript.Literate CoffeeScriptThe CoffeeScript REPL is now based on the Node.js REPL, and should work better and more familiarly.Returning explicit values from constructors is now forbidden. If you want to return an arbitrary value, use a function, not a constructor.You can now loop over an array backwards, without having to manually deal with the indexes: for item in list by -1for item in list by -1Source locations are now preserved in the CoffeeScript AST, although source maps are not yet being emitted.1.4.0    — 2012-10-23 1.4.0 — 2012-10-232012-10-23 The CoffeeScript compiler now strips Microsoft’s UTF-8 BOM if it exists, allowing you to compile BOM-borked source files. Fix Node/compiler deprecation warnings by removing registerExtension, and moving from path.exists to fs.exists. Small tweaks to splat compilation, backticks, slicing, and the error for duplicate keys in object literals. The CoffeeScript compiler now strips Microsoft’s UTF-8 BOM if it exists, allowing you to compile BOM-borked source files.Fix Node/compiler deprecation warnings by removing registerExtension, and moving from path.exists to fs.exists.registerExtensionpath.existsfs.existsSmall tweaks to splat compilation, backticks, slicing, and the error for duplicate keys in object literals.1.3.3    — 2012-05-15 1.3.3 — 2012-05-152012-05-15 Due to the new semantics of JavaScript’s strict mode, CoffeeScript no longer guarantees that constructor functions have names in all runtimes. See #2052 for discussion. Inside of a nested function inside of an instance method, it’s now possible to call super more reliably (walks recursively up). Named loop variables no longer have different scoping heuristics than other local variables. (Reverts #643) Fix for splats nested within the LHS of destructuring assignment. Corrections to our compile time strict mode forbidding of octal literals. Due to the new semantics of JavaScript’s strict mode, CoffeeScript no longer guarantees that constructor functions have names in all runtimes. See #2052 for discussion.#2052Inside of a nested function inside of an instance method, it’s now possible to call super more reliably (walks recursively up).superNamed loop variables no longer have different scoping heuristics than other local variables. (Reverts #643)Fix for splats nested within the LHS of destructuring assignment.Corrections to our compile time strict mode forbidding of octal literals.1.3.1    — 2012-04-10 1.3.1 — 2012-04-102012-04-10 CoffeeScript now enforces all of JavaScript’s Strict Mode early syntax errors at compile time. This includes old-style octal literals, duplicate property names in object literals, duplicate parameters in a function definition, deleting naked variables, setting the value of eval or arguments, and more. See a full discussion at #1547. The REPL now has a handy new multi-line mode for entering large blocks of code. It’s useful when copy-and-pasting examples into the REPL. Enter multi-line mode with Ctrl-V. You may also now pipe input directly into the REPL. CoffeeScript now prints a Generated by CoffeeScript VERSION header at the top of each compiled file. Conditional assignment of previously undefined variables a or= b is now considered a syntax error. A tweak to the semantics of do, which can now be used to more easily simulate a namespace: do (x = 1, y = 2) -> … Loop indices are now mutable within a loop iteration, and immutable between them. Both endpoints of a slice are now allowed to be omitted for consistency, effectively creating a shallow copy of the list. Additional tweaks and improvements to coffee --watch under Node’s “new” file watching API. Watch will now beep by default if you introduce a syntax error into a watched script. We also now ignore hidden directories by default when watching recursively. CoffeeScript now enforces all of JavaScript’s Strict Mode early syntax errors at compile time. This includes old-style octal literals, duplicate property names in object literals, duplicate parameters in a function definition, deleting naked variables, setting the value of eval or arguments, and more. See a full discussion at #1547.Strict Modeevalarguments#1547The REPL now has a handy new multi-line mode for entering large blocks of code. It’s useful when copy-and-pasting examples into the REPL. Enter multi-line mode with Ctrl-V. You may also now pipe input directly into the REPL.Ctrl-VCoffeeScript now prints a Generated by CoffeeScript VERSION header at the top of each compiled file.Generated by CoffeeScript VERSIONConditional assignment of previously undefined variables a or= b is now considered a syntax error.a or= bA tweak to the semantics of do, which can now be used to more easily simulate a namespace: do (x = 1, y = 2) -> …dodo (x = 1, y = 2) -> …Loop indices are now mutable within a loop iteration, and immutable between them.Both endpoints of a slice are now allowed to be omitted for consistency, effectively creating a shallow copy of the list.Additional tweaks and improvements to coffee --watch under Node’s “new” file watching API. Watch will now beep by default if you introduce a syntax error into a watched script. We also now ignore hidden directories by default when watching recursively.coffee --watch1.2.0    — 2011-12-18 1.2.0 — 2011-12-182011-12-18 Multiple improvements to coffee --watch and --join. You may now use both together, as well as add and remove files and directories within a --watch’d folder. The throw statement can now be used as part of an expression. Block comments at the top of the file will now appear outside of the safety closure wrapper. Fixed a number of minor 1.1.3 regressions having to do with trailing operators and unfinished lines, and a more major 1.1.3 regression that caused bound functions within bound class functions to have the incorrect this. Multiple improvements to coffee --watch and --join. You may now use both together, as well as add and remove files and directories within a --watch’d folder.coffee --watch--join--watchThe throw statement can now be used as part of an expression.throwBlock comments at the top of the file will now appear outside of the safety closure wrapper.Fixed a number of minor 1.1.3 regressions having to do with trailing operators and unfinished lines, and a more major 1.1.3 regression that caused bound functions within bound class functions to have the incorrect this.withinthis1.1.3    — 2011-11-08 1.1.3 — 2011-11-082011-11-08 Ahh, whitespace. CoffeeScript’s compiled JS now tries to space things out and keep it readable, as you can see in the examples on this page. You can now call super in class level methods in class bodies, and bound class methods now preserve their correct context. JavaScript has always supported octal numbers 010 is 8, and hexadecimal numbers 0xf is 15, but CoffeeScript now also supports binary numbers: 0b10 is 2. The CoffeeScript module has been nested under a subdirectory to make it easier to require individual components separately, without having to use npm. For example, after adding the CoffeeScript folder to your path: require('coffeescript/lexer') There’s a new “link” feature in Try CoffeeScript on this webpage. Use it to get a shareable permalink for your example script. The coffee --watch feature now only works on Node.js 0.6.0 and higher, but now also works properly on Windows. Lots of small bug fixes from @michaelficarra, @geraldalewis, @satyr, and @trevorburnham. Ahh, whitespace. CoffeeScript’s compiled JS now tries to space things out and keep it readable, as you can see in the examples on this page.You can now call super in class level methods in class bodies, and bound class methods now preserve their correct context.superJavaScript has always supported octal numbers 010 is 8, and hexadecimal numbers 0xf is 15, but CoffeeScript now also supports binary numbers: 0b10 is 2.010 is 80xf is 150b10 is 2The CoffeeScript module has been nested under a subdirectory to make it easier to require individual components separately, without having to use npm. For example, after adding the CoffeeScript folder to your path: require('coffeescript/lexer')requirenpmrequire('coffeescript/lexer')There’s a new “link” feature in Try CoffeeScript on this webpage. Use it to get a shareable permalink for your example script.The coffee --watch feature now only works on Node.js 0.6.0 and higher, but now also works properly on Windows.coffee --watchLots of small bug fixes from @michaelficarra, @geraldalewis, @satyr, and @trevorburnham.@michaelficarra@michaelficarra@geraldalewis@geraldalewis@satyr@satyr@trevorburnham@trevorburnham1.1.2    — 2011-08-04 1.1.2 — 2011-08-042011-08-04Fixes for block comment formatting, ?= compilation, implicit calls against control structures, implicit invocation of a try/catch block, variadic arguments leaking from local scope, line numbers in syntax errors following heregexes, property access on parenthesized number literals, bound class methods and super with reserved names, a REPL overhaul, consecutive compiled semicolons, block comments in implicitly called objects, and a Chrome bug.?=1.1.1    — 2011-05-10 1.1.1 — 2011-05-102011-05-10Bugfix release for classes with external constructor functions, see issue #1182.1.1.0    — 2011-05-01 1.1.0 — 2011-05-012011-05-01When running via the coffee executable, process.argv and friends now report coffee instead of node. Better compatibility with Node.js 0.4.x module lookup changes. The output in the REPL is now colorized, like Node’s is. Giving your concatenated CoffeeScripts a name when using --join is now mandatory. Fix for lexing compound division /= as a regex accidentally. All text/coffeescript tags should now execute in the order they’re included. Fixed an issue with extended subclasses using external constructor functions. Fixed an edge-case infinite loop in addImplicitParentheses. Fixed exponential slowdown with long chains of function calls. Globals no longer leak into the CoffeeScript REPL. Splatted parameters are declared local to the function.coffeeprocess.argvcoffeenodeNode.js 0.4.x--join/=text/coffeescriptaddImplicitParentheses1.0.1    — 2011-01-31 1.0.1 — 2011-01-312011-01-31Fixed a lexer bug with Unicode identifiers. Updated REPL for compatibility with Node.js 0.3.7. Fixed requiring relative paths in the REPL. Trailing return and return undefined are now optimized away. Stopped requiring the core Node.js util module for back-compatibility with Node.js 0.2.5. Fixed a case where a conditional return would cause fallthrough in a switch statement. Optimized empty objects in destructuring assignment.returnreturn undefinedutilreturnswitch1.0.0    — 2010-12-24 1.0.0 — 2010-12-242010-12-24CoffeeScript loops no longer try to preserve block scope when functions are being generated within the loop body. Instead, you can use the do keyword to create a convenient closure wrapper. Added a --nodejs flag for passing through options directly to the node executable. Better behavior around the use of pure statements within expressions. Fixed inclusive slicing through -1, for all browsers, and splicing with arbitrary expressions as endpoints.do--nodejsnode-10.9.6    — 2010-12-06 0.9.6 — 2010-12-062010-12-06The REPL now properly formats stacktraces, and stays alive through asynchronous exceptions. Using --watch now prints timestamps as files are compiled. Fixed some accidentally-leaking variables within plucked closure-loops. Constructors now maintain their declaration location within a class body. Dynamic object keys were removed. Nested classes are now supported. Fixes execution context for naked splatted functions. Bugfix for inversion of chained comparisons. Chained class instantiation now works properly with splats.--watch0.9.5    — 2010-11-21 0.9.5 — 2010-11-212010-11-210.9.5 should be considered the first release candidate for CoffeeScript 1.0. There have been a large number of internal changes since the previous release, many contributed from satyr’s Coco dialect of CoffeeScript. Heregexes (extended regexes) were added. Functions can now have default arguments. Class bodies are now executable code. Improved syntax errors for invalid CoffeeScript. undefined now works like null, and cannot be assigned a new value. There was a precedence change with respect to single-line comprehensions: result = i for i in list used to parse as result = (i for i in list) by default … it now parses as (result = i) for i in list.satyrCocoundefinednullresult = i for i in listresult = (i for i in list)(result = i) for i in list0.9.4    — 2010-09-21 0.9.4 — 2010-09-212010-09-21CoffeeScript now uses appropriately-named temporary variables, and recycles their references after use. Added require.extensions support for Node.js 0.3. Loading CoffeeScript in the browser now adds just a single CoffeeScript object to global scope. Fixes for implicit object and block comment edge cases.require.extensionsNode.js 0.3CoffeeScript0.9.3    — 2010-09-16 0.9.3 — 2010-09-162010-09-16CoffeeScript switch statements now compile into JS switch statements — they previously compiled into if/else chains for JavaScript 1.3 compatibility. Soaking a function invocation is now supported. Users of the RubyMine editor should now be able to use --watch mode.switchswitchif/else--watch0.9.2    — 2010-08-23 0.9.2 — 2010-08-232010-08-23Specifying the start and end of a range literal is now optional, eg. array[3..]. You can now say a not instanceof b. Fixed important bugs with nested significant and non-significant indentation (Issue #637). Added a --require flag that allows you to hook into the coffee command. Added a custom jsl.conf file for our preferred JavaScriptLint setup. Sped up Jison grammar compilation time by flattening rules for operations. Block comments can now be used with JavaScript-minifier-friendly syntax. Added JavaScript’s compound assignment bitwise operators. Bugfixes to implicit object literals with leading number and string keys, as the subject of implicit calls, and as part of compound assignment.array[3..]a not instanceof b--requirecoffeejsl.conf0.9.1    — 2010-08-11 0.9.1 — 2010-08-112010-08-11Bugfix release for 0.9.1. Greatly improves the handling of mixed implicit objects, implicit function calls, and implicit indentation. String and regex interpolation is now strictly #{ … } (Ruby style). The compiler now takes a --require flag, which specifies scripts to run before compilation.0.9.1#{ … }--require0.9.0    — 2010-08-04 0.9.0 — 2010-08-042010-08-04The CoffeeScript 0.9 series is considered to be a release candidate for 1.0; let’s give her a shakedown cruise. 0.9.0 introduces a massive backwards-incompatible change: Assignment now uses =, and object literals use :, as in JavaScript. This allows us to have implicit object literals, and YAML-style object definitions. Half assignments are removed, in favor of +=, or=, and friends. Interpolation now uses a hash mark # instead of the dollar sign $ — because dollar signs may be part of a valid JS identifier. Downwards range comprehensions are now safe again, and are optimized to straight for loops when created with integer endpoints. A fast, unguarded form of object comprehension was added: for all key, value of object. Mentioning the super keyword with no arguments now forwards all arguments passed to the function, as in Ruby. If you extend class B from parent class A, if A has an extended method defined, it will be called, passing in B — this enables static inheritance, among other things. Cleaner output for functions bound with the fat arrow. @variables can now be used in parameter lists, with the parameter being automatically set as a property on the object — useful in constructors and setter functions. Constructor functions can now take splats.0.91.00.9.0=:+=or=#$for all key, value of objectsuperBAAextendedB@variables0.7.2    — 2010-07-12 0.7.2 — 2010-07-122010-07-12Quick bugfix (right after 0.7.1) for a problem that prevented coffee command-line options from being parsed in some circumstances.coffee0.7.1    — 2010-07-11 0.7.1 — 2010-07-112010-07-11Block-style comments are now passed through and printed as JavaScript block comments – making them useful for licenses and copyright headers. Better support for running coffee scripts standalone via hashbangs. Improved syntax errors for tokens that are not in the grammar.0.7.0    — 2010-06-28 0.7.0 — 2010-06-282010-06-28Official CoffeeScript variable style is now camelCase, as in JavaScript. Reserved words are now allowed as object keys, and will be quoted for you. Range comprehensions now generate cleaner code, but you have to specify by -1 if you’d like to iterate downward. Reporting of syntax errors is greatly improved from the previous release. Running coffee with no arguments now launches the REPL, with Readline support. The <- bind operator has been removed from CoffeeScript. The loop keyword was added, which is equivalent to a while true loop. Comprehensions that contain closures will now close over their variables, like the semantics of a forEach. You can now use bound function in class definitions (bound to the instance). For consistency, a in b is now an array presence check, and a of b is an object-key check. Comments are no longer passed through to the generated JavaScript.by -1coffee<-loopwhile trueforEacha in ba of b0.6.2    — 2010-05-15 0.6.2 — 2010-05-152010-05-15The coffee command will now preserve directory structure when compiling a directory full of scripts. Fixed two omissions that were preventing the CoffeeScript compiler from running live within Internet Explorer. There’s now a syntax for block comments, similar in spirit to CoffeeScript’s heredocs. ECMA Harmony DRY-style pattern matching is now supported, where the name of the property is the same as the name of the value: {name, length}: func. Pattern matching is now allowed within comprehension variables. unless is now allowed in block form. until loops were added, as the inverse of while loops. switch statements are now allowed without switch object clauses. Compatible with Node.js v0.1.95.coffee{name, length}: funcunlessuntilwhileswitchv0.1.950.6.1    — 2010-04-12 0.6.1 — 2010-04-122010-04-12Upgraded CoffeeScript for compatibility with the new Node.js v0.1.90 series.v0.1.900.6.0    — 2010-04-03 0.6.0 — 2010-04-032010-04-03Trailing commas are now allowed, a-la Python. Static properties may be assigned directly within class definitions, using @property notation.@property0.5.6    — 2010-03-23 0.5.6 — 2010-03-232010-03-23Interpolation can now be used within regular expressions and heredocs, as well as strings. Added the <- bind operator. Allowing assignment to half-expressions instead of special ||=-style operators. The arguments object is no longer automatically converted into an array. After requiring coffeescript, Node.js can now directly load .coffee files, thanks to registerExtension. Multiple splats can now be used in function calls, arrays, and pattern matching.<-||=coffeescript.coffeeregisterExtension0.5.5    — 2010-03-08 0.5.5 — 2010-03-082010-03-08String interpolation, contributed by Stan Angeloff. Since --run has been the default since 0.5.3, updating --stdio and --eval to run by default, pass --compile as well if you’d like to print the result.Stan Angeloff--run0.5.3--stdio--eval--compile0.5.4    — 2010-03-03 0.5.4 — 2010-03-032010-03-03Bugfix that corrects the Node.js global constants __filename and __dirname. Tweaks for more flexible parsing of nested function literals and improperly-indented comments. Updates for the latest Node.js API.__filename__dirname0.5.3    — 2010-02-27 0.5.3 — 2010-02-272010-02-27CoffeeScript now has a syntax for defining classes. Many of the core components (Nodes, Lexer, Rewriter, Scope, Optparse) are using them. Cakefiles can use optparse.coffee to define options for tasks. --run is now the default flag for the coffee command, use --compile to save JavaScripts. Bugfix for an ambiguity between RegExp literals and chained divisions.optparse.coffee--runcoffee--compile0.5.2    — 2010-02-25 0.5.2 — 2010-02-252010-02-25Added a compressed version of the compiler for inclusion in web pages as /v2/browser-compiler/coffeescript.js. It’ll automatically run any script tags with type text/coffeescript for you. Added a --stdio option to the coffee command, for piped-in compiles./v2/browser-compiler/coffeescript.jstext/coffeescript--stdiocoffee0.5.1    — 2010-02-24 0.5.1 — 2010-02-242010-02-24Improvements to null soaking with the existential operator, including soaks on indexed properties. Added conditions to while loops, so you can use them as filters with when, in the same manner as comprehensions.whilewhen0.5.0    — 2010-02-21 0.5.0 — 2010-02-212010-02-21CoffeeScript 0.5.0 is a major release, While there are no language changes, the Ruby compiler has been removed in favor of a self-hosting compiler written in pure CoffeeScript.0.3.2    — 2010-02-08 0.3.2 — 2010-02-082010-02-08@property is now a shorthand for this.property. Switched the default JavaScript engine from Narwhal to Node.js. Pass the --narwhal flag if you’d like to continue using it.@propertythis.property--narwhal0.3.0    — 2010-01-26 0.3.0 — 2010-01-262010-01-26CoffeeScript 0.3 includes major syntax changes: The function symbol was changed to ->, and the bound function symbol is now =>. Parameter lists in function definitions must now be wrapped in parentheses. Added property soaking, with the ?. operator. Made parentheses optional, when invoking functions with arguments. Removed the obsolete block literal syntax.->=>?.0.2.6    — 2010-01-17 0.2.6 — 2010-01-172010-01-17Added Python-style chained comparisons, the conditional existence operator ?=, and some examples from Beautiful Code. Bugfixes relating to statement-to-expression conversion, arguments-to-array conversion, and the TextMate syntax highlighter.?=Beautiful Code0.2.5    — 2010-01-13 0.2.5 — 2010-01-132010-01-13The conditions in switch statements can now take multiple values at once — If any of them are true, the case will run. Added the long arrow ==>, which defines and immediately binds a function to this. While loops can now be used as expressions, in the same way that comprehensions can. Splats can be used within pattern matches to soak up the rest of an array.==>this0.2.4    — 2010-01-12 0.2.4 — 2010-01-122010-01-12Added ECMAScript Harmony style destructuring assignment, for dealing with extracting values from nested arrays and objects. Added indentation-sensitive heredocs for nicely formatted strings or chunks of code.0.2.3    — 2010-01-11 0.2.3 — 2010-01-112010-01-11Axed the unsatisfactory ino keyword, replacing it with of for object comprehensions. They now look like: for prop, value of object.inooffor prop, value of object0.2.2    — 2010-01-10 0.2.2 — 2010-01-102010-01-10When performing a comprehension over an object, use ino, instead of in, which helps us generate smaller, more efficient code at compile time. Added :: as a shorthand for saying .prototype. The “splat” symbol has been changed from a prefix asterisk *, to a postfix ellipsis ... Added JavaScript’s in operator, empty return statements, and empty while loops. Constructor functions that start with capital letters now include a safety check to make sure that the new instance of the object is returned. The extends keyword now functions identically to goog.inherits in Google’s Closure Library.inoin::.prototype.*...inreturnwhileextendsgoog.inherits0.2.1    — 2010-01-05 0.2.1 — 2010-01-052010-01-05Arguments objects are now converted into real arrays when referenced.0.2.0    — 2010-01-05 0.2.0 — 2010-01-052010-01-05Major release. Significant whitespace. Better statement-to-expression conversion. Splats. Splice literals. Object comprehensions. Blocks. The existential operator. Many thanks to all the folks who posted issues, with special thanks to Liam O’Connor-Davis for whitespace and expression help.Liam O’Connor-Davis0.1.6    — 2009-12-27 0.1.6 — 2009-12-272009-12-27Bugfix for running coffee --interactive and --run from outside of the CoffeeScript directory. Bugfix for nested function/if-statements.coffee --interactive--run0.1.5    — 2009-12-26 0.1.5 — 2009-12-262009-12-26Array slice literals and array comprehensions can now both take Ruby-style ranges to specify the start and end. JavaScript variable declaration is now pushed up to the top of the scope, making all assignment statements into expressions. You can use \\ to escape newlines. The coffeescript command is now called coffee.\\coffeescriptcoffee0.1.4    — 2009-12-25 0.1.4 — 2009-12-252009-12-25The official CoffeeScript extension is now .coffee instead of .cs, which properly belongs to C#. Due to popular demand, you can now also use = to assign. Unlike JavaScript, = can also be used within object literals, interchangeably with :. Made a grammatical fix for chained function calls like func(1)(2)(3)(4). Inheritance and super no longer use __proto__, so they should be IE-compatible now..coffee.csC#==:func(1)(2)(3)(4)__proto__0.1.3    — 2009-12-25 0.1.3 — 2009-12-252009-12-25The coffee command now includes --interactive, which launches an interactive CoffeeScript session, and --run, which directly compiles and executes a script. Both options depend on a working installation of Narwhal. The aint keyword has been replaced by isnt, which goes together a little smoother with is. Quoted strings are now allowed as identifiers within object literals: eg. {\"5+5\": 10}. All assignment operators now use a colon: +:, -:, *:, etc.coffee--interactive--runaintisntis{\"5+5\": 10}+:-:*:0.1.2    — 2009-12-24 0.1.2 — 2009-12-242009-12-24Fixed a bug with calling super() through more than one level of inheritance, with the re-addition of the extends keyword. Added experimental Narwhal support (as a Tusk package), contributed by Tom Robinson, including bin/cs as a CoffeeScript REPL and interpreter. New --no-wrap option to suppress the safety function wrapper.super()extendsNarwhalTom Robinsonbin/cs--no-wrap0.1.1    — 2009-12-24 0.1.1 — 2009-12-242009-12-24Added instanceof and typeof as operators.instanceoftypeof0.1.0    — 2009-12-24 0.1.0 — 2009-12-242009-12-24Initial CoffeeScript release.","dataLevel":3,"level":1,"parent":false},{"section":"2.3.1","title":"2.3.1 - 2018-05-21","content":"2.3.1    — 2018-05-21 2.3.1 — 2018-05-212018-05-21 Returning a JSX tag that is adjacent to another JSX tag, as opposed to returning a root JSX tag or fragment, is invalid JSX syntax. Babel throws an error on this, and now the CoffeeScript compiler does too. Invalid indentation inside a JSX interpolation (the middle of <tag>{ ... }</tag>) now throws an error. The browser compiler, used in Try CoffeeScript and similar web-based CoffeeScript editors, now evaluates code in a global scope rather than the scope of the browser compiler. This improves performance of code executed via the browser compiler. Syntax cleanup: it is now possible for an implicit function call to take a body-less class as an argument, and ?:: now behaves identically to :: with regard to implying a line continuation. Returning a JSX tag that is adjacent to another JSX tag, as opposed to returning a root JSX tag or fragment, is invalid JSX syntax. Babel throws an error on this, and now the CoffeeScript compiler does too.Invalid indentation inside a JSX interpolation (the middle of <tag>{ ... }</tag>) now throws an error.<tag>{ ... }</tag>The browser compiler, used in Try CoffeeScript and similar web-based CoffeeScript editors, now evaluates code in a global scope rather than the scope of the browser compiler. This improves performance of code executed via the browser compiler.Try CoffeeScriptSyntax cleanup: it is now possible for an implicit function call to take a body-less class as an argument, and ?:: now behaves identically to :: with regard to implying a line continuation.?::::","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.3.0","title":"2.3.0 - 2018-04-29","content":"2.3.0    — 2018-04-29 2.3.0 — 2018-04-292018-04-29 This release adds support for all the new features and syntaxes in ES2018 that weren’t already possible in CoffeeScript. For all of the below features, make sure that you transpile unless you know that your target runtime(s) support each feature. Asynchronous iterators are now supported. You can now yield an await call, e.g. do -> until file.EOF then yield await file.readLine(). Object splats/destructuring, a.k.a. object rest/spread syntax, has been standardized as part of ES2018 and therefore this release removes the polyfill that had previously been supporting this syntax. Code like {a, b, rest...} = obj now outputs more or less just like it appears, rather than being converted into an Object.assign call. Note that there are some subtle differences between the Object.assign polyfill and the native implementation. The exponentiation operator, **, and exponentiation assignment operator **= are new to JavaScript in ES2018. Now code like a ** 3 is output as it appears, rather than being converted into Math.pow(a, 3) as it was before. The s (dotAll) flag is now supported in regular expressions. This release adds support for all the new features and syntaxes in ES2018 that weren’t already possible in CoffeeScript. For all of the below features, make sure that you transpile unless you know that your target runtime(s) support each feature.transpileAsynchronous iterators are now supported. You can now yield an await call, e.g. do -> until file.EOF then yield await file.readLine().yieldawaitdo -> until file.EOF then yield await file.readLine()Object splats/destructuring, a.k.a. object rest/spread syntax, has been standardized as part of ES2018 and therefore this release removes the polyfill that had previously been supporting this syntax. Code like {a, b, rest...} = obj now outputs more or less just like it appears, rather than being converted into an Object.assign call. Note that there are some subtle differences between the Object.assign polyfill and the native implementation.{a, b, rest...} = objObject.assignsome subtle differencesObject.assignThe exponentiation operator, **, and exponentiation assignment operator **= are new to JavaScript in ES2018. Now code like a ** 3 is output as it appears, rather than being converted into Math.pow(a, 3) as it was before.****=a ** 3Math.pow(a, 3)The s (dotAll) flag is now supported in regular expressions.s","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.2.4","title":"2.2.4 - 2018-03-29","content":"2.2.4    — 2018-03-29 2.2.4 — 2018-03-292018-03-29 When the by value in a for loop is a literal number, e.g. for x in [2..1] by -1, fewer checks are necessary to determine if the loop is in range. Bugfix for regression in 2.2.0 where a statement inside parentheses, e.g. (fn(); break) while condition, was compiling. Pure statements like break or return cannot turn a parenthesized block into an expression, and should throw an error. When the by value in a for loop is a literal number, e.g. for x in [2..1] by -1, fewer checks are necessary to determine if the loop is in range.byforfor x in [2..1] by -1Bugfix for regression in 2.2.0 where a statement inside parentheses, e.g. (fn(); break) while condition, was compiling. Pure statements like break or return cannot turn a parenthesized block into an expression, and should throw an error.(fn(); break) while conditionbreakreturn","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.2.3","title":"2.2.3 - 2018-03-11","content":"2.2.3    — 2018-03-11 2.2.3 — 2018-03-112018-03-11 Bugfix for object destructuring with an empty array as a key’s value: { key: [] } = obj. Bugfix for array destructuring onto targets attached to this: [ @most... , @penultimate, @last ] = arr. Bugfix for object destructuring with an empty array as a key’s value: { key: [] } = obj.{ key: [] } = objBugfix for array destructuring onto targets attached to this: [ @most... , @penultimate, @last ] = arr.this[ @most... , @penultimate, @last ] = arr","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.2.2","title":"2.2.2 - 2018-02-21","content":"2.2.2    — 2018-02-21 2.2.2 — 2018-02-212018-02-21 Bugfix for regression in 2.2.0 where a range with a by (step) value that increments or decrements in the opposite direction as the range was returning an array containing the first value of the range, whereas it should be returning an empty array. In other words, x for x in [2..1] by 1 should equal [], not [2] (because the step value is positive 1, counting up, whereas the range goes from 2 to 1, counting down). Bugfixes for allowing backslashes in import and export statements and lines that trigger the start of an indented block, like an if statement. Bugfix for regression in 2.2.0 where a range with a by (step) value that increments or decrements in the opposite direction as the range was returning an array containing the first value of the range, whereas it should be returning an empty array. In other words, x for x in [2..1] by 1 should equal [], not [2] (because the step value is positive 1, counting up, whereas the range goes from 2 to 1, counting down).byx for x in [2..1] by 1[][2]Bugfixes for allowing backslashes in import and export statements and lines that trigger the start of an indented block, like an if statement.importexportif","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.2.1","title":"2.2.1 - 2018-02-06","content":"2.2.1    — 2018-02-06 2.2.1 — 2018-02-062018-02-06 Bugfix for regression in 2.2.0 involving an error thrown by the compiler in certain cases when using destructuring with a splat or expansion in an array. Bugfix for regression in 2.2.0 where in certain cases a range iterator variable was declared in the global scope. Bugfix for regression in 2.2.0 involving an error thrown by the compiler in certain cases when using destructuring with a splat or expansion in an array.Bugfix for regression in 2.2.0 where in certain cases a range iterator variable was declared in the global scope.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.2.0","title":"2.2.0 - 2018-02-01","content":"2.2.0    — 2018-02-01 2.2.0 — 2018-02-012018-02-01 This release fixes all currently open bugs, dating as far back as 2014, 2012 and 2011. Potential breaking change: An inline if or switch statement with an ambiguous else, such as if no then if yes then alert 1 else alert 2, now compiles where the else always corresponds to the closest open then. Previously the behavior of an ambiguous else was unpredictable. If your code has any if … then or switch … then statements with multiple thens (and one or more elses) the compiled output might be different now, unless you had resolved ambiguity via parentheses. We made this change because the previous behavior was inconsistent and basically a bug: depending on what grammar was where, for example if there was an inline function or something that implied a block, the else might bind to an earlier then rather than a later then. Now an else essentially closes a block opened by a then, similar to closing an open parenthesis. When a required then is missing, the error more accurately points out the location of the mistake. An error is thrown when the coffee command is run in an environment that doesn’t support some ES2015 JavaScript features that the CoffeeScript compiler itself requires. This can happen if CoffeeScript is installed in Node older than version 6. Destructuring with a non-final splat/spread, e.g. [open, contents..., close] = tag.split('') is now output using ES2015 rest syntax. Functions named get or set can be used without parentheses in more cases, including when attached to this or @ or ?.; or when the first argument is an implicit object, e.g. @set key: 'val'. Statements such as break can now be used inside parentheses, e.g. (doSomething(); break) while condition or (pick(key); break) for key of obj. Bugfix for assigning to a property attached to this/@ in destructuring, e.g. ({@prop = yes, @otherProp = no}) ->. Bugfix for incorrect errors being thrown about calling super with a parameter attached to this when said parameter is in a lower scope, e.g. class Child extends Parent then constructor: -> super(-> @prop). Bugfix to prevent a possible infinite loop when a for loop is given a variable to step by, e.g. for x in [1..3] by step (as opposed to by 0.5 or some other primitive numeric value). Bugfix to no longer declare iterator variables twice when evaluating a range, e.g. end = 3; fn [0..end]. Bugfix for incorrect scope of variables in chained calls, e.g. start(x = 3).then(-> x = 4). Bugfix for incorrect scope of variables in a function passed to do, e.g. for [1..3] then masked = 10; do -> alert masked. Bugfix to no longer throw a syntax error for a trailing comma in a function call, e.g. fn arg1, arg2,. Bugfix for an expression in a property access, e.g. a[!b in c..]. Bugfix to allow a line continuation backslash (\\) at any point in a for line. This release fixes all currently open bugs, dating as far back as 2014, 2012 and 2011.allPotential breaking change: An inline if or switch statement with an ambiguous else, such as if no then if yes then alert 1 else alert 2, now compiles where the else always corresponds to the closest open then. Previously the behavior of an ambiguous else was unpredictable. If your code has any if … then or switch … then statements with multiple thens (and one or more elses) the compiled output might be different now, unless you had resolved ambiguity via parentheses. We made this change because the previous behavior was inconsistent and basically a bug: depending on what grammar was where, for example if there was an inline function or something that implied a block, the else might bind to an earlier then rather than a later then. Now an else essentially closes a block opened by a then, similar to closing an open parenthesis.Potential breaking change:ifswitchelseif no then if yes then alert 1 else alert 2elsethenelseif … thenswitch … thenthenelseelsethenthenelsethenWhen a required then is missing, the error more accurately points out the location of the mistake.thenAn error is thrown when the coffee command is run in an environment that doesn’t support some ES2015 JavaScript features that the CoffeeScript compiler itself requires. This can happen if CoffeeScript is installed in Node older than version 6.coffeeDestructuring with a non-final splat/spread, e.g. [open, contents..., close] = tag.split('') is now output using ES2015 rest syntax.[open, contents..., close] = tag.split('')Functions named get or set can be used without parentheses in more cases, including when attached to this or @ or ?.; or when the first argument is an implicit object, e.g. @set key: 'val'.getsetthis@?.@set key: 'val'Statements such as break can now be used inside parentheses, e.g. (doSomething(); break) while condition or (pick(key); break) for key of obj.break(doSomething(); break) while condition(pick(key); break) for key of objBugfix for assigning to a property attached to this/@ in destructuring, e.g. ({@prop = yes, @otherProp = no}) ->.this@({@prop = yes, @otherProp = no}) ->Bugfix for incorrect errors being thrown about calling super with a parameter attached to this when said parameter is in a lower scope, e.g. class Child extends Parent then constructor: -> super(-> @prop).superthisclass Child extends Parent then constructor: -> super(-> @prop)Bugfix to prevent a possible infinite loop when a for loop is given a variable to step by, e.g. for x in [1..3] by step (as opposed to by 0.5 or some other primitive numeric value).forfor x in [1..3] by stepby 0.5Bugfix to no longer declare iterator variables twice when evaluating a range, e.g. end = 3; fn [0..end].end = 3; fn [0..end]Bugfix for incorrect scope of variables in chained calls, e.g. start(x = 3).then(-> x = 4).start(x = 3).then(-> x = 4)Bugfix for incorrect scope of variables in a function passed to do, e.g. for [1..3] then masked = 10; do -> alert masked.dofor [1..3] then masked = 10; do -> alert maskedBugfix to no longer throw a syntax error for a trailing comma in a function call, e.g. fn arg1, arg2,.fn arg1, arg2,Bugfix for an expression in a property access, e.g. a[!b in c..].a[!b in c..]Bugfix to allow a line continuation backslash (\\) at any point in a for line.\\for","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.1.1","title":"2.1.1 - 2017-12-29","content":"2.1.1    — 2017-12-29 2.1.1 — 2017-12-292017-12-29 Bugfix to set the correct context for executable class bodies. So in class @B extends @A then @property = 1, the @ in @property now refers to the class, not the global object. Bugfix where anonymous classes were getting created using the same automatic variable name. They now each receive unique names, so as not to override each other. Bugfix to set the correct context for executable class bodies. So in class @B extends @A then @property = 1, the @ in @property now refers to the class, not the global object.class @B extends @A then @property = 1@@propertyBugfix where anonymous classes were getting created using the same automatic variable name. They now each receive unique names, so as not to override each other.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.1.0","title":"2.1.0 - 2017-12-10","content":"2.1.0    — 2017-12-10 2.1.0 — 2017-12-102017-12-10 Computed property keys in object literals are now supported: obj = { ['key' + i]: 42 }, or obj = [Symbol.iterator]: -> yield i++. Skipping of array elements, a.k.a. elision, is now supported: arr = [a, , b], or [, protocol] = url.match /^(.*):\\/\\//. JSX fragments syntax is now supported. Bugfix where /// within a # line comment inside a /// block regex was erroneously closing the regex, rather than being treated as part of the comment. Bugfix for incorrect output for object rest destructuring inside array destructuring. Computed property keys in object literals are now supported: obj = { ['key' + i]: 42 }, or obj = [Symbol.iterator]: -> yield i++.obj = { ['key' + i]: 42 }obj = [Symbol.iterator]: -> yield i++Skipping of array elements, a.k.a. elision, is now supported: arr = [a, , b], or [, protocol] = url.match /^(.*):\\/\\//.arr = [a, , b][, protocol] = url.match /^(.*):\\/\\//JSX fragments syntax is now supported.JSX fragments syntaxBugfix where /// within a # line comment inside a /// block regex was erroneously closing the regex, rather than being treated as part of the comment.///#///Bugfix for incorrect output for object rest destructuring inside array destructuring.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.3","title":"2.0.3 - 2017-11-26","content":"2.0.3    — 2017-11-26 2.0.3 — 2017-11-262017-11-26 Bugfix for export default followed by an implicit object that contains an explicit object, for example exportedMember: { obj... }. Bugfix for key, val of obj after an implicit object member, e.g. foo: bar for key, val of obj. Bugfix for combining array and object destructuring, e.g. [ ..., {a, b} ] = arr. Bugfix for an edge case where it was possible to create a bound (=>) generator function, which should throw an error as such functions aren’t allowed in ES2015. Bugfix for source maps: .map files should always have the same base filename as the requested output filename. So coffee --map --output foo.js test.coffee should generate foo.js and foo.js.map. Bugfix for incorrect source maps generated when using --transpile with --map for multiple input files. Bugfix for comments at the beginning or end of input into the REPL (coffee --interactive). Bugfix for export default followed by an implicit object that contains an explicit object, for example exportedMember: { obj... }.export defaultexportedMember: { obj... }Bugfix for key, val of obj after an implicit object member, e.g. foo: bar for key, val of obj.key, val of objfoo: bar for key, val of objBugfix for combining array and object destructuring, e.g. [ ..., {a, b} ] = arr.[ ..., {a, b} ] = arrBugfix for an edge case where it was possible to create a bound (=>) generator function, which should throw an error as such functions aren’t allowed in ES2015.=>Bugfix for source maps: .map files should always have the same base filename as the requested output filename. So coffee --map --output foo.js test.coffee should generate foo.js and foo.js.map..mapcoffee --map --output foo.js test.coffeefoo.jsfoo.js.mapBugfix for incorrect source maps generated when using --transpile with --map for multiple input files.--transpile--mapBugfix for comments at the beginning or end of input into the REPL (coffee --interactive).coffee --interactive","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.2","title":"2.0.2 - 2017-10-26","content":"2.0.2    — 2017-10-26 2.0.2 — 2017-10-262017-10-26 --transpile now also applies to required or imported CoffeeScript files. --transpile can be used with the REPL: coffee --interactive --transpile. Improvements to comments output that should now cover all of the Flow comment-based syntax. Inline ### comments near variable initial assignments are now output in the variable declaration statement, and ### comments near a class and method names are now output where Flow expects them. Importing CoffeeScript keywords is now allowed, so long as they’re aliased: import { and as andFn } from 'lib'. (You could also do import lib from 'lib' and then reference lib.and.) Calls to functions named get and set no longer throw an error when given a bracketless object literal as an argument: obj.set propertyName: propertyValue. In the constructor of a derived class (a class that extends another class), you cannot call super with an argument that references this: class Child extends Parent then constructor: (@arg) -> super(@arg). This isn’t allowed in JavaScript, and now the CoffeeScript compiler will throw an error. Instead, assign to this after calling super: (arg) -> super(arg); @arg = arg. Bugfix for incorrect output when backticked statements and hoisted expressions were both in the same class body. This allows a backticked line like `field = 3`, for people using the experimental class fields syntax, in the same class along with traditional class body expressions like prop: 3 that CoffeeScript outputs as part of the class prototype. Bugfix for comments not output before a complex ? operation, e.g. @a ? b. All tests now pass in Windows. --transpile now also applies to required or imported CoffeeScript files.--transpilerequireimport--transpile can be used with the REPL: coffee --interactive --transpile.--transpilecoffee --interactive --transpileImprovements to comments output that should now cover all of the Flow comment-based syntax. Inline ### comments near variable initial assignments are now output in the variable declaration statement, and ### comments near a class and method names are now output where Flow expects them.Flow comment-based syntax###variable###class and method namesImporting CoffeeScript keywords is now allowed, so long as they’re aliased: import { and as andFn } from 'lib'. (You could also do import lib from 'lib' and then reference lib.and.)import { and as andFn } from 'lib'import lib from 'lib'lib.andCalls to functions named get and set no longer throw an error when given a bracketless object literal as an argument: obj.set propertyName: propertyValue.getsetobj.set propertyName: propertyValueIn the constructor of a derived class (a class that extends another class), you cannot call super with an argument that references this: class Child extends Parent then constructor: (@arg) -> super(@arg). This isn’t allowed in JavaScript, and now the CoffeeScript compiler will throw an error. Instead, assign to this after calling super: (arg) -> super(arg); @arg = arg.extendssuperthisclass Child extends Parent then constructor: (@arg) -> super(@arg)thissuper(arg) -> super(arg); @arg = argBugfix for incorrect output when backticked statements and hoisted expressions were both in the same class body. This allows a backticked line like `field = 3`, for people using the experimental class fields syntax, in the same class along with traditional class body expressions like prop: 3 that CoffeeScript outputs as part of the class prototype.`field = 3`class fieldsprop: 3Bugfix for comments not output before a complex ? operation, e.g. @a ? b.?@a ? bAll tests now pass in Windows.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.1","title":"2.0.1 - 2017-09-26","content":"2.0.1    — 2017-09-26 2.0.1 — 2017-09-262017-09-26 babel-core is no longer listed in package.json, even as an optionalDependency, to avoid it being automatically installed for most users. If you wish to use --transpile, simply install babel-core manually. See Transpilation. --transpile now relies on Babel to find its options, i.e. the .babelrc file in the path of the file(s) being compiled. (Previously the CoffeeScript compiler was duplicating this logic, so nothing has changed from a user’s perspective.) This provides automatic support for additional ways to pass options to Babel in future versions, such as the .babelrc.js file coming in Babel 7. Backticked expressions in a class body, outside any class methods, are now output in the JavaScript class body itself. This allows for passing through experimental JavaScript syntax like the class fields proposal, assuming your transpiler supports it. babel-core is no longer listed in package.json, even as an optionalDependency, to avoid it being automatically installed for most users. If you wish to use --transpile, simply install babel-core manually. See Transpilation.babel-corepackage.jsonoptionalDependency--transpilebabel-coreTranspilation--transpile now relies on Babel to find its options, i.e. the .babelrc file in the path of the file(s) being compiled. (Previously the CoffeeScript compiler was duplicating this logic, so nothing has changed from a user’s perspective.) This provides automatic support for additional ways to pass options to Babel in future versions, such as the .babelrc.js file coming in Babel 7.--transpile.babelrc.babelrc.jsBackticked expressions in a class body, outside any class methods, are now output in the JavaScript class body itself. This allows for passing through experimental JavaScript syntax like the class fields proposal, assuming your transpiler supports it.class fields proposaltranspiler supports it","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.0","title":"2.0.0 - 2017-09-18","content":"2.0.0    — 2017-09-18 2.0.0 — 2017-09-182017-09-18 Added --transpile flag or transpile Node API option to tell the CoffeeScript compiler to pipe its output through Babel before saving or returning it; see Transpilation. Also changed the -t short flag to refer to --transpile instead of --tokens. Always populate source maps’ sourcesContent property. Bugfixes for destructuring and for comments in JSX. Note that these are only the changes between 2.0.0-beta5 and 2.0.0. See below for all changes since 1.x. Added --transpile flag or transpile Node API option to tell the CoffeeScript compiler to pipe its output through Babel before saving or returning it; see Transpilation. Also changed the -t short flag to refer to --transpile instead of --tokens.--transpiletranspileTranspilation-t--transpile--tokensAlways populate source maps’ sourcesContent property.sourcesContentBugfixes for destructuring and for comments in JSX.Note that these are only the changes between 2.0.0-beta5 and 2.0.0. See below for all changes since 1.x.Note that these are only the changes between 2.0.0-beta5 and 2.0.0. See below for all changes since 1.x.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.0-beta5","title":"2.0.0-beta5 - 2017-09-02","content":"2.0.0-beta5    — 2017-09-02 2.0.0-beta5 — 2017-09-022017-09-02 Node 6 is now supported, and we will try to maintain that as the minimum required version for CoffeeScript 2 via the coffee command or Node API. Older versions of Node, or non-evergreen browsers, can compile via the browser compiler. The command line --output flag now allows you to specify an output filename, not just an output folder. The command line --require flag now properly handles filenames or module names that are invalid identifiers (like an NPM module with a hyphen in the name). Object.assign, output when object destructuring is used, is polyfilled using the same polyfill that Babel outputs. This means that polyfills shouldn’t be required unless support for Internet Explorer 8 or below is desired (or your own code uses a feature that requires a polyfill). See ES2015+ Output. A string or JSX interpolation that contains only a comment (\"a#{### comment ###}b\" or <div>{### comment ###}</div>) is now output (`a${/* comment */}b`) Interpolated strings (ES2015 template literals) that contain quotation marks no longer have the quotation marks escaped: `say \"${message}\"` It is now possible to chain after a function literal (for example, to define a function and then call .call on it). The results of the async tests are included in the output when you run cake test. Bugfixes for object destructuring; expansions in function parameters; generated reference variables in function parameters; chained functions after do; splats after existential operator soaks in arrays ([a?.b...]); trailing if with splat in arrays or function parameters ([a if b...]); attempting to throw an if, for, switch, while or other invalid construct. Bugfixes for syntactical edge cases: semicolons after = and other “mid-expression” tokens; spaces after ::; and scripts that begin with : or *. Bugfixes for source maps generated via the Node API; and stack trace line numbers when compiling CoffeeScript via the Node API from within a .coffee file. Node 6 is now supported, and we will try to maintain that as the minimum required version for CoffeeScript 2 via the coffee command or Node API. Older versions of Node, or non-evergreen browsers, can compile via the browser compiler.coffeebrowser compilerThe command line --output flag now allows you to specify an output filename, not just an output folder.--outputThe command line --require flag now properly handles filenames or module names that are invalid identifiers (like an NPM module with a hyphen in the name).--requireObject.assign, output when object destructuring is used, is polyfilled using the same polyfill that Babel outputs. This means that polyfills shouldn’t be required unless support for Internet Explorer 8 or below is desired (or your own code uses a feature that requires a polyfill). See ES2015+ Output.Object.assignES2015+ OutputA string or JSX interpolation that contains only a comment (\"a#{### comment ###}b\" or <div>{### comment ###}</div>) is now output (`a${/* comment */}b`)\"a#{### comment ###}b\"<div>{### comment ###}</div>`a${/* comment */}b`Interpolated strings (ES2015 template literals) that contain quotation marks no longer have the quotation marks escaped: `say \"${message}\"``say \"${message}\"`It is now possible to chain after a function literal (for example, to define a function and then call .call on it)..callThe results of the async tests are included in the output when you run cake test.cake testBugfixes for object destructuring; expansions in function parameters; generated reference variables in function parameters; chained functions after do; splats after existential operator soaks in arrays ([a?.b...]); trailing if with splat in arrays or function parameters ([a if b...]); attempting to throw an if, for, switch, while or other invalid construct.do[a?.b...]if[a if b...]throwifforswitchwhileBugfixes for syntactical edge cases: semicolons after = and other “mid-expression” tokens; spaces after ::; and scripts that begin with : or *.=:::*Bugfixes for source maps generated via the Node API; and stack trace line numbers when compiling CoffeeScript via the Node API from within a .coffee file..coffee","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.0-beta4","title":"2.0.0-beta4 - 2017-08-03","content":"2.0.0-beta4    — 2017-08-03 2.0.0-beta4 — 2017-08-032017-08-03 This release includes all the changes from 1.12.6 to 1.12.7. Line comments (starting with #) are now output in the generated JavaScript. Block comments (delimited by ###) are now allowed anywhere, including inline where they previously weren’t possible. This provides support for static type annotations using Flow’s comments-based syntax. Spread syntax (... for objects) is now supported in JSX tags: <div {props...} />. Argument parsing for scripts run via coffee is improved. See breaking changes. CLI: Propagate SIGINT and SIGTERM signals when node is forked. await in the REPL is now allowed without requiring a wrapper function. do super is now allowed, and other accesses of super like super.x.y or super['x'].y now work. Splat/spread syntax triple dots are now allowed on either the left or the right (so props... or ...props are both valid). Tagged template literals are recognized as callable functions. Bugfixes for object spread syntax in nested properties. Bugfixes for destructured function parameter default values. This release includes all the changes from 1.12.6 to 1.12.7.all the changes from 1.12.6 to 1.12.7Line comments (starting with #) are now output in the generated JavaScript.Line comments#Block comments (delimited by ###) are now allowed anywhere, including inline where they previously weren’t possible. This provides support for static type annotations using Flow’s comments-based syntax.Block comments###static type annotationsSpread syntax (... for objects) is now supported in JSX tags: <div {props...} />....<div {props...} />Argument parsing for scripts run via coffee is improved. See breaking changes.coffeebreaking changesCLI: Propagate SIGINT and SIGTERM signals when node is forked.SIGINTSIGTERMawait in the REPL is now allowed without requiring a wrapper function.awaitdo super is now allowed, and other accesses of super like super.x.y or super['x'].y now work.do supersupersuper.x.ysuper['x'].ySplat/spread syntax triple dots are now allowed on either the left or the right (so props... or ...props are both valid).props......propsTagged template literals are recognized as callable functions.Bugfixes for object spread syntax in nested properties.Bugfixes for destructured function parameter default values.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.0-beta3","title":"2.0.0-beta3 - 2017-06-30","content":"2.0.0-beta3    — 2017-06-30 2.0.0-beta3 — 2017-06-302017-06-30 JSX is now supported. Object rest/spread properties are now supported. Bound (fat arrow) methods are once again supported in classes; though an error will be thrown if you attempt to call the method before it is bound. See breaking changes for classes. The REPL no longer warns about assigning to _. Bugfixes for destructured nested default values and issues related to chaining or continuing expressions across multiple lines. JSX is now supported.JSXObject rest/spread properties are now supported.Object rest/spread propertiesBound (fat arrow) methods are once again supported in classes; though an error will be thrown if you attempt to call the method before it is bound. See breaking changes for classes.breaking changes for classesThe REPL no longer warns about assigning to _._Bugfixes for destructured nested default values and issues related to chaining or continuing expressions across multiple lines.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.0-beta2","title":"2.0.0-beta2 - 2017-05-16","content":"2.0.0-beta2    — 2017-05-16 2.0.0-beta2 — 2017-05-162017-05-16 This release includes all the changes from 1.12.5 to 1.12.6. Bound (fat arrow) methods in classes must be declared in the class constructor, after super() if the class is extending a parent class. See breaking changes for classes. All unnecessary utility helper functions have been removed, including the polyfills for indexOf and bind. The extends keyword now only works in the context of classes; it cannot be used to extend a function prototype. See breaking changes for extends. Literate CoffeeScript is now parsed entirely based on indentation, similar to the 1.x implementation; there is no longer a dependency for parsing Markdown. See breaking changes for Literate CoffeeScript parsing. JavaScript reserved words used as properties are no longer wrapped in quotes. require('coffeescript') should now work in non-Node environments such as the builds created by Webpack or Browserify. This provides a more convenient way to include the browser compiler in builds intending to run in a browser environment. Unreachable break statements are no longer added after switch cases that throw exceptions. The browser compiler is now compiled using Babili and transpiled down to Babel’s env preset (should be safe for use in all browsers in current use, not just evergreen versions). Calling functions @get or @set no longer throws an error about required parentheses. (Bare get or set, not attached to an object or @, still intentionally throws a compiler error.) If $XDG_CACHE_HOME is set, the REPL .coffee_history file is saved there. This release includes all the changes from 1.12.5 to 1.12.6.all the changes from 1.12.5 to 1.12.6Bound (fat arrow) methods in classes must be declared in the class constructor, after super() if the class is extending a parent class. See breaking changes for classes.super()breaking changes for classesAll unnecessary utility helper functions have been removed, including the polyfills for indexOf and bind.indexOfbindThe extends keyword now only works in the context of classes; it cannot be used to extend a function prototype. See breaking changes for extends.extendsbreaking changes for extendsextendsLiterate CoffeeScript is now parsed entirely based on indentation, similar to the 1.x implementation; there is no longer a dependency for parsing Markdown. See breaking changes for Literate CoffeeScript parsing.breaking changes for Literate CoffeeScript parsingJavaScript reserved words used as properties are no longer wrapped in quotes.require('coffeescript') should now work in non-Node environments such as the builds created by Webpack or Browserify. This provides a more convenient way to include the browser compiler in builds intending to run in a browser environment.require('coffeescript')Unreachable break statements are no longer added after switch cases that throw exceptions.breakswitchthrowThe browser compiler is now compiled using Babili and transpiled down to Babel’s env preset (should be safe for use in all browsers in current use, not just evergreen versions).envCalling functions @get or @set no longer throws an error about required parentheses. (Bare get or set, not attached to an object or @, still intentionally throws a compiler error.)@get@setgetset@still intentionally throws a compiler errorIf $XDG_CACHE_HOME is set, the REPL .coffee_history file is saved there.$XDG_CACHE_HOME.coffee_history","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.0-beta1","title":"2.0.0-beta1 - 2017-04-14","content":"2.0.0-beta1    — 2017-04-14 2.0.0-beta1 — 2017-04-142017-04-14 Initial beta release of CoffeeScript 2. No further breaking changes are anticipated. Destructured objects and arrays now output using ES2015+ syntax whenever possible. Literate CoffeeScript now has much better support for parsing Markdown, thanks to using Markdown-It to detect Markdown sections rather than just looking at indentation. Calling a function named get or set now requires parentheses, to disambiguate from the get or set keywords (which are disallowed). The compiler now requires Node 7.6+, the first version of Node to support asynchronous functions without requiring a flag. Initial beta release of CoffeeScript 2. No further breaking changes are anticipated.Destructured objects and arrays now output using ES2015+ syntax whenever possible.Literate CoffeeScript now has much better support for parsing Markdown, thanks to using Markdown-It to detect Markdown sections rather than just looking at indentation.Markdown-ItCalling a function named get or set now requires parentheses, to disambiguate from the get or set keywords (which are disallowed).getsetgetsetdisallowedThe compiler now requires Node 7.6+, the first version of Node to support asynchronous functions without requiring a flag.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"2.0.0-alpha1","title":"2.0.0-alpha1 - 2017-02-21","content":"2.0.0-alpha1    — 2017-02-21 2.0.0-alpha1 — 2017-02-212017-02-21 Initial alpha release of CoffeeScript 2. The CoffeeScript compiler now outputs ES2015+ syntax whenever possible. See breaking changes. Classes are output using ES2015 class and extends keywords. Added support for async/await. Bound (arrow) functions now output as => functions. Function parameters with default values now use ES2015 default values syntax. Splat function parameters now use ES2015 spread syntax. Computed properties now use ES2015 syntax. Interpolated strings (template literals) now use ES2015 backtick syntax. Improved support for recognizing Markdown in Literate CoffeeScript files. Mixing tabs and spaces in indentation is now disallowed. Browser compiler is now minified using the Google Closure Compiler (JavaScript version). Node 7+ required for CoffeeScript 2. Initial alpha release of CoffeeScript 2. The CoffeeScript compiler now outputs ES2015+ syntax whenever possible. See breaking changes.breaking changesClasses are output using ES2015 class and extends keywords.classextendsAdded support for async/await.asyncawaitBound (arrow) functions now output as => functions.=>Function parameters with default values now use ES2015 default values syntax.Splat function parameters now use ES2015 spread syntax.Computed properties now use ES2015 syntax.Interpolated strings (template literals) now use ES2015 backtick syntax.Improved support for recognizing Markdown in Literate CoffeeScript files.Mixing tabs and spaces in indentation is now disallowed.Browser compiler is now minified using the Google Closure Compiler (JavaScript version).Node 7+ required for CoffeeScript 2.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.7","title":"1.12.7 - 2017-07-16","content":"1.12.7    — 2017-07-16 1.12.7 — 2017-07-162017-07-16 Fix regressions in 1.12.6 related to chained function calls and indented return and throw arguments. The REPL no longer warns about assigning to _. Fix regressions in 1.12.6 related to chained function calls and indented return and throw arguments.returnthrowThe REPL no longer warns about assigning to _._","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.6","title":"1.12.6 - 2017-05-15","content":"1.12.6    — 2017-05-15 1.12.6 — 2017-05-152017-05-15 The return and export keywords can now accept implicit objects (defined by indentation, without needing braces). Support Unicode code point escapes (e.g. \\u{1F4A9}). The coffee command now first looks to see if CoffeeScript is installed under node_modules in the current folder, and executes the coffee binary there if so; or otherwise it runs the globally installed one. This allows you to have one version of CoffeeScript installed globally and a different one installed locally for a particular project. (Likewise for the cake command.) Bugfixes for chained function calls not closing implicit objects or ternaries. Bugfixes for incorrect code generated by the ? operator within a termary if statement. Fixed some tests, and failing tests now result in a nonzero exit code. The return and export keywords can now accept implicit objects (defined by indentation, without needing braces).returnexportSupport Unicode code point escapes (e.g. \\u{1F4A9}).\\u{1F4A9}The coffee command now first looks to see if CoffeeScript is installed under node_modules in the current folder, and executes the coffee binary there if so; or otherwise it runs the globally installed one. This allows you to have one version of CoffeeScript installed globally and a different one installed locally for a particular project. (Likewise for the cake command.)coffeenode_modulescoffeecakeBugfixes for chained function calls not closing implicit objects or ternaries.Bugfixes for incorrect code generated by the ? operator within a termary if statement.?ifFixed some tests, and failing tests now result in a nonzero exit code.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.5","title":"1.12.5 - 2017-04-10","content":"1.12.5    — 2017-04-10 1.12.5 — 2017-04-102017-04-10 Better handling of default, from, as and * within import and export statements. You can now import or export a member named default and the compiler won’t interpret it as the default keyword. Fixed a bug where invalid octal escape sequences weren’t throwing errors in the compiler. Better handling of default, from, as and * within import and export statements. You can now import or export a member named default and the compiler won’t interpret it as the default keyword.defaultfromas*importexportdefaultdefaultFixed a bug where invalid octal escape sequences weren’t throwing errors in the compiler.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.4","title":"1.12.4 - 2017-02-18","content":"1.12.4    — 2017-02-18 1.12.4 — 2017-02-182017-02-18 The cake commands have been updated, with new watch options for most tasks. Clone the CoffeeScript repo and run cake at the root of the repo to see the options. Fixed a bug where exporting a referenced variable was preventing the variable from being declared. Fixed a bug where the coffee command wasn’t working for a .litcoffee file. Bugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools. The cake commands have been updated, with new watch options for most tasks. Clone the CoffeeScript repo and run cake at the root of the repo to see the options.cakewatchCoffeeScript repocakeFixed a bug where exporting a referenced variable was preventing the variable from being declared.exportFixed a bug where the coffee command wasn’t working for a .litcoffee file.coffee.litcoffeeBugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.3","title":"1.12.3 - 2017-01-24","content":"1.12.3    — 2017-01-24 1.12.3 — 2017-01-242017-01-24 @ values can now be used as indices in for expressions. This loosens the compilation of for expressions to allow the index variable to be an @ value, e.g. do @visit for @node, @index in nodes. Within @visit, the index of the current node (@node) would be available as @index. CoffeeScript’s patched Error.prepareStackTrace has been restored, with some revisions that should prevent the erroneous exceptions that were making life difficult for some downstream projects. This fixes the incorrect line numbers in stack traces since 1.12.2. The //= operator’s output now wraps parentheses around the right operand, like the other assignment operators. @ values can now be used as indices in for expressions. This loosens the compilation of for expressions to allow the index variable to be an @ value, e.g. do @visit for @node, @index in nodes. Within @visit, the index of the current node (@node) would be available as @index.@forfor@do @visit for @node, @index in nodes@visit@node@indexCoffeeScript’s patched Error.prepareStackTrace has been restored, with some revisions that should prevent the erroneous exceptions that were making life difficult for some downstream projects. This fixes the incorrect line numbers in stack traces since 1.12.2.Error.prepareStackTraceThe //= operator’s output now wraps parentheses around the right operand, like the other assignment operators.//=","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.2","title":"1.12.2 - 2016-12-16","content":"1.12.2    — 2016-12-16 1.12.2 — 2016-12-162016-12-16 The browser compiler can once again be built unminified via MINIFY=false cake build:browser. The error-prone patched version of Error.prepareStackTrace has been removed. Command completion in the REPL (pressing tab to get suggestions) has been fixed for Node 6.9.1+. The browser-based tests now include all the tests as the Node-based version. The browser compiler can once again be built unminified via MINIFY=false cake build:browser.MINIFY=false cake build:browserThe error-prone patched version of Error.prepareStackTrace has been removed.Error.prepareStackTraceCommand completion in the REPL (pressing tab to get suggestions) has been fixed for Node 6.9.1+.The browser-based tests now include all the tests as the Node-based version.browser-based tests","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.1","title":"1.12.1 - 2016-12-07","content":"1.12.1    — 2016-12-07 1.12.1 — 2016-12-072016-12-07 You can now import a module member named default, e.g. import { default } from 'lib'. Though like in ES2015, you cannot import an entire module and name it default (so import default from 'lib' is not allowed). Fix regression where from as a variable name was breaking for loop declarations. For the record, from is not a reserved word in CoffeeScript; you may use it for variable names. from behaves like a keyword within the context of import and export statements, and in the declaration of a for loop; though you should also be able to use variables named from in those contexts, and the compiler should be able to tell the difference. You can now import a module member named default, e.g. import { default } from 'lib'. Though like in ES2015, you cannot import an entire module and name it default (so import default from 'lib' is not allowed).defaultimport { default } from 'lib'defaultimport default from 'lib'Fix regression where from as a variable name was breaking for loop declarations. For the record, from is not a reserved word in CoffeeScript; you may use it for variable names. from behaves like a keyword within the context of import and export statements, and in the declaration of a for loop; though you should also be able to use variables named from in those contexts, and the compiler should be able to tell the difference.fromforfromfromimportexportforfrom","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.12.0","title":"1.12.0 - 2016-12-04","content":"1.12.0    — 2016-12-04 1.12.0 — 2016-12-042016-12-04 CoffeeScript now supports ES2015 tagged template literals. Note that using tagged template literals in your code makes you responsible for ensuring that either your runtime supports tagged template literals or that you transpile the output JavaScript further to a version your target runtime(s) support. CoffeeScript now provides a for…from syntax for outputting ES2015 for…of. (Sorry they couldn’t match, but we came up with for…of first for something else.) This allows iterating over generators or any other iterable object. Note that using for…from in your code makes you responsible for ensuring that either your runtime supports for…of or that you transpile the output JavaScript further to a version your target runtime(s) support. Triple backticks (```​) allow the creation of embedded JavaScript blocks where escaping single backticks is not required, which should improve interoperability with ES2015 template literals and with Markdown. Within single-backtick embedded JavaScript, backticks can now be escaped via \\`​. The browser tests now run in the browser again, and are accessible here if you would like to test your browser. CoffeeScript-only keywords in ES2015 imports and exports are now ignored. The compiler now throws an error on trying to export an anonymous class. Bugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools. CoffeeScript now supports ES2015 tagged template literals. Note that using tagged template literals in your code makes you responsible for ensuring that either your runtime supports tagged template literals or that you transpile the output JavaScript further to a version your target runtime(s) support.tagged template literalsCoffeeScript now provides a for…from syntax for outputting ES2015 for…of. (Sorry they couldn’t match, but we came up with for…of first for something else.) This allows iterating over generators or any other iterable object. Note that using for…from in your code makes you responsible for ensuring that either your runtime supports for…of or that you transpile the output JavaScript further to a version your target runtime(s) support.for…fromfor…fromfor…offor…offor…offor…fromfor…ofTriple backticks (```​) allow the creation of embedded JavaScript blocks where escaping single backticks is not required, which should improve interoperability with ES2015 template literals and with Markdown.```​Within single-backtick embedded JavaScript, backticks can now be escaped via \\`​.\\`​The browser tests now run in the browser again, and are accessible here if you would like to test your browser.hereCoffeeScript-only keywords in ES2015 imports and exports are now ignored.importexportThe compiler now throws an error on trying to export an anonymous class.Bugfixes related to tokens and location data, for better source maps and improved compatibility with downstream tools.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.11.1","title":"1.11.1 - 2016-10-02","content":"1.11.1    — 2016-10-02 1.11.1 — 2016-10-022016-10-02 Bugfix for shorthand object syntax after interpolated keys. Bugfix for indentation-stripping in \"\"\" strings. Bugfix for not being able to use the name “arguments” for a prototype property of class. Correctly compile large hexadecimal numbers literals to 2e308 (just like all other large number literals do). Bugfix for shorthand object syntax after interpolated keys.Bugfix for indentation-stripping in \"\"\" strings.\"\"\"Bugfix for not being able to use the name “arguments” for a prototype property of class.Correctly compile large hexadecimal numbers literals to 2e308 (just like all other large number literals do).2e308","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.11.0","title":"1.11.0 - 2016-09-24","content":"1.11.0    — 2016-09-24 1.11.0 — 2016-09-242016-09-24 CoffeeScript now supports ES2015 import and export syntax. Added the -M, --inline-map flag to the compiler, allowing you embed the source map directly into the output JavaScript, rather than as a separate file. A bunch of fixes for yield: yield return can no longer mistakenly be used as an expression. yield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present. &&=, ||=, and= and or= no longer accidentally allow a space before the equals sign. Improved several error messages. Just like undefined compiles to void 0, NaN now compiles into 0/0 and Infinity into 2e308. Bugfix for renamed destructured parameters with defaults. ({a: b = 1}) -> no longer crashes the compiler. Improved the internal representation of a CoffeeScript program. This is only noticeable to tools that use CoffeeScript.tokens or CoffeeScript.nodes. Such tools need to update to take account for changed or added tokens and nodes. Several minor bug fixes, including: The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks. Unassignable parameter destructuring no longer crashes the compiler. Source maps are now used correctly for errors thrown from .coffee.md files. coffee -e 'throw null' no longer crashes. The REPL no longer crashes when using .exit to exit it. Invalid JavaScript is no longer output when lots of for loops are used in the same scope. A unicode issue when using stdin with the CLI. CoffeeScript now supports ES2015 import and export syntax.import and export syntaximportexportAdded the -M, --inline-map flag to the compiler, allowing you embed the source map directly into the output JavaScript, rather than as a separate file.-M, --inline-mapA bunch of fixes for yield: yield return can no longer mistakenly be used as an expression. yield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present. yield yield return can no longer mistakenly be used as an expression. yield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present. yield return can no longer mistakenly be used as an expression.yield returnyield now mirrors return in that it can be used stand-alone as well as with expressions. Where you previously wrote yield undefined, you may now write simply yield. However, this means also inheriting the same syntax limitations that return has, so these examples no longer compile:doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 yieldreturnyield undefinedyieldreturndoubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 doubles = ->   yield for i in [1..3]     i * 2 six = ->   yield     2 * 3 The JavaScript output is a bit nicer, with unnecessary parentheses and spaces, double indentation and double semicolons around yield no longer present.yield&&=, ||=, and= and or= no longer accidentally allow a space before the equals sign.&&=||=and=or=Improved several error messages.Just like undefined compiles to void 0, NaN now compiles into 0/0 and Infinity into 2e308.undefinedvoid 0NaN0/0Infinity2e308Bugfix for renamed destructured parameters with defaults. ({a: b = 1}) -> no longer crashes the compiler.({a: b = 1}) ->Improved the internal representation of a CoffeeScript program. This is only noticeable to tools that use CoffeeScript.tokens or CoffeeScript.nodes. Such tools need to update to take account for changed or added tokens and nodes.CoffeeScript.tokensCoffeeScript.nodesSeveral minor bug fixes, including: The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks. Unassignable parameter destructuring no longer crashes the compiler. Source maps are now used correctly for errors thrown from .coffee.md files. coffee -e 'throw null' no longer crashes. The REPL no longer crashes when using .exit to exit it. Invalid JavaScript is no longer output when lots of for loops are used in the same scope. A unicode issue when using stdin with the CLI. The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks. Unassignable parameter destructuring no longer crashes the compiler. Source maps are now used correctly for errors thrown from .coffee.md files. coffee -e 'throw null' no longer crashes. The REPL no longer crashes when using .exit to exit it. Invalid JavaScript is no longer output when lots of for loops are used in the same scope. A unicode issue when using stdin with the CLI. The caught error in catch blocks is no longer declared unnecessarily, and no longer mistakenly named undefined for catch-less try blocks.catchundefinedcatchtryUnassignable parameter destructuring no longer crashes the compiler.Source maps are now used correctly for errors thrown from .coffee.md files.coffee -e 'throw null' no longer crashes.coffee -e 'throw null'The REPL no longer crashes when using .exit to exit it..exitInvalid JavaScript is no longer output when lots of for loops are used in the same scope.forA unicode issue when using stdin with the CLI.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.10.0","title":"1.10.0 - 2015-09-03","content":"1.10.0    — 2015-09-03 1.10.0 — 2015-09-032015-09-03 CoffeeScript now supports ES2015-style destructuring defaults. (offsetHeight: height) -> no longer compiles. That syntax was accidental and partly broken. Use ({offsetHeight: height}) -> instead. Object destructuring always requires braces. Several minor bug fixes, including: A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier. A problem with multiple JS contexts in the jest test framework. An error in io.js where strict mode is set on internal modules. A variable name clash for the caught error in catch blocks. CoffeeScript now supports ES2015-style destructuring defaults.(offsetHeight: height) -> no longer compiles. That syntax was accidental and partly broken. Use ({offsetHeight: height}) -> instead. Object destructuring always requires braces.(offsetHeight: height) ->({offsetHeight: height}) ->Several minor bug fixes, including: A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier. A problem with multiple JS contexts in the jest test framework. An error in io.js where strict mode is set on internal modules. A variable name clash for the caught error in catch blocks. A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier. A problem with multiple JS contexts in the jest test framework. An error in io.js where strict mode is set on internal modules. A variable name clash for the caught error in catch blocks. A bug where the REPL would sometimes report valid code as invalid, based on what you had typed earlier.A problem with multiple JS contexts in the jest test framework.An error in io.js where strict mode is set on internal modules.A variable name clash for the caught error in catch blocks.catch","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.9.3","title":"1.9.3 - 2015-05-27","content":"1.9.3    — 2015-05-27 1.9.3 — 2015-05-272015-05-27 Bugfix for interpolation in the first key of an object literal in an implicit call. Fixed broken error messages in the REPL, as well as a few minor bugs with the REPL. Fixed source mappings for tokens at the beginning of lines when compiling with the --bare option. This has the nice side effect of generating smaller source maps. Slight formatting improvement of compiled block comments. Better error messages for on, off, yes and no. Bugfix for interpolation in the first key of an object literal in an implicit call.Fixed broken error messages in the REPL, as well as a few minor bugs with the REPL.Fixed source mappings for tokens at the beginning of lines when compiling with the --bare option. This has the nice side effect of generating smaller source maps.--bareSlight formatting improvement of compiled block comments.Better error messages for on, off, yes and no.onoffyesno","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.9.2","title":"1.9.2 - 2015-04-15","content":"1.9.2    — 2015-04-15 1.9.2 — 2015-04-152015-04-15 Fixed a watch mode error introduced in 1.9.1 when compiling multiple files with the same filename. Bugfix for yield around expressions containing this. Added a Ruby-style -r option to the REPL, which allows requiring a module before execution with --eval or --interactive. In <script type=\"text/coffeescript\"> tags, to avoid possible duplicate browser requests for .coffee files, you can now use the data-src attribute instead of src. Minor bug fixes for IE8, strict ES5 regular expressions and Browserify. Fixed a watch mode error introduced in 1.9.1 when compiling multiple files with the same filename.watchBugfix for yield around expressions containing this.yieldthisAdded a Ruby-style -r option to the REPL, which allows requiring a module before execution with --eval or --interactive.-r--eval--interactiveIn <script type=\"text/coffeescript\"> tags, to avoid possible duplicate browser requests for .coffee files, you can now use the data-src attribute instead of src.<script type=\"text/coffeescript\">data-srcsrcMinor bug fixes for IE8, strict ES5 regular expressions and Browserify.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.9.1","title":"1.9.1 - 2015-02-18","content":"1.9.1    — 2015-02-18 1.9.1 — 2015-02-182015-02-18 Interpolation now works in object literal keys (again). You can use this to dynamically name properties. Internal compiler variable names no longer start with underscores. This makes the generated JavaScript a bit prettier, and also fixes an issue with the completely broken and ungodly way that AngularJS “parses” function arguments. Fixed a few yield-related edge cases with yield return and yield throw. Minor bug fixes and various improvements to compiler error messages. Interpolation now works in object literal keys (again). You can use this to dynamically name properties.Internal compiler variable names no longer start with underscores. This makes the generated JavaScript a bit prettier, and also fixes an issue with the completely broken and ungodly way that AngularJS “parses” function arguments.Fixed a few yield-related edge cases with yield return and yield throw.yieldyield returnyield throwMinor bug fixes and various improvements to compiler error messages.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.9.0","title":"1.9.0 - 2015-01-29","content":"1.9.0    — 2015-01-29 1.9.0 — 2015-01-292015-01-29 CoffeeScript now supports ES2015 generators. A generator is simply a function that yields. More robust parsing and improved error messages for strings and regexes — especially with respect to interpolation. Changed strategy for the generation of internal compiler variable names. Note that this means that @example function parameters are no longer available as naked example variables within the function body. Fixed REPL compatibility with latest versions of Node and Io.js. Various minor bug fixes. CoffeeScript now supports ES2015 generators. A generator is simply a function that yields.yieldMore robust parsing and improved error messages for strings and regexes — especially with respect to interpolation.Changed strategy for the generation of internal compiler variable names. Note that this means that @example function parameters are no longer available as naked example variables within the function body.@exampleexampleFixed REPL compatibility with latest versions of Node and Io.js.Various minor bug fixes.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.8.0","title":"1.8.0 - 2014-08-26","content":"1.8.0    — 2014-08-26 1.8.0 — 2014-08-262014-08-26 The --join option of the CLI is now deprecated. Source maps now use .js.map as file extension, instead of just .map. The CLI now exits with the exit code 1 when it fails to write a file to disk. The compiler no longer crashes on unterminated, single-quoted strings. Fixed location data for string interpolations, which made source maps out of sync. The error marker in error messages is now correctly positioned if the code is indented with tabs. Fixed a slight formatting error in CoffeeScript’s source map-patched stack traces. The %% operator now coerces its right operand only once. It is now possible to require CoffeeScript files from Cakefiles without having to register the compiler first. The CoffeeScript REPL is now exported and can be required using require 'coffeescript/repl'. Fixes for the REPL in Node 0.11. The --join option of the CLI is now deprecated.--joinSource maps now use .js.map as file extension, instead of just .map..js.map.mapThe CLI now exits with the exit code 1 when it fails to write a file to disk.The compiler no longer crashes on unterminated, single-quoted strings.Fixed location data for string interpolations, which made source maps out of sync.The error marker in error messages is now correctly positioned if the code is indented with tabs.Fixed a slight formatting error in CoffeeScript’s source map-patched stack traces.The %% operator now coerces its right operand only once.%%It is now possible to require CoffeeScript files from Cakefiles without having to register the compiler first.The CoffeeScript REPL is now exported and can be required using require 'coffeescript/repl'.require 'coffeescript/repl'Fixes for the REPL in Node 0.11.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.7.1","title":"1.7.1 - 2014-01-29","content":"1.7.1    — 2014-01-29 1.7.1 — 2014-01-292014-01-29 Fixed a typo that broke node module lookup when running a script directly with the coffee binary. Fixed a typo that broke node module lookup when running a script directly with the coffee binary.coffee","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.7.0","title":"1.7.0 - 2014-01-28","content":"1.7.0    — 2014-01-28 1.7.0 — 2014-01-282014-01-28 When requiring CoffeeScript files in Node you must now explicitly register the compiler. This can be done with require 'coffeescript/register' or CoffeeScript.register(). Also for configuration such as Mocha’s, use coffeescript/register. Improved error messages, source maps and stack traces. Source maps now use the updated //# syntax. Leading . now closes all open calls, allowing for simpler chaining syntax. Added **, // and %% operators and ... expansion in parameter lists and destructuring expressions. Multiline strings are now joined by a single space and ignore all indentation. A backslash at the end of a line can denote the amount of whitespace between lines, in both strings and heredocs. Backslashes correctly escape whitespace in block regexes. Closing brackets can now be indented and therefore no longer cause unexpected error. Several breaking compilation fixes. Non-callable literals (strings, numbers etc.) don’t compile in a call now and multiple postfix conditionals compile properly. Postfix conditionals and loops always bind object literals. Conditional assignment compiles properly in subexpressions. super is disallowed outside of methods and works correctly inside for loops. Formatting of compiled block comments has been improved. No more -p folders on Windows. The options object passed to CoffeeScript is no longer mutated. When requiring CoffeeScript files in Node you must now explicitly register the compiler. This can be done with require 'coffeescript/register' or CoffeeScript.register(). Also for configuration such as Mocha’s, use coffeescript/register.require 'coffeescript/register'CoffeeScript.register()coffeescript/registerImproved error messages, source maps and stack traces. Source maps now use the updated //# syntax.//#Leading . now closes all open calls, allowing for simpler chaining syntax..Added **, // and %% operators and ... expansion in parameter lists and destructuring expressions.**//%%...Multiline strings are now joined by a single space and ignore all indentation. A backslash at the end of a line can denote the amount of whitespace between lines, in both strings and heredocs. Backslashes correctly escape whitespace in block regexes.Closing brackets can now be indented and therefore no longer cause unexpected error.Several breaking compilation fixes. Non-callable literals (strings, numbers etc.) don’t compile in a call now and multiple postfix conditionals compile properly. Postfix conditionals and loops always bind object literals. Conditional assignment compiles properly in subexpressions. super is disallowed outside of methods and works correctly inside for loops.superforFormatting of compiled block comments has been improved.No more -p folders on Windows.-pThe options object passed to CoffeeScript is no longer mutated.options","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.6.3","title":"1.6.3 - 2013-06-02","content":"1.6.3    — 2013-06-02 1.6.3 — 2013-06-022013-06-02 The CoffeeScript REPL now remembers your history between sessions. Just like a proper REPL should. You can now use require in Node to load .coffee.md Literate CoffeeScript files. In the browser, text/literate-coffeescript script tags. The old coffee --lint command has been removed. It was useful while originally working on the compiler, but has been surpassed by JSHint. You may now use -l to pass literate files in over stdio. Bugfixes for Windows path separators, catch without naming the error, and executable-class-bodies-with- prototypal-property-attachment. The CoffeeScript REPL now remembers your history between sessions. Just like a proper REPL should.You can now use require in Node to load .coffee.md Literate CoffeeScript files. In the browser, text/literate-coffeescript script tags.require.coffee.mdtext/literate-coffeescriptThe old coffee --lint command has been removed. It was useful while originally working on the compiler, but has been surpassed by JSHint. You may now use -l to pass literate files in over stdio.coffee --lint-lstdioBugfixes for Windows path separators, catch without naming the error, and executable-class-bodies-with- prototypal-property-attachment.catch","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.6.2","title":"1.6.2 - 2013-03-18","content":"1.6.2    — 2013-03-18 1.6.2 — 2013-03-182013-03-18 Source maps have been used to provide automatic line-mapping when running CoffeeScript directly via the coffee command, and for automatic line-mapping when running CoffeeScript directly in the browser. Also, to provide better error messages for semantic errors thrown by the compiler — with colors, even. Improved support for mixed literate/vanilla-style CoffeeScript projects, and generating source maps for both at the same time. Fixes for 1.6.x regressions with overriding inherited bound functions, and for Windows file path management. The coffee command can now correctly fork() both .coffee and .js files. (Requires Node.js 0.9+) Source maps have been used to provide automatic line-mapping when running CoffeeScript directly via the coffee command, and for automatic line-mapping when running CoffeeScript directly in the browser. Also, to provide better error messages for semantic errors thrown by the compiler — with colors, even.coffeewith colors, evenImproved support for mixed literate/vanilla-style CoffeeScript projects, and generating source maps for both at the same time.Fixes for 1.6.x regressions with overriding inherited bound functions, and for Windows file path management.1.6.xThe coffee command can now correctly fork() both .coffee and .js files. (Requires Node.js 0.9+)coffeefork().coffee.js","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.6.1","title":"1.6.1 - 2013-03-05","content":"1.6.1    — 2013-03-05 1.6.1 — 2013-03-052013-03-05 First release of source maps. Pass the --map flag to the compiler, and off you go. Direct all your thanks over to Jason Walton. Fixed a 1.5.0 regression with multiple implicit calls against an indented implicit object. Combinations of implicit function calls and implicit objects should generally be parsed better now — but it still isn’t good style to nest them too heavily. .coffee.md is now also supported as a Literate CoffeeScript file extension, for existing tooling. .litcoffee remains the canonical one. Several minor fixes surrounding member properties, bound methods and super in class declarations. First release of source maps. Pass the --map flag to the compiler, and off you go. Direct all your thanks over to Jason Walton.source maps--mapJason WaltonFixed a 1.5.0 regression with multiple implicit calls against an indented implicit object. Combinations of implicit function calls and implicit objects should generally be parsed better now — but it still isn’t good style to nest them too heavily.style.coffee.md is now also supported as a Literate CoffeeScript file extension, for existing tooling. .litcoffee remains the canonical one..coffee.md.litcoffeeSeveral minor fixes surrounding member properties, bound methods and super in class declarations.super","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.5.0","title":"1.5.0 - 2013-02-25","content":"1.5.0    — 2013-02-25 1.5.0 — 2013-02-252013-02-25 First release of Literate CoffeeScript. The CoffeeScript REPL is now based on the Node.js REPL, and should work better and more familiarly. Returning explicit values from constructors is now forbidden. If you want to return an arbitrary value, use a function, not a constructor. You can now loop over an array backwards, without having to manually deal with the indexes: for item in list by -1 Source locations are now preserved in the CoffeeScript AST, although source maps are not yet being emitted. First release of Literate CoffeeScript.Literate CoffeeScriptThe CoffeeScript REPL is now based on the Node.js REPL, and should work better and more familiarly.Returning explicit values from constructors is now forbidden. If you want to return an arbitrary value, use a function, not a constructor.You can now loop over an array backwards, without having to manually deal with the indexes: for item in list by -1for item in list by -1Source locations are now preserved in the CoffeeScript AST, although source maps are not yet being emitted.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.4.0","title":"1.4.0 - 2012-10-23","content":"1.4.0    — 2012-10-23 1.4.0 — 2012-10-232012-10-23 The CoffeeScript compiler now strips Microsoft’s UTF-8 BOM if it exists, allowing you to compile BOM-borked source files. Fix Node/compiler deprecation warnings by removing registerExtension, and moving from path.exists to fs.exists. Small tweaks to splat compilation, backticks, slicing, and the error for duplicate keys in object literals. The CoffeeScript compiler now strips Microsoft’s UTF-8 BOM if it exists, allowing you to compile BOM-borked source files.Fix Node/compiler deprecation warnings by removing registerExtension, and moving from path.exists to fs.exists.registerExtensionpath.existsfs.existsSmall tweaks to splat compilation, backticks, slicing, and the error for duplicate keys in object literals.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.3.3","title":"1.3.3 - 2012-05-15","content":"1.3.3    — 2012-05-15 1.3.3 — 2012-05-152012-05-15 Due to the new semantics of JavaScript’s strict mode, CoffeeScript no longer guarantees that constructor functions have names in all runtimes. See #2052 for discussion. Inside of a nested function inside of an instance method, it’s now possible to call super more reliably (walks recursively up). Named loop variables no longer have different scoping heuristics than other local variables. (Reverts #643) Fix for splats nested within the LHS of destructuring assignment. Corrections to our compile time strict mode forbidding of octal literals. Due to the new semantics of JavaScript’s strict mode, CoffeeScript no longer guarantees that constructor functions have names in all runtimes. See #2052 for discussion.#2052Inside of a nested function inside of an instance method, it’s now possible to call super more reliably (walks recursively up).superNamed loop variables no longer have different scoping heuristics than other local variables. (Reverts #643)Fix for splats nested within the LHS of destructuring assignment.Corrections to our compile time strict mode forbidding of octal literals.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.3.1","title":"1.3.1 - 2012-04-10","content":"1.3.1    — 2012-04-10 1.3.1 — 2012-04-102012-04-10 CoffeeScript now enforces all of JavaScript’s Strict Mode early syntax errors at compile time. This includes old-style octal literals, duplicate property names in object literals, duplicate parameters in a function definition, deleting naked variables, setting the value of eval or arguments, and more. See a full discussion at #1547. The REPL now has a handy new multi-line mode for entering large blocks of code. It’s useful when copy-and-pasting examples into the REPL. Enter multi-line mode with Ctrl-V. You may also now pipe input directly into the REPL. CoffeeScript now prints a Generated by CoffeeScript VERSION header at the top of each compiled file. Conditional assignment of previously undefined variables a or= b is now considered a syntax error. A tweak to the semantics of do, which can now be used to more easily simulate a namespace: do (x = 1, y = 2) -> … Loop indices are now mutable within a loop iteration, and immutable between them. Both endpoints of a slice are now allowed to be omitted for consistency, effectively creating a shallow copy of the list. Additional tweaks and improvements to coffee --watch under Node’s “new” file watching API. Watch will now beep by default if you introduce a syntax error into a watched script. We also now ignore hidden directories by default when watching recursively. CoffeeScript now enforces all of JavaScript’s Strict Mode early syntax errors at compile time. This includes old-style octal literals, duplicate property names in object literals, duplicate parameters in a function definition, deleting naked variables, setting the value of eval or arguments, and more. See a full discussion at #1547.Strict Modeevalarguments#1547The REPL now has a handy new multi-line mode for entering large blocks of code. It’s useful when copy-and-pasting examples into the REPL. Enter multi-line mode with Ctrl-V. You may also now pipe input directly into the REPL.Ctrl-VCoffeeScript now prints a Generated by CoffeeScript VERSION header at the top of each compiled file.Generated by CoffeeScript VERSIONConditional assignment of previously undefined variables a or= b is now considered a syntax error.a or= bA tweak to the semantics of do, which can now be used to more easily simulate a namespace: do (x = 1, y = 2) -> …dodo (x = 1, y = 2) -> …Loop indices are now mutable within a loop iteration, and immutable between them.Both endpoints of a slice are now allowed to be omitted for consistency, effectively creating a shallow copy of the list.Additional tweaks and improvements to coffee --watch under Node’s “new” file watching API. Watch will now beep by default if you introduce a syntax error into a watched script. We also now ignore hidden directories by default when watching recursively.coffee --watch","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.2.0","title":"1.2.0 - 2011-12-18","content":"1.2.0    — 2011-12-18 1.2.0 — 2011-12-182011-12-18 Multiple improvements to coffee --watch and --join. You may now use both together, as well as add and remove files and directories within a --watch’d folder. The throw statement can now be used as part of an expression. Block comments at the top of the file will now appear outside of the safety closure wrapper. Fixed a number of minor 1.1.3 regressions having to do with trailing operators and unfinished lines, and a more major 1.1.3 regression that caused bound functions within bound class functions to have the incorrect this. Multiple improvements to coffee --watch and --join. You may now use both together, as well as add and remove files and directories within a --watch’d folder.coffee --watch--join--watchThe throw statement can now be used as part of an expression.throwBlock comments at the top of the file will now appear outside of the safety closure wrapper.Fixed a number of minor 1.1.3 regressions having to do with trailing operators and unfinished lines, and a more major 1.1.3 regression that caused bound functions within bound class functions to have the incorrect this.withinthis","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.1.3","title":"1.1.3 - 2011-11-08","content":"1.1.3    — 2011-11-08 1.1.3 — 2011-11-082011-11-08 Ahh, whitespace. CoffeeScript’s compiled JS now tries to space things out and keep it readable, as you can see in the examples on this page. You can now call super in class level methods in class bodies, and bound class methods now preserve their correct context. JavaScript has always supported octal numbers 010 is 8, and hexadecimal numbers 0xf is 15, but CoffeeScript now also supports binary numbers: 0b10 is 2. The CoffeeScript module has been nested under a subdirectory to make it easier to require individual components separately, without having to use npm. For example, after adding the CoffeeScript folder to your path: require('coffeescript/lexer') There’s a new “link” feature in Try CoffeeScript on this webpage. Use it to get a shareable permalink for your example script. The coffee --watch feature now only works on Node.js 0.6.0 and higher, but now also works properly on Windows. Lots of small bug fixes from @michaelficarra, @geraldalewis, @satyr, and @trevorburnham. Ahh, whitespace. CoffeeScript’s compiled JS now tries to space things out and keep it readable, as you can see in the examples on this page.You can now call super in class level methods in class bodies, and bound class methods now preserve their correct context.superJavaScript has always supported octal numbers 010 is 8, and hexadecimal numbers 0xf is 15, but CoffeeScript now also supports binary numbers: 0b10 is 2.010 is 80xf is 150b10 is 2The CoffeeScript module has been nested under a subdirectory to make it easier to require individual components separately, without having to use npm. For example, after adding the CoffeeScript folder to your path: require('coffeescript/lexer')requirenpmrequire('coffeescript/lexer')There’s a new “link” feature in Try CoffeeScript on this webpage. Use it to get a shareable permalink for your example script.The coffee --watch feature now only works on Node.js 0.6.0 and higher, but now also works properly on Windows.coffee --watchLots of small bug fixes from @michaelficarra, @geraldalewis, @satyr, and @trevorburnham.@michaelficarra@michaelficarra@geraldalewis@geraldalewis@satyr@satyr@trevorburnham@trevorburnham","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.1.2","title":"1.1.2 - 2011-08-04","content":"1.1.2    — 2011-08-04 1.1.2 — 2011-08-042011-08-04Fixes for block comment formatting, ?= compilation, implicit calls against control structures, implicit invocation of a try/catch block, variadic arguments leaking from local scope, line numbers in syntax errors following heregexes, property access on parenthesized number literals, bound class methods and super with reserved names, a REPL overhaul, consecutive compiled semicolons, block comments in implicitly called objects, and a Chrome bug.?=","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.1.1","title":"1.1.1 - 2011-05-10","content":"1.1.1    — 2011-05-10 1.1.1 — 2011-05-102011-05-10Bugfix release for classes with external constructor functions, see issue #1182.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.1.0","title":"1.1.0 - 2011-05-01","content":"1.1.0    — 2011-05-01 1.1.0 — 2011-05-012011-05-01When running via the coffee executable, process.argv and friends now report coffee instead of node. Better compatibility with Node.js 0.4.x module lookup changes. The output in the REPL is now colorized, like Node’s is. Giving your concatenated CoffeeScripts a name when using --join is now mandatory. Fix for lexing compound division /= as a regex accidentally. All text/coffeescript tags should now execute in the order they’re included. Fixed an issue with extended subclasses using external constructor functions. Fixed an edge-case infinite loop in addImplicitParentheses. Fixed exponential slowdown with long chains of function calls. Globals no longer leak into the CoffeeScript REPL. Splatted parameters are declared local to the function.coffeeprocess.argvcoffeenodeNode.js 0.4.x--join/=text/coffeescriptaddImplicitParentheses","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.0.1","title":"1.0.1 - 2011-01-31","content":"1.0.1    — 2011-01-31 1.0.1 — 2011-01-312011-01-31Fixed a lexer bug with Unicode identifiers. Updated REPL for compatibility with Node.js 0.3.7. Fixed requiring relative paths in the REPL. Trailing return and return undefined are now optimized away. Stopped requiring the core Node.js util module for back-compatibility with Node.js 0.2.5. Fixed a case where a conditional return would cause fallthrough in a switch statement. Optimized empty objects in destructuring assignment.returnreturn undefinedutilreturnswitch","dataLevel":3,"level":2,"parent":"changelog"},{"section":"1.0.0","title":"1.0.0 - 2010-12-24","content":"1.0.0    — 2010-12-24 1.0.0 — 2010-12-242010-12-24CoffeeScript loops no longer try to preserve block scope when functions are being generated within the loop body. Instead, you can use the do keyword to create a convenient closure wrapper. Added a --nodejs flag for passing through options directly to the node executable. Better behavior around the use of pure statements within expressions. Fixed inclusive slicing through -1, for all browsers, and splicing with arbitrary expressions as endpoints.do--nodejsnode-1","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.9.6","title":"0.9.6 - 2010-12-06","content":"0.9.6    — 2010-12-06 0.9.6 — 2010-12-062010-12-06The REPL now properly formats stacktraces, and stays alive through asynchronous exceptions. Using --watch now prints timestamps as files are compiled. Fixed some accidentally-leaking variables within plucked closure-loops. Constructors now maintain their declaration location within a class body. Dynamic object keys were removed. Nested classes are now supported. Fixes execution context for naked splatted functions. Bugfix for inversion of chained comparisons. Chained class instantiation now works properly with splats.--watch","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.9.5","title":"0.9.5 - 2010-11-21","content":"0.9.5    — 2010-11-21 0.9.5 — 2010-11-212010-11-210.9.5 should be considered the first release candidate for CoffeeScript 1.0. There have been a large number of internal changes since the previous release, many contributed from satyr’s Coco dialect of CoffeeScript. Heregexes (extended regexes) were added. Functions can now have default arguments. Class bodies are now executable code. Improved syntax errors for invalid CoffeeScript. undefined now works like null, and cannot be assigned a new value. There was a precedence change with respect to single-line comprehensions: result = i for i in list used to parse as result = (i for i in list) by default … it now parses as (result = i) for i in list.satyrCocoundefinednullresult = i for i in listresult = (i for i in list)(result = i) for i in list","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.9.4","title":"0.9.4 - 2010-09-21","content":"0.9.4    — 2010-09-21 0.9.4 — 2010-09-212010-09-21CoffeeScript now uses appropriately-named temporary variables, and recycles their references after use. Added require.extensions support for Node.js 0.3. Loading CoffeeScript in the browser now adds just a single CoffeeScript object to global scope. Fixes for implicit object and block comment edge cases.require.extensionsNode.js 0.3CoffeeScript","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.9.3","title":"0.9.3 - 2010-09-16","content":"0.9.3    — 2010-09-16 0.9.3 — 2010-09-162010-09-16CoffeeScript switch statements now compile into JS switch statements — they previously compiled into if/else chains for JavaScript 1.3 compatibility. Soaking a function invocation is now supported. Users of the RubyMine editor should now be able to use --watch mode.switchswitchif/else--watch","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.9.2","title":"0.9.2 - 2010-08-23","content":"0.9.2    — 2010-08-23 0.9.2 — 2010-08-232010-08-23Specifying the start and end of a range literal is now optional, eg. array[3..]. You can now say a not instanceof b. Fixed important bugs with nested significant and non-significant indentation (Issue #637). Added a --require flag that allows you to hook into the coffee command. Added a custom jsl.conf file for our preferred JavaScriptLint setup. Sped up Jison grammar compilation time by flattening rules for operations. Block comments can now be used with JavaScript-minifier-friendly syntax. Added JavaScript’s compound assignment bitwise operators. Bugfixes to implicit object literals with leading number and string keys, as the subject of implicit calls, and as part of compound assignment.array[3..]a not instanceof b--requirecoffeejsl.conf","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.9.1","title":"0.9.1 - 2010-08-11","content":"0.9.1    — 2010-08-11 0.9.1 — 2010-08-112010-08-11Bugfix release for 0.9.1. Greatly improves the handling of mixed implicit objects, implicit function calls, and implicit indentation. String and regex interpolation is now strictly #{ … } (Ruby style). The compiler now takes a --require flag, which specifies scripts to run before compilation.0.9.1#{ … }--require","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.9.0","title":"0.9.0 - 2010-08-04","content":"0.9.0    — 2010-08-04 0.9.0 — 2010-08-042010-08-04The CoffeeScript 0.9 series is considered to be a release candidate for 1.0; let’s give her a shakedown cruise. 0.9.0 introduces a massive backwards-incompatible change: Assignment now uses =, and object literals use :, as in JavaScript. This allows us to have implicit object literals, and YAML-style object definitions. Half assignments are removed, in favor of +=, or=, and friends. Interpolation now uses a hash mark # instead of the dollar sign $ — because dollar signs may be part of a valid JS identifier. Downwards range comprehensions are now safe again, and are optimized to straight for loops when created with integer endpoints. A fast, unguarded form of object comprehension was added: for all key, value of object. Mentioning the super keyword with no arguments now forwards all arguments passed to the function, as in Ruby. If you extend class B from parent class A, if A has an extended method defined, it will be called, passing in B — this enables static inheritance, among other things. Cleaner output for functions bound with the fat arrow. @variables can now be used in parameter lists, with the parameter being automatically set as a property on the object — useful in constructors and setter functions. Constructor functions can now take splats.0.91.00.9.0=:+=or=#$for all key, value of objectsuperBAAextendedB@variables","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.7.2","title":"0.7.2 - 2010-07-12","content":"0.7.2    — 2010-07-12 0.7.2 — 2010-07-122010-07-12Quick bugfix (right after 0.7.1) for a problem that prevented coffee command-line options from being parsed in some circumstances.coffee","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.7.1","title":"0.7.1 - 2010-07-11","content":"0.7.1    — 2010-07-11 0.7.1 — 2010-07-112010-07-11Block-style comments are now passed through and printed as JavaScript block comments – making them useful for licenses and copyright headers. Better support for running coffee scripts standalone via hashbangs. Improved syntax errors for tokens that are not in the grammar.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.7.0","title":"0.7.0 - 2010-06-28","content":"0.7.0    — 2010-06-28 0.7.0 — 2010-06-282010-06-28Official CoffeeScript variable style is now camelCase, as in JavaScript. Reserved words are now allowed as object keys, and will be quoted for you. Range comprehensions now generate cleaner code, but you have to specify by -1 if you’d like to iterate downward. Reporting of syntax errors is greatly improved from the previous release. Running coffee with no arguments now launches the REPL, with Readline support. The <- bind operator has been removed from CoffeeScript. The loop keyword was added, which is equivalent to a while true loop. Comprehensions that contain closures will now close over their variables, like the semantics of a forEach. You can now use bound function in class definitions (bound to the instance). For consistency, a in b is now an array presence check, and a of b is an object-key check. Comments are no longer passed through to the generated JavaScript.by -1coffee<-loopwhile trueforEacha in ba of b","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.6.2","title":"0.6.2 - 2010-05-15","content":"0.6.2    — 2010-05-15 0.6.2 — 2010-05-152010-05-15The coffee command will now preserve directory structure when compiling a directory full of scripts. Fixed two omissions that were preventing the CoffeeScript compiler from running live within Internet Explorer. There’s now a syntax for block comments, similar in spirit to CoffeeScript’s heredocs. ECMA Harmony DRY-style pattern matching is now supported, where the name of the property is the same as the name of the value: {name, length}: func. Pattern matching is now allowed within comprehension variables. unless is now allowed in block form. until loops were added, as the inverse of while loops. switch statements are now allowed without switch object clauses. Compatible with Node.js v0.1.95.coffee{name, length}: funcunlessuntilwhileswitchv0.1.95","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.6.1","title":"0.6.1 - 2010-04-12","content":"0.6.1    — 2010-04-12 0.6.1 — 2010-04-122010-04-12Upgraded CoffeeScript for compatibility with the new Node.js v0.1.90 series.v0.1.90","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.6.0","title":"0.6.0 - 2010-04-03","content":"0.6.0    — 2010-04-03 0.6.0 — 2010-04-032010-04-03Trailing commas are now allowed, a-la Python. Static properties may be assigned directly within class definitions, using @property notation.@property","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.5.6","title":"0.5.6 - 2010-03-23","content":"0.5.6    — 2010-03-23 0.5.6 — 2010-03-232010-03-23Interpolation can now be used within regular expressions and heredocs, as well as strings. Added the <- bind operator. Allowing assignment to half-expressions instead of special ||=-style operators. The arguments object is no longer automatically converted into an array. After requiring coffeescript, Node.js can now directly load .coffee files, thanks to registerExtension. Multiple splats can now be used in function calls, arrays, and pattern matching.<-||=coffeescript.coffeeregisterExtension","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.5.5","title":"0.5.5 - 2010-03-08","content":"0.5.5    — 2010-03-08 0.5.5 — 2010-03-082010-03-08String interpolation, contributed by Stan Angeloff. Since --run has been the default since 0.5.3, updating --stdio and --eval to run by default, pass --compile as well if you’d like to print the result.Stan Angeloff--run0.5.3--stdio--eval--compile","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.5.4","title":"0.5.4 - 2010-03-03","content":"0.5.4    — 2010-03-03 0.5.4 — 2010-03-032010-03-03Bugfix that corrects the Node.js global constants __filename and __dirname. Tweaks for more flexible parsing of nested function literals and improperly-indented comments. Updates for the latest Node.js API.__filename__dirname","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.5.3","title":"0.5.3 - 2010-02-27","content":"0.5.3    — 2010-02-27 0.5.3 — 2010-02-272010-02-27CoffeeScript now has a syntax for defining classes. Many of the core components (Nodes, Lexer, Rewriter, Scope, Optparse) are using them. Cakefiles can use optparse.coffee to define options for tasks. --run is now the default flag for the coffee command, use --compile to save JavaScripts. Bugfix for an ambiguity between RegExp literals and chained divisions.optparse.coffee--runcoffee--compile","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.5.2","title":"0.5.2 - 2010-02-25","content":"0.5.2    — 2010-02-25 0.5.2 — 2010-02-252010-02-25Added a compressed version of the compiler for inclusion in web pages as /v2/browser-compiler/coffeescript.js. It’ll automatically run any script tags with type text/coffeescript for you. Added a --stdio option to the coffee command, for piped-in compiles./v2/browser-compiler/coffeescript.jstext/coffeescript--stdiocoffee","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.5.1","title":"0.5.1 - 2010-02-24","content":"0.5.1    — 2010-02-24 0.5.1 — 2010-02-242010-02-24Improvements to null soaking with the existential operator, including soaks on indexed properties. Added conditions to while loops, so you can use them as filters with when, in the same manner as comprehensions.whilewhen","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.5.0","title":"0.5.0 - 2010-02-21","content":"0.5.0    — 2010-02-21 0.5.0 — 2010-02-212010-02-21CoffeeScript 0.5.0 is a major release, While there are no language changes, the Ruby compiler has been removed in favor of a self-hosting compiler written in pure CoffeeScript.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.3.2","title":"0.3.2 - 2010-02-08","content":"0.3.2    — 2010-02-08 0.3.2 — 2010-02-082010-02-08@property is now a shorthand for this.property. Switched the default JavaScript engine from Narwhal to Node.js. Pass the --narwhal flag if you’d like to continue using it.@propertythis.property--narwhal","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.3.0","title":"0.3.0 - 2010-01-26","content":"0.3.0    — 2010-01-26 0.3.0 — 2010-01-262010-01-26CoffeeScript 0.3 includes major syntax changes: The function symbol was changed to ->, and the bound function symbol is now =>. Parameter lists in function definitions must now be wrapped in parentheses. Added property soaking, with the ?. operator. Made parentheses optional, when invoking functions with arguments. Removed the obsolete block literal syntax.->=>?.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.2.6","title":"0.2.6 - 2010-01-17","content":"0.2.6    — 2010-01-17 0.2.6 — 2010-01-172010-01-17Added Python-style chained comparisons, the conditional existence operator ?=, and some examples from Beautiful Code. Bugfixes relating to statement-to-expression conversion, arguments-to-array conversion, and the TextMate syntax highlighter.?=Beautiful Code","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.2.5","title":"0.2.5 - 2010-01-13","content":"0.2.5    — 2010-01-13 0.2.5 — 2010-01-132010-01-13The conditions in switch statements can now take multiple values at once — If any of them are true, the case will run. Added the long arrow ==>, which defines and immediately binds a function to this. While loops can now be used as expressions, in the same way that comprehensions can. Splats can be used within pattern matches to soak up the rest of an array.==>this","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.2.4","title":"0.2.4 - 2010-01-12","content":"0.2.4    — 2010-01-12 0.2.4 — 2010-01-122010-01-12Added ECMAScript Harmony style destructuring assignment, for dealing with extracting values from nested arrays and objects. Added indentation-sensitive heredocs for nicely formatted strings or chunks of code.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.2.3","title":"0.2.3 - 2010-01-11","content":"0.2.3    — 2010-01-11 0.2.3 — 2010-01-112010-01-11Axed the unsatisfactory ino keyword, replacing it with of for object comprehensions. They now look like: for prop, value of object.inooffor prop, value of object","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.2.2","title":"0.2.2 - 2010-01-10","content":"0.2.2    — 2010-01-10 0.2.2 — 2010-01-102010-01-10When performing a comprehension over an object, use ino, instead of in, which helps us generate smaller, more efficient code at compile time. Added :: as a shorthand for saying .prototype. The “splat” symbol has been changed from a prefix asterisk *, to a postfix ellipsis ... Added JavaScript’s in operator, empty return statements, and empty while loops. Constructor functions that start with capital letters now include a safety check to make sure that the new instance of the object is returned. The extends keyword now functions identically to goog.inherits in Google’s Closure Library.inoin::.prototype.*...inreturnwhileextendsgoog.inherits","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.2.1","title":"0.2.1 - 2010-01-05","content":"0.2.1    — 2010-01-05 0.2.1 — 2010-01-052010-01-05Arguments objects are now converted into real arrays when referenced.","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.2.0","title":"0.2.0 - 2010-01-05","content":"0.2.0    — 2010-01-05 0.2.0 — 2010-01-052010-01-05Major release. Significant whitespace. Better statement-to-expression conversion. Splats. Splice literals. Object comprehensions. Blocks. The existential operator. Many thanks to all the folks who posted issues, with special thanks to Liam O’Connor-Davis for whitespace and expression help.Liam O’Connor-Davis","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.1.6","title":"0.1.6 - 2009-12-27","content":"0.1.6    — 2009-12-27 0.1.6 — 2009-12-272009-12-27Bugfix for running coffee --interactive and --run from outside of the CoffeeScript directory. Bugfix for nested function/if-statements.coffee --interactive--run","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.1.5","title":"0.1.5 - 2009-12-26","content":"0.1.5    — 2009-12-26 0.1.5 — 2009-12-262009-12-26Array slice literals and array comprehensions can now both take Ruby-style ranges to specify the start and end. JavaScript variable declaration is now pushed up to the top of the scope, making all assignment statements into expressions. You can use \\ to escape newlines. The coffeescript command is now called coffee.\\coffeescriptcoffee","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.1.4","title":"0.1.4 - 2009-12-25","content":"0.1.4    — 2009-12-25 0.1.4 — 2009-12-252009-12-25The official CoffeeScript extension is now .coffee instead of .cs, which properly belongs to C#. Due to popular demand, you can now also use = to assign. Unlike JavaScript, = can also be used within object literals, interchangeably with :. Made a grammatical fix for chained function calls like func(1)(2)(3)(4). Inheritance and super no longer use __proto__, so they should be IE-compatible now..coffee.csC#==:func(1)(2)(3)(4)__proto__","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.1.3","title":"0.1.3 - 2009-12-25","content":"0.1.3    — 2009-12-25 0.1.3 — 2009-12-252009-12-25The coffee command now includes --interactive, which launches an interactive CoffeeScript session, and --run, which directly compiles and executes a script. Both options depend on a working installation of Narwhal. The aint keyword has been replaced by isnt, which goes together a little smoother with is. Quoted strings are now allowed as identifiers within object literals: eg. {\"5+5\": 10}. All assignment operators now use a colon: +:, -:, *:, etc.coffee--interactive--runaintisntis{\"5+5\": 10}+:-:*:","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.1.2","title":"0.1.2 - 2009-12-24","content":"0.1.2    — 2009-12-24 0.1.2 — 2009-12-242009-12-24Fixed a bug with calling super() through more than one level of inheritance, with the re-addition of the extends keyword. Added experimental Narwhal support (as a Tusk package), contributed by Tom Robinson, including bin/cs as a CoffeeScript REPL and interpreter. New --no-wrap option to suppress the safety function wrapper.super()extendsNarwhalTom Robinsonbin/cs--no-wrap","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.1.1","title":"0.1.1 - 2009-12-24","content":"0.1.1    — 2009-12-24 0.1.1 — 2009-12-242009-12-24Added instanceof and typeof as operators.instanceoftypeof","dataLevel":3,"level":2,"parent":"changelog"},{"section":"0.1.0","title":"0.1.0 - 2009-12-24","content":"0.1.0    — 2009-12-24 0.1.0 — 2009-12-242009-12-24Initial CoffeeScript release.","dataLevel":3,"level":2,"parent":"changelog"}]};