import * as babel from "babel-core";

/**
 * CoffeeScript compiler options.
 *
 * @member ast If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @member bare If true, omit a top-level IIFE safety wrapper.
 * @member filename File name to compile - defaults to `index.js`.
 * @member header If true, output the `Generated by CoffeeScript` header.
 * @member inlineMap If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @member sourceMap If true, output a source map object with the code.
 * @member transpile Babel transpilation options - see `babel.TransformOptions`.
 */
export interface Options {
  ast?: boolean;
  bare?: boolean;
  filename?: string;
  header?: boolean;
  inlineMap?: boolean;
  sourceMap?: boolean;
  transpile?: babel.TransformOptions;
}

/**
 * CoffeeScript abstract syntax tree location data.
 */
export type ASTNodeLocationData =
  | {
      first_column: number;
      first_line: number;
      last_line: number;
      last_column: number;
    }
  | {
      end: number;
      loc: {
        end: {
          line: number;
          column: number;
        };
        start: {
          line: number;
          column: number;
        };
      };
      range: [number, number];
      start: number;
    };

/**
 * Range data interface for CoffeeScript abstract syntax tree nodes.
 */
export interface ASTNodeRange {
  from: ASTNode | null;
  to: ASTNode | null;
  exclusive: boolean;
  equals: string;
  locationData: ASTNodeLocationData;
}

/**
 * CoffeeScript's abstract syntax tree node interfaces with all possible node properties.
 */
export interface ASTNode {
  array?: boolean | ASTNode;
  asKey?: boolean;
  args?: ASTNode[];
  base?: ASTNode;
  body?: ASTBody | ASTNode;
  bound?: boolean;
  boundFuncs?: ASTNode[];
  cases?: ASTNode[][];
  classBody?: boolean;
  comments?: string[];
  condition?: ASTNode;
  context?: string;
  elseBody?: ASTNode | null;
  expression?: ASTNode;
  expressions?: ASTNode[];
  first?: ASTNode;
  flip?: boolean;
  generated?: boolean;
  guard?: ASTNode;
  index?: ASTNode;
  isChain?: boolean;
  isGenerator?: boolean;
  isNew?: boolean;
  isSuper?: boolean;
  locationData: ASTNodeLocationData;
  name?: ASTNode;
  negated?: boolean;
  object?: boolean | ASTNode;
  objects?: ASTNode[];
  operator?: string;
  otherwise?: ASTNode;
  own?: boolean;
  param?: boolean;
  params?: ASTNode[];
  parent?: ASTNode | null;
  pattern?: boolean;
  properties?: ASTNode[];
  range?: boolean | ASTNodeRange[];
  returns?: boolean;
  subject?: ASTNode;
  second?: ASTNode;
  soak?: boolean;
  source?: ASTNode;
  subpattern?: boolean;
  this?: boolean;
  val?: string;
  value?: ASTNode | string;
  variable?: ASTNode;
}

/**
 * Container interface for CoffeeScript abstract syntax trees.
 */
export interface ASTBody {
  classBody?: boolean;
  expressions: ASTNode[] | [];
  locationData: ASTNodeLocationData;
}

/**
 * Syntax error thrown by CoffeeScript compiler.
 *
 * @member code Source code that generated the `coffee` compiler error
 * @member filename File name for invalid CoffeeScript resource.
 * @member location Starting and ending location data.
 * @member stack String representation of syntax error.
 * @member toString Stack trace generator for error.
 */
export interface SyntaxError {
  code?: string;
  filename?: string;
  location: ASTNodeLocationData;
  stack: ReturnType<SyntaxError["toString"]>;
  toString: () => string;
}

/**
 * Options for `coffeescript.helpers.replaceUnicodeCodePointEscapes`.
 *
 * @member {string} [delimiter]
 *   Separator between two Unicode characters in `str` parameter of
 *   `coffeescript.helpers.replaceUnicodeCodePointEscapes`.
 * @member {string} [error=unicode code point escapes greater than \\u{10ffff} are not allowed]
 *   Error message if `coffeescript.helpers.replaceUnicodeCodePointEscapes` fails.
 * @member {string} [flags]
 *   Which flags are present in the regular expression for the replacement operation.
 *   Must include `u` if provided to support Unicode escapes.
 */
export interface ReplaceUnicodeCodePointEscapesOptions {
  error?: string;
  flags?: string;
  delimiter?: string;
}

/**
 * List of precompiled CoffeeScript file extensions.
 */
export let FILE_EXTENSIONS: [".coffee", ".coffee.md", ".litcoffee"];

/**
 * Version number of the CoffeeScript compiler.
 */
export let VERSION: string;

/**
 * Helpers used internally to compile CoffeeScript code.
 *
 * @deprecated Unstable and designed for internal use.
 */
export interface helpers {
  /**
   * Peek at the start of a given string to see if it matches a sequence.
   *
   * @param {string} string Target string to check the prefix literal against.
   * @param {string} literal Literal string to use for the prefix check.
   * @param {number} start Zero-indexed starting position of the prefix.
   *   The offset preceding the first character of the string is `0`.
   * @returns {boolean} Whether the `literal` prefix is found in `string`
   *   at the provided `start` position.
   */
  starts(string: string, literal: string, start: number): boolean;
  /**
   * Peek at the end of a given string to see if it matches a sequence.
   *
   * @param {string} string Target string to check the suffix literal against.
   * @param {string} literal Literal string to use for the suffix check.
   * @param {number} [back=0] Zero-indexed backtracking position of the prefix.
   *   The offset following the last character of the string is `0`.
   * @returns {boolean} Whether the `literal` suffix is found in `string`
   *   at the backtracking position or end of the string.
   */
  ends(string: string, literal: string, back?: number): boolean;
  /**
   * Repeat a string `n` times.
   * Uses a clever algorithm to have O(log(n)) string concatenation operations.
   *
   * @param {string} str String to repeat.
   * @param {number} n 1-indexed number of repetitions.
   * @returns {string} Repeated string.
   */
  repeat(str: string, n: number): string;
  /**
   * Trim out all falsy values from an array.
   *
   * @param {Array} array Array of boolean-operator indeterminate values.
   * @returns {Array} Array of truthy values.
   */
  compact(array: any[]): any[];
  /**
   * Count the number of occurrences of a search string in another string.
   *
   * @param {string} string Target string to search.
   * @param {string} substring Search string to compute against target.
   * @returns {number} Number of times the search string appears in the
   *   target string.
   */
  count(string: string, substr: any): number;
  /**
   * Merge objects, returning a fresh copy with attributes from both sides.
   * Used every time `CoffeeScript.compile` is called, to allow properties in the
   * options hash to propagate down the tree without polluting other branches.
   *
   * @param {object} options  Original, target object for merge operation.
   * @param {object} overrides Map of override key-values for merge operation.
   * @returns {object} Cloned object that merges `options` with `overrides`. The
   *   `overrides` properties have a higher merge priority than `options` properties.
   */
  merge(options: object, overrides: object): object;
  /**
   * Extend a source object with the properties of another object (shallow copy).
   *
   * @param {object} object Target object to extend.
   * @param {object} properties Source object to extend the source object.
   * @returns {object} The original `object` extended by the `properties` object.
   */
  extend(object: object, properties: object): object;
  /**
   * Flattens an array recursively.
   * Handy for getting a list of descendants from the nodes.
   *
   * @param {Array} array Array containing array and non-array elements.
   * @returns {Array} A flattened version of the array with an array depth of `0`.
   */
  flatten(array: any[]): any[];
  /**
   * Delete a key from an object, returning the value. Useful when a node is
   * looking for a particular method in an options hash.
   *
   * @param {object} obj Object to delete a key from.
   * @param {*} key Target key of object for the deletion operation.
   * @returns {*} The value of the deleted object entry.
   */
  del(obj: object, key: any): any;
  /**
   * Polyfill for `Array.prototype.some` used pre-transpilation in the compiler.
   * Determines whether the specified callback function returns true for any
   * element of an array.
   *
   * @this {Array} Array instance or prototype to polyfill.
   * @param {function} fn Predicate function test for each array element.
   * @returns {boolean} Whether one or more elements return `true` when passed to
   *   the predicate `fn(...)`.
   */
  some:
    | typeof Array.prototype.some
    | ((this: any[], predicate: (value: any) => unknown) => boolean);
  /**
   * Helper function for extracting code from Literate CoffeeScript by stripping
   * out all non-code blocks, producing a string of CoffeeScript code that can
   * be compiled "normally."
   *
   * @param {string} code Literate CoffeeScript code to extract code blocks from.
   * @returns {string} CoffeeScript code without surrounding Markdown documentation.
   */
  invertLiterate(code: string): string;
  /**
   * Build a list of all comments attached to tokens.
   *
   * @param {CoffeeScriptASTNode[]} tokens Collection of CoffeeScript abstract
   *   syntax tree tokens, all sorted by source order.
   * @returns {string[]} List of comment strings present in CoffeeScript AST.
   */
  extractAllCommentTokens(tokens: any[]): string[];
  /**
   * Build a dictionary of token comments organized by tokensâ€™ locations
   * used as lookup hashes.
   *
   * Though multiple tokens can have the same location hash, using exclusive
   * location data allows to distinguish between zero-length generated tokens and
   * actual source tokens, for example.
   *
   * The ranges for "overlapping" tokens with the same location data and
   * and matching token hashes are merged into one array.
   *
   * If there are duplicate comments, they will get sorted out later.
   *
   * @param {CoffeeScriptASTNode[]} tokens List of CoffeeScript abstract syntax
   *   tree tokens with or without comments.
   * @returns {object} Hashmap of token comments vs token location offsets.
   */
  buildTokenDataDictionary(tokens: any[]): object;
  /**
   * Generates a setter function that updates the location data of an object
   * if it is a CoffeeScript abstract syntax tree node.
   *
   * @param {object} parserState CoffeeScript parser state.
   * @param {CoffeeScriptASTLocationData} firstLocationData Location data for first node.
   * @param {CoffeeScriptASTNode} firstValue Abstract syntax tree for first node.
   * @param {CoffeeScriptASTLocationData} lastLocationData Location data for last node.
   * @param {CoffeeScriptASTNode} lastValue Abstract syntax tree for first node.
   * @param {boolean} [forceUpdateLocation=true] Whether to override the location data of the
   *   container and child nodes if the container has location data already.
   */
  addDataToNode(
    parserState: object,
    firstLocationData: any,
    firstValue: any,
    lastLocationData: any,
    lastValue: any,
    forceUpdateLocation?: boolean
  ): (obj: any) => any;
  /**
   * Attaches a set of comments to the supplied node.
   *
   * @param {string[]} comments Collection of comment strings.
   * @param {CofffeScriptASTNode} node Node associated with `comments`.
   * @returns {CofffeScriptASTNode} The `node` merged with the `comments` array.
   */
  attachCommentsToNode(comments: string[], node: any): any;
  /**
   * Convert JISON location data to a string.
   *
   * @param obj Token or `CoffeeScriptASTLocationData` object.
   * @returns {string} String representation of location data.
   */
  locationDataToString(obj: any): string;
  /**
   * A `.coffee.md` compatible version of `path.basename`.
   *
   * @param {string} file File name path. Can be relative, absolute or missing a directory.
   * @param {boolean} [stripExt=false]
   * @param {*} [useWinPathSep=false] Whether to  use the Windows path separator `\`
   *   as well as the Unix path separator `/`.
   * @returns {string} File name without extension.
   */
  baseFileName(file: string, stripExt?: boolean, useWinPathSep?: any): string;
  /**
   * Determine if a filename represents a CoffeeScript file.
   * A CoffeeScript file has the file extensions `.coffee`, `.coffee.md` or
   * `.litcoffee`.
   *
   * @param {string} file Filename without directories.
   * @returns {boolean} Whether a filename is a CoffeeScript file.
   */
  isCoffee(file: string): boolean;
  /**
   * Determine if a filename represents a Literate CoffeeScript file.
   * A Literate CoffeeScript file has the file extensions `.litcoffee`,
   * or `.coffee.md`.
   *
   * @param {string} file Filename without directories.
   * @returns {boolean} Whether a filename is a CoffeeScript file.
   */
  isLiterate(file: string): boolean;
  /**
   * Throws a `CoffeeScriptSyntaxError` from a given location.
   * The error's `toString` will return an error message following the "standard"
   * format `<filename>:<line>:<col>: <message>` plus the line with the error and a
   * marker showing where the error is.
   *
   * Instead of showing the compiler's stacktrace, show our custom error message
   * (this is useful when the error bubbles up in Node.js applications that
   * compile CoffeeScript for example).
   *
   * @throws {CoffeeScriptSyntaxError} Error object with location data and string
   *   representation.
   */
  throwSyntaxError(message: any, location: any): never;
  /**
   * Update a compiler `SyntaxError` with source code information if it didn't have
   * it already.
   *
   * @param {CoffeeScriptSyntaxError} error Syntax error with or without source code
   *   information.
   * @param {string} code Source code that produced the syntax error.
   * @param {string} filename File name for invalid CoffeeScript resource.
   * @returns {CoffeeScriptSyntaxError} Syntax error with source code.
   */
  updateSyntaxError(error: any, code: string, filename: string): any;
  /**
   * Maps a whitespace character to a character name.
   *
   * @param {string} Single-character string.
   * @returns {string} Human-readable identifier for whitespace character, or the
   * `string` parameter.
   */
  nameWhitespaceCharacter(string: any): string;
  /**
   * Parses a CoffeeScript number string to a primitive JS number.
   *
   * @param {string} string String representation of a number.
   * @retuns {number} Parsed float or integer corresponding to number.
   */
  parseNumber(string: string): number;
  /**
   * Checks if a value is a function.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a function.
   */
  isFunction(obj: any): boolean;
  /**
   * Checks if a value is a number.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a number.
   */
  isNumber(obj: any): boolean;
  /**
   * Checks if an value is a string.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a string.
   */
  isString(obj: any): boolean;
  /**
   * Checks if an value is a primitive boolean or `Boolean` instance.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a boolean.
   */
  isBoolean(obj: any): boolean;
  /**
   * Checks if an value is a literal JS object - `{}`.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a literal JS object.
   */
  isPlainObject(obj: any): boolean;
  /**
   * Replace `\u{...}` with `\uxxxx[\uxxxx]` in regexes without the `u` flag.
   *
   * @param {string} str String that may contain Unicode brace syntax - `\u{...}`.
   * @param {object} options Options for Unicode replacement.
   * @member {string} [options.delimiter]
   *   Separator between two Unicode characters in `str` parameter of
   *   `coffeescript.helpers.replaceUnicodeCodePointEscapes`.
   * @member {string} [options.error=unicode code point escapes greater than \\u{10ffff} are not allowed]
   *   Error message if `coffeescript.helpers.replaceUnicodeCodePointEscapes` fails.
   * @member {string} [options.flags]
   *   Which flags are present in the regular expression for the replacement operation.
   *   Must include `u` if provided to support Unicode escapes.
   * @returns RegExp string with Unicode brace groups in the format `\uxxxx[\uxxxx]`.
   */
  replaceUnicodeCodePointEscapes(str: string, options?: ReplaceUnicodeCodePointEscapesOptions): string;
}

/**
 * Transpiles CoffeeScript to legacy, high-compatibility ECMAScript versions using Babel.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns {babel.BabelFileResult} Babel transpiler result for file.
 */
export function transpile(code: string, options?: Options): babel.BabelFileResult;

/**
 * Compiles CoffeeScript to JavaScript code, then outputs it as a string.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns {string} Compiled and unevaluated JavaScript code.
 */
export function compile(code: string, options?: Options): string;

/**
 * Parse a string of CoffeeScript code or an array of lexed tokens, and return the AST. You can then compile it by
 * calling `.compile()` on the root, or traverse it by using `.traverseChildren()` with a callback.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment
 *   at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns {CoffeeScriptASTBody} Compiled and unevaluated JavaScript code.
 */
export function nodes(code: string, options?: Options): ASTBody;

/**
 * Compiles and executes a CoffeeScript string in the NodeJS environment.
 * Evaluates `__filename` and `__dirname` correctly in order to execute the CoffeeScript input.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns Output of evaluated CoffeeScript code in the NodeJS environment.
 */
export function run(code: string, options?: Options): any;

/**
 * Compiles and executes a CoffeeScript string in a NodeJS-like browser environment.
 * The CoffeeScript REPL uses this to run the input.
 *
 * @function eval
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a Base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns Output of evaluated CoffeeScript code in the browser environment.
 */
export interface eval {
  (code: string, options?: Options): any;
} // hack to avoid TS eval call protection

/**
 * Node's module loader, patched to be able to handle multi-dot extensions.
 * This is a horrible thing that should not be required.
 */
export function register(): {
  [path: string]: object;
  (path: string): object;
};

/**
 * Synchronous module definitions for the CoffeeScript library files.
 *
 * @param {string} path Path to CoffeeScript library submodule relative to the `./lib/coffeescript` directory.
 * @returns {(object|undefined)} CoffeeScript library submodule.
 */
export interface require {
  [path: string]: object;
  (path: string): require[keyof require];
}

/**
 * Compiles a raw CoffeeScript file buffer string.
 * Requires UTF-8 character encoding on the `raw` input string.
 * Strip the Unicode byte order mark, if `filename` begins with one.
 *
 * @param {string} raw Raw UTF-8 CoffeeScript file contents.
 * @param {string} filename File name with extension (not including directories).
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a Base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @private
 */
export function _compileRawFileContent(raw: string, filename: string, options?: Options): string;

/**
 * Reads and compiles a CoffeeScript file using `fs.readFileSync`.
 * NodeJS wrapper around `coffeescript._compileRawFileContent`.
 * Files are decoded as if they are UTF-8 character encoded or compliant with UTF-8.
 *
 * @param {string} raw Raw UTF-8 CoffeeScript file contents.
 * @param {string} filename File name with extension (not including directories).
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a Base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @private
 */
export function _compileFile(filename: string, options?: Options): string;
